<!doctype html>
<head>
	 <meta charset="utf-8"/>
    <title>GFL cutscene interpreter</title>
     <link rel="preconnect" href="https://fonts.gstatic.com">
     <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR&display=swap" rel="stylesheet"> 
</head>
<style type="text/css">
body
{
	/*background-color: black;
	color: white*/
	text-align:center;
}

/*button
{
	background-color: black;
	color:white;
}*/

table, th, td {
   border: 1px solid #222222;
   border-collapse: collapse;
}
th {
	background-color: purple;
}

#head, #foot {
	height: 6%;
	min-height: 25px;
	width: 100%;
	background-color: #151515;
	overflow: hidden;
}

#head a {
  float: left;
  color: #f2f2f2;
  text-align: center;
  padding: 14px 16px;
  text-decoration: none;
  font-size: 17px;
}


#head a:hover {
  background-color: #ddd;
  color: black;
}

#head a.active {
  background-color: #4CAF50;
  color: white;
}


.flex-container {
  display: flex;
  flex-wrap: wrap;
  background-color: DodgerBlue;
  justify-content: center;
  align-items: center;
}

.flex-container > div {
  background-color: #f1f1f1;
  margin: 5px;
  /*padding: 20px;
  font-size: 30px;*/
}

tr:nth-child(odd) {
    background-color: #000000CC;
}
tr:nth-child(even) {
    background-color: #111111CC;
}

#verySimpleText{
	text-align: left;
}

.container {
  position: relative;
  text-align: center;
  color: white;
}

.charName {
      font-family: 'Noto Sans KR', sans-serif;
  position: absolute;
  top: 5px;
  left: 16px;
  font-size: 2vw;
}

.absText {
      font-family: 'Noto Sans KR', sans-serif;
  position: absolute;
  top: 45px;
  left: 16px;
  font-size: 2.2vw;
}
</style>
<script type="text/javascript"></script>
<!--<script src="phaser.min.js"></script>-->
<script src="https://cdn.jsdelivr.net/npm/phaser@3.24.1/dist/phaser.min.js"></script>
<script>
	/*
	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU Affero General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU Affero General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.

	This program is written by Rhythm Lunatic.
	*/
	
	/*
		Just gonna say it right now, I don't know an ounce of JavaScript or phaser.
		I interpreted lua and my game engine knowledge until this worked.
		
		So that's the answer as to why the chapter select looks like dogshit. Make a PR if you want it to be fixed.
	*/

	/* opcode dictionary
		Seriously who designed this, can't you use normal fucking opcodes?
		XXX() - Set portrait. XXX is character sprite. Can have multiple of these. Actually does not need to be the first opcode.
		; - Unknown purpose. Could be used for switching highlights? Seems to separate two portrait opcodes.
		<BGM> - Set BGM
		<BIN> - Set background
		<Speaker> - Set the speaker name
		|| - Separator. Things after this separator will be run later, maybe? Usually transition commands, shake effects, etc are after these
		<黑点X> - Black dot screen transition. X=1 for in, 2 for out.
		<黑屏X> - Black screen fade in and out
		<通讯框> - "Communication box". Display character portrait inside a communication box.
		<震屏> - Screen shake effect
		: - End of opcodes, text goes here (Other than +)
		+ - End text. Text will continue in a new box (no close/open animation) when clicked.
		
	*/
	//I kept accidentally typing print ok
	window.print = function(param)
	{
		console.log(param);
	}
	
	const opcode = {
		BGM : 1,
		BG : 2,
		SPEAKER : 3,
		MSG : 4,
		PORTRAIT : 5,
		NOPORTRAIT : 6,
		MSGBOXTRANSITION : 7,
		SETMASKEDPORTRAIT : 8
	}
	//For JSON structured
	const opcode2string = [
		'none',
		'bgm',
		'bg',
		'speaker',
		'msg',
		'portrait',
		'noPortrait',
		'msgboxTransition',
		'setMaskedPortrait'
	]
	
	const tag2opcode = {
		"Speaker":opcode.SPEAKER,
		"BIN":opcode.BG,
		"BGM":opcode.BGM,
		"通讯框":opcode.SETMASKEDPORTRAIT,
	}
	
	const backgrounds = {
		2: "机场",
		4: "主界面背景",
		6: "冰湖",
		8: "作战室avg",
		9: "black",
		10: "PlaybackBG1",
		15: "室内战斗",
	}
	
	const portraits = {
		"NPC-Kalin":[
			"special/版娘",
			"special/版娘-1",
			"special/版娘-2",
			"special/版娘-3",
			"special/版娘-4",
			"special/版娘-5",
			"special/版娘-6",
			"special/版娘-7",
			"special/版娘-8"
		]
	}
	
	//I moved everything to gfl subdomain so it's fine now
	//const portraitWebserver = "http://gfl.amaryllisworks.pw/pic/"
	
	//Don't care if it's all over the place. Fix it yourself. If this was SM I'd be using broadcasts anyways
	var nameActor;
	var bgActor;
	
	function loadBG(runtime, num)
	{
		console.log("Loading "+num+" | "+backgrounds[num])
		runtime.load.once('complete',function() { bgActor.setTexture(num);bgActor.displayWidth = 1280;bgActor.displayHeight= 1280; },runtime)
		runtime.load.image(num,'avgtexture/'+backgrounds[num]+'.png');
		runtime.load.start();
	}
	
	//A pool of portraits since there's gonna be more than one
	var portraitCollection = []
	function loadPortrait(runtime,name,type)
	{
		if (portraits[name] != undefined && portraits[name][type] != undefined)
		{
			let keyedPortrait=name+'-'+type;
			let fileName = portraits[name][type]+'.png'
			console.log("Loading "+fileName);
			if (portraitCollection.length == 0)
			{
				runtime.load.once('complete',function() { portraitCollection.push( runtime.add.image(game.config.width/2,game.config.height-100,keyedPortrait) ) } );
			
			}
			//Need logic for multi portraits!
			else
			{
				runtime.load.once('complete',function() { portraitCollection[0].setTexture(keyedPortrait) } );
			}
			runtime.load.image(keyedPortrait,'pic/'+fileName);
			runtime.load.start();
		}
	}
	
	//var interval;
	//Yes, I did translate it from lua. Lmao.
	class VNText4 {
		constructor(phaserRuntime,font,maxwidth,spd,msgTable)
		{
			this.phaserRuntime = phaserRuntime; //lol
			this.cur_len = 0;
			this.spd = spd;
			this.curIndex = 0;
			this.msgTable = msgTable;
			
			this.textActor = phaserRuntime.add.text(0,0,'Static Text Object', { fontFamily: 'Noto Sans KR', fontSize: 27, color: '#ffffff', wordWrap: {width:maxwidth,useAdvancedWrap:true} });
		}
		is_finished()
		{
			return this.cur_len == this.text.length;
		}
		
		//In StepMania you can just chain a command (within an actor) with sleep over and over, but in phaser you have to attach it to the game engine?
		//Attaching tweens to the game engine instead of actors is kind of a weird decision by the way, why wouldn't you attach them to the actor?
		//I'm using setInterval anyways
		play()
		{
			
			let f = function(self){
				self.cur_len = self.textActor.text.length;
				//console.log(self.cur_len+"/"+self.text.length);
				if (self.cur_len < self.text.length)
				{
					let txt = self.text.slice(0,self.cur_len+1)
					//console.log(txt);
					self.textActor.setText(txt);
				}
				else
				{
					clearInterval(f);
				}
			}
			
			f(this);
			
			//console.log(1/this.spd*1000);
			let interval = setInterval(f,1/this.spd*1000,this);
			//This can't possibly be high performance...
			
			/*phaserRuntime.tweens.add({
				targets:this.textActor,
				ease:'Linear',
				duration:1/this.spd,
				onComplete:this.play
			)}*/
				
			
		}
		Text()
		{
			this.cur_len = this.textActor.text;
			if (this.cur_len < this.text.length)
				this.textActor.setText(this.text.slice(0,this.cur_len));
		}
		advance()
		{
			if (this.no_more_text())
				return;
			//this.curIndex++;
			var noMsgYet = true;
			while (noMsgYet)
			{
				console.assert(this.msgTable[this.curIndex],"There is no opcode located at "+this.curIndex+". How did you even get this far?")
				let curMsg = this.msgTable[this.curIndex]
				let MsgOpcode = curMsg[0]
				//console.log(opcode)
				//console.log(this.curIndex);
				//console.log(MsgOpcode == opcode.MSG);
				switch(MsgOpcode) {
					case opcode.MSG:
						this.cur_len= 0
						this.text = curMsg[1]
						//this.text_actor:queuecommand("Check")
						noMsgYet = false;
						break;
					case opcode.SPEAKER:
						nameActor.setText(curMsg[1]);
						break;
					case opcode.BG:
						loadBG(this.phaserRuntime,curMsg[1]);
						break;
					case opcode.PORTRAIT:
						console.log(curMsg[1])
						loadPortrait(this.phaserRuntime,curMsg[1],curMsg[2])
						break;
					//lua junk from my message system. Just ignore it.
					/*case opcode.FMSG:
						this.cur_len= 0
						this.text = this.msgTable[this.curIndex][2]()
						//this.text_actor:queuecommand("Check")
						break outLoop;
					elseif opcode == "func" then
						this.msgTable[this.curIndex][2]()
					elseif opcode == "choice" then
						ChoiceTable = {Result=1,Finished=false}
						assert(this.msgTable[this.curIndex][2],"Choice table is invalid.")
						ChoiceTable.Choices = this.msgTable[this.curIndex][2]
						assert(ChoiceTable.Choices)
					elseif opcode == "exit" then
						return false;
					elseif opcode == "condJumpSS" then
						Trace(table_print(this.selfSwitches))
						Trace(table_print(this.msgTable[this.curIndex]))
						if this.selfSwitches[this.msgTable[this.curIndex][2]] == true then
							//Subtract 1 to account for advance advancing one step, since we want to start on whatever it jumps to
							this.curIndex = this.msgTable[this.curIndex][3]-1
							Trace("Jumped to index "..this.curIndex)
						end
					elseif opcode == "condJump" then
						if this.msgTable[this.curIndex][2]() == true then
							//Subtract 1 to account for advance advancing one step, since we want to start on whatever it jumps to
							this.curIndex = this.msgTable[this.curIndex][3]-1
							Trace("Jumped to index "..this.curIndex)
						end
					elseif opcode == "selfSwitch" then
						this.selfSwitches[this.msgTable[this.curIndex][2]] = this.msgTable[this.curIndex][3]
					end;*/
				}
				this.curIndex++;
				//console.log(noMsgYet);
			}
			//Trace(this.text)
			//lua.Flush();
			//this.text_actor:settext(""):playcommand("Check");
			//console.log(this.text)
			document.getElementById('curIndexDebug').innerText="idx: "+(this.curIndex-1)+" | msg: "+this.msgTable[(this.curIndex-1)].toString()
			this.textActor.setText('');
			this.play();
		}
		no_more_text()
		{
			return this.msgTable.length == this.curIndex;
		}
		skip()
		{
			this.textActor.setText(this.text);
			this.cur_len = this.text.length;
		}
	}
	
	/*class SpriteActor() {
		constructor()
		{
			//this.
		}
	}*/
	
	function sliceAndRemove(str, begin, end)
	{
		return str.slice(0,begin)+str.slice(end)
	}
	
	function getFromTag(str,tag)
	{
		const beginTag = "<"+tag+">"
		const endTag = "</"+tag+">"
		var n = str.indexOf(beginTag)
		if (n != -1){
			return str.slice(n+beginTag.length, str.indexOf(endTag))
		}
		return null
	}
	function removeTag(str,tag)
	{
		const beginTag = "<"+tag+">"
		const endTag = "</"+tag+">"
		return sliceAndRemove(str,str.indexOf(beginTag),str.indexOf(endTag)+endTag.length)
	}
	
	
	var config = {
		type: Phaser.WEBGL,
		width: 1280,
		height: 720,
		parent: 'phaser',
		scene: {
			preload: preload,
			create: create,
		}
	};
	
	//phaser
	var game;
	
	var imageActor;
	var vntext;
	
	function preload()
	{
		//this.load.image('test','test.png');
		this.load.image('textbox','textbox.png');
	}
	
	function create()
	{
		//input.touch only works on mobile devices. So it will break on desktop. reeeee
		//game.input.touch.capture = false;
		
		//var img = this.make.image({ x:game.config.width/2, y:game.config.height/2, key:'test',add:true })
		//img.displayWidth = game.config.width
		//img.displayHeight= game.config.height
		
		//GFL, in all of it's genius, uses 1024x1024 images. With black borders.
		/*bgActor = this.make.image({ x:game.config.width/2, y:game.config.height/2, add:true });
		bgActor.displayWidth = 1024
		bgActor.displayHeight= 1024*/
		bgActor = this.add.image(game.config.width/2,game.config.height/2);
		bgActor.texture = Phaser.Cache.DEFAULT;
		bgActor.setDepth(0);
		
		//Depth 2 is reserved for character portraits!
		
		imageActor = this.make.image({
			x:game.config.width /2,
			y:game.config.height-125,
			//scale:1,
			key:'textbox',
			add:true
		})
		imageActor.scaleY = 1
		imageActor.setDepth(3);
		
		//var blocks = this.add.group({ key: 'block', repeat: 139, setScale: { x: 0, y: 0 } });
		
		nameActor = this.add.text(240,500,'', { fontFamily: 'Noto Sans KR', fontSize: 30, color: '#ffffff' });
		nameActor.setDepth(4);
		
		//TODO
		vntext = new VNText4(this,'',800,13,currentEpisodeAsOpcodes[0]);
		vntext.textActor.x = 240;
		vntext.textActor.y = game.config.height-160
		vntext.textActor.setDepth(4);
		vntext.advance();
		
		this.input.on('pointerdown',function(){
			if (vntext.no_more_text())
			{
				console.log("Already hit the end!!!!");
			}
			else
			{
				if (vntext.is_finished())
				{
					vntext.advance();
				}
				else
				{
					vntext.skip();
				}
			}
		},vntext)
		//Hey look it's just like StepMania
		/*this.make.text({
			x: 100,
			y: 100,
			text: 'Phaser III',
			style: {
				fontSize: '48px',
				fontFamily: 'Arial',
				color: '#ffffff',
				metrics: {
				    ascent: 45,
				    descent: 10,
				    fontSize: 55
				}
			}
		})*/
	}
	
	//I'm not even using this lmao
	function update()
	{
		
	}
	
	function convertTextToOpcodes(out)
	{
		//console.log(out);
		var lines = out.split(/\r?\n/);
		//The GFL text system is stupid as fuck and I just spent a whole week writing my own VN system
		//So obviously I'm going to convert it to my own. fuck you
		//console.log(lines)
		//Fuck your opcodes
		let structuredLines = [];
		for(i=0;i<lines.length;i++)
		{
			if (!lines[i])
				continue;
			//print(lines[i]);
			let [cmds,text] = lines[i].replace("：",':').split(':')
			console.assert(cmds,lines[i])
			//console.assert(text,lines[i])
			
			//Yeah I know tags are supposed to be in order, No I don't really care sorry
			const tags = ["Speaker","BGM","BIN"]
			tags.forEach(tag => {
				//console.log(tag);
				let tagRes = getFromTag(cmds,tag);
				//console.log(tagRes)
				if (tagRes != null)
				{
					structuredLines.push([tag2opcode[tag],tagRes])
					removeTag(cmds,tag)
				}
			})
			//const tags = [
			if (cmds.includes("<通讯框>"))
			{
				structuredLines.push([opcode.SETMASKEDPORTRAIT])
				cmds.replace("<通讯框>","");
			}
			
			
			//So portraits are set in any order... But how the fuck are you supposed to tell when a name is if there's <> tags
			//I'm just going to search portraits after removing <> tags, it probably won't matter
			let numPortraits = 0;
			//Limit it to 5 because I don't want a dumb infinite loop that crashes the browser
			for(j=0;j<5;j++)
			{
				//console.log(cmds)
				let charTagEnd = cmds.indexOf(")");
				if (charTagEnd != -1)
				{
					let charTagStart = Math.max(cmds.lastIndexOf(";",charTagEnd),0)
					let [charID,charSpr] = cmds.slice(charTagStart,charTagEnd).split("(")
					//console.log(charID)
					//console.log(charSpr)
					//Ignore empty sprite IDs, they do nothing.
					if (charSpr != "")
					{
						numPortraits++;
						structuredLines.push([opcode.PORTRAIT,charID,charSpr])
					}
					//I think speaker name gets cleared if it's ()? Not sure
					//Portrait gets cleared
					else
					{
						structuredLines.push([opcode.NOPORTRAIT])
					}
					cmds = sliceAndRemove(cmds,charTagStart,charTagEnd+1);
				}
				else
				{
					//console.log("Done... Let's exit");
					break;
				}
			}
			
			//Now do text... But first check if there is any text (some lines are only commands)
			if (text)
			{
				text.split("+").forEach(msg => {
					structuredLines.push([opcode.MSG,msg])
				})
			}
			//open/close msgbox
			structuredLines.push([opcode.MSGBOXTRANSITION])
		}
		return structuredLines;
	}
	
	var curEpKey;
	var currentEpisodeAsOpcodes;
	
	//WHY DOES IT HAVE TO BE A SEPARATE FUNCTION
	/*async function fetchTextFile(fileName)
	{
		console.log("fetching "+fileName);
		const response = await fetch("avgtxt/"+fileName);
		console.log("got "+fileName);
		return await response.text();
		//const out = await response.text();
		//return out;
	}*/
	
	async function run(episode,curEpKey_)
	{
		currentEpisodeAsOpcodes = [];
		curEpKey = curEpKey_;
		
		document.getElementById('chapterName').innerText = episode['name'];
		
		//Instead of just one part, put all of them in the verySimpleText div.
		let NewSimpleTextDiv = document.createElement('div');
		NewSimpleTextDiv.id="verySimpleText";
		
		//let partNum = 0;
		for(var p = 0; p < episode.parts.length;p++)
		{
			let fileName = episode.parts[p];
			
			//We have to await so it doesn't load the parts in the wrong order. Which is an actual thing that has happened.
			console.log("fetching "+fileName);
			const response = await fetch("avgtxt/"+fileName);
			const out = await response.text();
			console.log("got "+fileName);
			
			//console.log(fetchTextFile("avgtxt/"+fileName));
			
			//fetch("avgtxt/"+fileName)
			//.then(response => response.text())
			//.then((out) => {
			//fetchTextFile(fileName).then(out => {
				//console.log('got '+fileName);
				let structuredLines = convertTextToOpcodes(out);
				
				//console.log(structuredLines)
				let s = "";
				structuredLines.forEach(line => {
					s+=opcode2string[line[0]]+','
					for(var i=1;i<line.length;i++)
						s+=line[i]
					s+='\r\n'
					//s+=line.toString()+"\r\n";
				})
				document.getElementById("DebugTextArea").value = s;
				
				
				let lastSpeakerName = "";
				
				//It has underscores because it's going to be cloned
				/*let _div_ = document.createElement('div');
				_div_.className="container";
				
				let _img_ = document.createElement("img");
				_img_.src="textbox.png";
				_img_.style.width="100%";
				_div_.appendChild(_img_);
				
				let charName = document.createElement("div");
				charName.className="charName";
				_div_.appendChild(charName);
				
				let text = document.createElement("div");
				text.className="absText";
				text.id="text";
				_div_.appendChild(text);
				
				//let textboxDiv = document.getElementById("Textboxes");
				let newTextboxDiv = document.createElement('div');
				newTextboxDiv.id="Textboxes";*/
				
				let thisPartDiv = document.createElement('div');
				let h3 = document.createElement('h3');
				//console.log(partNum);
				h3.innerText="Part "+(p+1);
				//partNum++;
				thisPartDiv.appendChild(h3);
				
				for(var i=0;i<structuredLines.length;i++)
				{
					if (structuredLines[i][0] == opcode.SPEAKER)
					{
						lastSpeakerName=structuredLines[i][1];
					}
					else if (structuredLines[i][0] == opcode.MSG)
					{
						/*let newTextbox = _div_.cloneNode(true);
						//console.log(newTextbox);
						newTextbox.getElementsByClassName("absText")[0].innerText = structuredLines[i][1]
						newTextbox.getElementsByClassName("charName")[0].innerText = lastSpeakerName;
						newTextboxDiv.appendChild(newTextbox);*/
						
						let p = document.createElement('p');
						if (lastSpeakerName == "")
							p.innerText = structuredLines[i][1];
						else
							p.innerText = lastSpeakerName + ": "+structuredLines[i][1];
						thisPartDiv.appendChild(p);
					}
					/*else if (structuredLines[i][0] == opcode.MSGBOXTRANSITION)
					{
						let p = document.createElement('p');
						p.innerText = "(newTextbox)";
						simpleTextDiv.appendChild(p);
					}*/
				}
				NewSimpleTextDiv.appendChild(thisPartDiv);
				//Now replace the old div...
				/*let textboxDiv = document.getElementById("Textboxes");
				textboxDiv.parentNode.replaceChild(newTextboxDiv,textboxDiv);*/
				
				//Init phaser
				//jk I don't want it automatic anymore
				currentEpisodeAsOpcodes.push(structuredLines);
			//})
		//})
		}
		let simpleTextDiv = document.getElementById("verySimpleText")
		simpleTextDiv.parentNode.replaceChild(NewSimpleTextDiv,simpleTextDiv);
	}
	
	function initPhaser()
	{
		game = new Phaser.Game(config);
		let button = document.getElementById("startButton")
		button.disabled = true
		button.innerText = "started!"
		
	}
	/*function reset()
	{
		game.restart()
	}*/
	
	function showOpcodes() {
		let x = document.getElementById("myDIV");
		if (x.style.display === "none") {
			x.style.display = "block";
		} else {
			x.style.display = "none";
		}
	}
	
	
	function getRoutableKeyString(type,chapter,episode)
	{
		return type+'-'+chapter+'-'+episode
	}
	function getKeysFromRoutableString(s)
	{
		return s.split('-');
	}
	
	function onChapterSelected(value)
	{
		console.log(value);
		let [type,chapter,episode] = getKeysFromRoutableString(value)
		run(listOfChapters[type][chapter]['episodes'][episode],value)
		document.getElementById("startButton").disabled = false
	}
	function goToNextEpisode()
	{
		let value = curEpKey;
		console.log(value);
		let [type,chapter,episode] = getKeysFromRoutableString(value)
		episode++;
		if (listOfChapters[type][chapter]['episodes'][episode])
		{
			run(listOfChapters[type][chapter]['episodes'][episode],getRoutableKeyString(type,chapter,episode))
			return true;
		}
		else
		{
			chapter++;
			episode = 0;
		}
		
		if (listOfChapters[type][chapter]['episodes'][episode])
		{
			run(listOfChapters[type][chapter]['episodes'][episode],getRoutableKeyString(type,chapter,episode))
			return true;
		}
		
		return false;
	}
	
	function appendFromij(i,j,name,letter)
	{
		return {
			name:  name+' '+i+'-'+j,
			parts: [i+'-'+j+'-1'+letter+'.txt',
					i+'-'+j+'-2'+letter+'.txt'],
		}
	}
	
	//name field is structured like type-chapter-episode
	listOfChapters={
		'main':[],
		'event':[],
		'side':[], //also skin
		'crossover':[]
	}
	function generateTables() {
		
		//Special for chapter 0
		{
			let chapterZero = []
			for(j=1;j<5;j++)
			{
				chapterZero.push(appendFromij(0,j,"Normal",''))
			}
			listOfChapters['main'].push({name:"Chapter 0",episodes:chapterZero});
		}
		//Normal chapters
		for(i=1;i<13;i++)
		{
			let curChapter = []
			for(j=1;j<=6;j++)
			{
				curChapter.push(appendFromij(i,j,"Normal",''))
			}
			for(j=1;j<=4;j++)
			{
				curChapter.push(appendFromij(i,j,"Emergency",'E'))
			}
			for(j=1;j<=4;j++)
			{
				curChapter.push(appendFromij(i,j,"Midnight",'N'))
			}
			listOfChapters['main'].push({name:'Chapter '+i,episodes:curChapter});
			
			//What am I supposed to do?
			/*if (i==5)
			{
				listOfChapters.push({
					name:"Operation Cube",
					episodes:[
						{name:"Seven Step Puzzle",begin:,mid:end:},
					]
				})
			}*/
		}
		
		//Events
		let prologue = []
		for(i=0;i<12;i++)
		{
			prologue.push({name:"Start"+i,parts:['startavg/Start'+i+".txt"]});
		}
		listOfChapters['event'].push({name:"Prologue",episodes:prologue});
		/*
		0|Chapter|EP.|00
		1|Chapter|EP.|01
		2|Chapter|EP.|02
		3|Chapter|EP.|03
		4|Chapter|EP.|04
		5|Chapter|EP.|05
		-1|Operation Cube|EP.|5.5
		6|Chapter|EP.|06
		7|Chapter|EP.|07
		-2,-3,-4,-5|Arctic Warfare|EP.|7.5
		-7|Operation Cube+|EP.|7.75
		8|Chapter|EP.|08
		-10,-11,-12,-13|Deep Dive|EP.|8.5
		9|Chapter|EP.|09
		10|Chapter|EP.|10
		-16,-17,-18|Singularity|EP.|10.5
		-24,-25,-26,-28|Continuum Turbulence|EP.|10.75
		11|Chapter|EP.|11
		*/
		
		let tDollEpisodes = []
		let knownFiles = ["1.txt", "11.txt", "1501.txt", "1502.txt", "1503.txt",
		"1504.txt", "1505.txt", "1506.txt", "1507.txt", "1801.txt", "1802.txt",
		"1803.txt", "1804.txt", "1805.txt", "1806.txt", "1807.txt", "1808.txt",
		"1901.txt", "1902.txt", "1904.txt", "1905.txt", "1906.txt", "2.txt",
		"2101.txt", "2102.txt", "2103.txt", "2104.txt", "2105.txt", "2106.txt",
		"2107.txt", "2108.txt", "2109.txt", "2301.txt", "2302.txt", "2303.txt",
		"2304.txt", "2305.txt", "2401.txt", "2403.txt", "2404.txt", "2405.txt",
		"2406.txt", "2407.txt", "2408.txt", "2409.txt", "2410.txt", "2601.txt",
		"2602.txt", "2603.txt", "2604.txt", "2605.txt", "2606.txt", "2801.txt",
		"2802.txt", "2803.txt", "2804.txt", "2805.txt", "2807.txt", "3.txt",
		"3001.txt", "3002.txt", "3003.txt", "3004.txt", "3005.txt", "3006.txt", 
		"3007.txt", "301.txt", "302.txt", "303.txt", "304.txt", "305.txt", 
		"306.txt", "307.txt", "308.txt", "309.txt", "310.txt", "3102.txt", 
		"3103.txt", "3105.txt", "3106.txt", "3107.txt", "3301.txt", "3302.txt", 
		"3303.txt", "3304.txt", "3305.txt", "3306.txt", "3307.txt", "3308.txt", 
		"3309.txt", "3501.txt", "3502.txt", "3503.txt", "3504.txt", "3505.txt", 
		"1903.txt", "2402.txt", "2806.txt", "3101.txt", "3506.txt", "4203.txt", 
		"3507.txt", "3801.txt", "3802.txt", "3803.txt", "3805.txt", "3806.txt", 
		"3807.txt", "3808.txt", "3809.txt", "4.txt", "4001.txt", "4002.txt", 
		"4003.txt", "4004.txt", "4005.txt", "4006.txt", "4007.txt", "4201.txt",
		 "4202.txt", "4204.txt", "4205.txt", "4206.txt", "4207.txt", "4209.txt", 
		 "4210.txt", "4301.txt", "4302.txt", "4303.txt", "4304.txt", "4305.txt",
		  "4306.txt", "4308.txt", "4309.txt", "4310.txt", "5.txt", "6.txt", "7.txt",
		   "8.txt", "801.txt", "802.txt", "803.txt", "804.txt", "805.txt", "806.txt", 
		   "807.txt", "808.txt", "9.txt"]
		for (i=0;i<knownFiles.length;i++)
			tDollEpisodes.push({name:knownFiles[i],parts:['skin/'+knownFiles[i]]});
		listOfChapters['side'].push({name:"Skin Stories",episodes:tDollEpisodes});
		
		
		var _table_ = document.createElement('table'),
			_tr_ = document.createElement('tr'),
			_th_ = document.createElement('th'),
			_td_ = document.createElement('td'),
			_select_ = document.createElement('select'),
			_option_ = document.createElement('option');
		
		//var table = document.getElementById("table");
		//let thead = document.createElement("thead");
		//thead.innerHTML = "<tr><th colspan='"+listOfChapters.length+"'>Pick a chapter</th></tr>"
		//table.appendChild(thead);
		
		//Behold, the most god awful code ever written
		//let tbody = document.createElement('tbody');
		
		/*let trChapterNames = _tr_.cloneNode(false);
		for(i=0;i<listOfChapters.length;i++)
		{
			let td = _td_.cloneNode(false);
			td.appendChild(document.createTextNode(listOfChapters[i]['name']));
			trChapterNames.appendChild(td);
		}
		tbody.appendChild(trChapterNames);*/
		
		for (const key in listOfChapters)
		{
			let episodeContainer = document.getElementById(key+'Episodes')
			let trChapterDropdowns = _tr_.cloneNode(false);
			for(i=0;i<listOfChapters[key].length;i++)
			{
				//let td = _td_.cloneNode(false);
				let flexBoxDiv = document.createElement('div');
				let select = _select_.cloneNode(false);
				select.setAttribute('id',"selectChapter"+i)
				select.setAttribute('onchange','onChapterSelected(value);');
				
				//Generate chapter name first..
				let optChName = _option_.cloneNode(false);
				optChName.setAttribute("selected","");
				optChName.setAttribute("disabled","");
				optChName.innerText=listOfChapters[key][i]['name'];
				select.appendChild(optChName);
				
				//Now let's do the episodes
				let curChapter = listOfChapters[key][i]['episodes'];
				for(j=0;j<curChapter.length;j++)
				{
					let option = _option_.cloneNode(false);
					option.value=getRoutableKeyString(key,i,j)
					option.innerText=curChapter[j]['name'];
					select.appendChild(option);
				}
				flexBoxDiv.appendChild(select);
				
				episodeContainer.appendChild(flexBoxDiv);
				//td.appendChild(select);
				//trChapterDropdowns.appendChild(td);
			}
		}

		//tbody.appendChild(trChapterDropdowns);
		
		//table.appendChild(thead);
		//table.appendChild(tbody);
		
		console.log(listOfChapters);
		return listOfChapters;
	}
	
	function showSelectedEpisodes(id)
	{
		let episodesDivs = document.getElementById("Episodes").children;
		for (var i = 0; i < episodesDivs.length;i++){
			if (episodesDivs[i].id == id)
				episodesDivs[i].style="";
			else
				episodesDivs[i].style="display: none;"
		}
		//console.log(episodesDiv.children);
	}
	
	window.onload=function()
	{
		generateTables();
		showSelectedEpisodes('mainEpisodes');
	}
</script>
<body>
	<h1 id="theTop">GFL Cutscene Intrepeter (very alpha)</h1>
	<!--<h2>...And a way to read the game dialogue.</h2>-->
	<div id='chapterSelect'>
		<div id='head'>
			<a href="#" onclick="showSelectedEpisodes('mainEpisodes');return false;">Main Story Chapters</a>
			<a href="#" onclick="showSelectedEpisodes('eventEpisodes');return false;">Story Events</a>
			<a href="#" onclick="showSelectedEpisodes('sideEpisodes');return false;">Side Stories</a>
			<a href="#" onclick="showSelectedEpisodes('crossoverEpisodes');return false;">Crossover Stories</a>
			<a href="#" onclick="return false;">T-Doll Dialogue (coming eventually)</a>
		</div>
		<div id="Episodes">
			<div class="flex-container" id="mainEpisodes"></div>
			<div class="flex-container" id="eventEpisodes"></div>
			<div class="flex-container" id="sideEpisodes"></div>
			<div class="flex-container" id="crossoverEpisodes"></div>
		</div>
		
	</div>
	<!--<h2><a href="#Textboxes">Mobile devices are stupid and the canvas absorbs touch, so click here to jump to the part without the canvas</a></h2>-->
	<!---->

	<h2 id="chapterName">Chapter Name Here</h2>
    <button id="startButton" onclick="initPhaser()" disabled>Start interactive interpreter (It's like playing the game!)</button>
	<p id="curIndexDebug"></p>
	<div id="phaser"></div>
	<br><br><button onclick='showOpcodes()'>Show converted opcodes (For debugging)</button><br>
	<div id='myDIV' style="display: none;">
		<textarea rows='6' cols='50' id="DebugTextArea"></textarea><br>
		<button disabled>Re-run scene with these opcodes (Unimplemented)</button>
	</div>
	<!--<canvas id="myCanvas" width="1280" height="720"></canvas>--><br><br>
    <!--<h1 id="title">This is a header!</h1>-->
	<!--<img src="textbox.png"></img>-->
	<!--<h2><a href="#verySimpleText">Click HERE to jump to the text without any textboxes which is probably what you want anyways</a></h2>
	<h2>Static Textboxes</h2>
	<div id="Textboxes"></div>-->
	<hr>
	<h2>Text Only (+Text Modifiers)</h2>
	<div id="verySimpleText"></div>
	<a href="#theTop">Back to top</a> <a href="#theTop" onclick="goToNextEpisode();">Go to the next cutscene</a>
	<hr>
	<p>Dandelai is my wife, greets to /gfg/, <a href="https://github.com/RhythmLunatic/gfl-cutscene-interpreter">harass me on github (bug reports, check the source code, fork it)</a></p>
	<p>Can someone please fix the horrible UI? I'm a programmer, not a designer. Please fork the source code and make a pull request.</p>
	<p>If you want a feature or something is broken, <b><a href="https://github.com/RhythmLunatic/gfl-cutscene-interpreter/issues">file a bug report</a></b></p>
	<br>
	<!--<a href="https://github.com/RhythmLunatic/Girls-Frontline-Discord-Search">Try out my Girls' Frontline discord bot. T-Doll info, quotes, costumes, and more!</a>-->
</body>
