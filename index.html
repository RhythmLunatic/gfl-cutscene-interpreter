<!doctype html>
<head>
	<meta charset="utf-8"/>
	<title>GFL cutscene interpreter</title>
	
	<!--Let browser know website is optimized for mobile-->
	<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
	
	<!-- Favicon and mobile browser 'webpage as app' support -->
	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
	<meta name="msapplication-TileColor" content="#2b5797">
	<meta name="theme-color" content="#09004c">
	
	<!--For discord description -->
	<meta property="og:title" content="Girls' Frontline Cutscene Interpreter" />
	<meta property="og:type" content="website" />
	<meta property="og:url" content="http://gfl.amaryllisworks.pw" />
	<!--<meta property="og:image" content="http://my.site.com/images/thumb.png" />-->
	<meta property="og:description" content="Read cutscenes from Girls' Frontline in the web browser." />
	<meta name='description' content="Read cutscenes from Girls' Frontline in the web browser." />
	
	<!--Resources -->
	<link rel="preconnect" href="https://fonts.gstatic.com">
	<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500&display=swap" rel="stylesheet">  
	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
	<!--<link type="text/css" rel="stylesheet" href="materialize.css"  media="screen,projection"/>-->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
	
	<!--This stuff doesn't even work correctly and I haven't used it in ages
	<link rel="stylesheet" type="text/css" href="./tln.css"/>
	<script type="text/javascript" src="./tln.js"></script>
	-->
</head>
<style type="text/css">
body
{
	/*background-color: black;
	color: white*/
	text-align:center;
	--bg-color: white;
	--text-color: black;
	--nav-color: #ee6e73;
	--nav-color-hover: #bf4040;
	--btn-color: #26a69a;
	--card-color: #fff;
	--collection-item-color:#fff;
	--dropdown-text-color:#26a69a;
	--dropdown-hover-color:#eee;
	--settings-row-border-color: rgba(0, 0, 0, 0.12);
	--colored-dialogue: brightness(0.6);
	
	background-color: var(--bg-color);
	color: var(--text-color);
}

body.dark-theme{
	--bg-color: #333333;
	--text-color: white;
	--nav-color:#1a237e;
	--nav-color-hover:#3465a4;
	--btn-color: #26a69a;
	--card-color: #455a64;
	--collection-item-color:#2b2b2b;
	--dropdown-text-color: white;
	--dropdown-hover-color: black;
	
	--settings-row-border-color: rgba(255, 255, 255, 0.5);
	--colored-dialogue: brightness(1.0);
}
body.black-theme{
	--bg-color: black;
	--text-color: white;
	--nav-color: #212121;
	--btn-color: #455a64;
	--card-color: #2e3436;
	--collection-item-color: black;
	--dropdown-text-color: white;
	--dropdown-hover-color: black;
	
	--settings-row-border-color: rgba(255, 255, 255, 0.8);
	--colored-dialogue: brightness(1.0);
}

nav {
	background-color: var(--nav-color);
}
textarea{
	color:var(--text-color);
}
input{
	color:var(--text-color);
}
h2 {
	margin: 1.424rem 0 1.424rem 0;
}

.textarea-wrapper{
	/*border:1px solid red;*/
	position:relative;
	height:500px;
	width:700px;
	margin:15px auto
}
/*.textarea-wrapper::before {
	content:"wrapper";
	text-transform: uppercase;
	left:0px;
	position:absolute;
	top:-18px;
	font-size:16px;
	color:red;
}*/

/*table, th, td {
   border: 1px solid #222222;
   border-collapse: collapse;
}
th {
	background-color: purple;
}*/

.header-desktop{
	display: inline-block;
}
.header-desktop-shorter{
	display: none;
}
.header-mobile{
	display: none;
}

.chapterTitles-mobile{
	display: none;
}

@media screen and (max-width: 900px) {
    .header-desktop{
       display:none;
    }
    
    .header-desktop-shorter{
       display:inline-block;
    }
    
    .chapterTitles-desktop{
		display: none;
	}
	.chapterTitles-mobile{
		display: block;
	}
    
    .navbarButton{
    	padding: 0 5px; /*Since text is hidden, remove the padding between buttons*/
    }
    
    .modal {
    	width:100%;
    	max-height:100%;
    	height:100%;
    	top:0 !important;
    }
    .modal.modal-fixed-footer{
    	height:100%;
    }
}

@media screen and (max-width: 500px) {
    .header-desktop{
       display:none;
    }
    .header-desktop-shorter{
       display:none;
    }
    
    .header-mobile{
       display:inline-block;
    }
}

.btn {
	background-color: var(--btn-color);
}
.card {
	background-color: var(--card-color);
}
.modal {
	background-color: var(--bg-color);
	/* sadly animating 'top' breaks the modal showing */
	transition: width 0.2s ease-out, height 0.2s ease-out;
}
.collection .collection-item{
	background-color: var(--collection-item-color)
}
.dropdown-content{
	background-color: var(--card-color);
}
.dropdown-content li > a {
	color: var(--dropdown-text-color);
}
.dropdown-content li:hover, .dropdown-content li.active {
  background-color: var(--dropdown-hover-color);
}

.collapsible-header {
	background-color: var(--collection-item-color);
}

.pagination{
	max-width:700px;
	margin-left:auto;
	margin-right:auto;
}
.pagination li a {
	color: var(--text-color);
}
.pagination li.active {
	background-color: var(--nav-color);
}
.pagination li.active:hover{
	background-color:var(--nav-color-hover);
}
.pagination li {
	margin-left: 5px;
	margin-top: 5px;
}

/*Something I actually wrote myself*/
.material-settings-table {
	padding: 0px;
}
.material-settings-table td {
	padding: 0px;
}
.material-settings-table p {
	margin: 0px;
}
.material-settings-table tr {
	border-bottom-color: var(--settings-row-border-color);
}

.material-settings-table .title {
	font-weight: bold;
	font-size:120%
}
.modal .modal-footer {
	background-color: rgba(128,128,128,0.3);
}
.modal .modal-footer > a {
	color: var(--text-color);
}

/*#head, #foot {
	height: 6%;
	min-height: 25px;
	width: 100%;
	background-color: #151515;
	overflow: hidden;
}

#head a {
  float: left;
  color: #f2f2f2;
  text-align: center;
  padding: 14px 16px;
  text-decoration: none;
  font-size: 17px;
}


#head a:hover {
  background-color: #ddd;
  color: black;
}

#head a.active {
  background-color: #4CAF50;
  color: white;
}*/

.tabs {
    display:-webkit-flex;
    display: -ms-flexbox;
    display: flex
}




.flex-container {
  display: flex;
  flex-wrap: wrap;
  /*background-color: DodgerBlue;*/
  justify-content: center;
  align-items: center;
}

.flex-container > div {
  background-color: #f1f1f1;
  margin: 5px;
  /*padding: 20px;
  font-size: 30px;*/
}

/*tr:nth-child(odd) {
    background-color: #000000CC;
}
tr:nth-child(even) {
    background-color: #111111CC;
}*/



#verySimpleText{
	text-align: left;
	font-family: 'Noto Sans KR', sans-serif;
	margin-left: 10px;
	margin-right: 10px;
}
.coloredDialogue{
	filter: var(--colored-dialogue);
}

/*To make everything nice and centered on desktop.*/
@media screen and (min-width:701px) {

	#verySimpleText{
		margin-left: 0px;
		margin-right: 0px;
		width: 700px; 
		margin: 0 auto;
	}
}

/*.container {
  position: relative;
  text-align: center;
  color: white;
}

.charName {
  font-family: 'Noto Sans KR', sans-serif;
  position: absolute;
  top: 5px;
  left: 16px;
  font-size: 2vw;
}

.absText {
      font-family: 'Noto Sans KR', sans-serif;
  position: absolute;
  top: 45px;
  left: 16px;
  font-size: 2.2vw;
}*/


/*.speakerName{
	font-weight: bold;
}*/



.snow{
	background-image:
        url(snow1.png),
           url(snow2.png),
           url(snow3.png);
	animation: snow 30s linear infinite;
}

@keyframes snow {
    0% {background-position: 0px 0px, 0px 0px, 0px 0px;}
    100% {background-position: 500px 1000px, 400px 400px, 300px 300px}
}


.storyText {
	margin-top: 0.5ex;
	margin-bottom: 0.5ex;
	overflow-wrap: break-word;
}

.storyText.speakerName {
	/*margin-top: 0;*/
	font-weight: bold;
}

/*
Blatantly stolen from gfl.zzzzz.kr 
I have no idea how it works
*/
.storyImg{
	position:relative;
	overflow:hidden; /*Keep portraits within div */
	width:100%;
	margin-top:1.5rem;
}
.storydoll{
	width:71%; /*You're probably wondering why this is 71% instead of 70%. After all, left:15% will create the remaining 30% to center the image right? Well it turns out that the heads of most images are slightly to the left and not centered. I think gfl.zzzzz.kr did it on purpose so it would look slightly more centered. */
	position: absolute;
	bottom: -30%;
	z-index: 5; /*higher number means it's drawn in front */
}
.storydoll.one{
	left:15%; /*Margin of 15%, which also creates a right margin of 15%, which adds up the remaining 30% in 'width' in storyImg class */
}
.storydoll.first.two{
	right:35%
}
.storydoll.second.two{
	left:35%
}

.storydoll.dim{
	filter: brightness(50%);
	z-index:4;
}
.storydoll.mask {
	mask-position: center;
	mask-size: 100%; /* I don't know why 100% works but it does */
	-webkit-mask-size: 100%;
	filter: brightness(300%) opacity(75%);
}

.maskcontainer{
	z-index:5;
}
.maskcontainer.one{
	left:35%; /*This is a guess, I don't know how it works */
}
.maskcontainer.first.two{
	left:15%;
}
.maskcontainer.second.two{
	left:55%
}
/*Should probably fix later */
.maskcontainer.dim{
	z-index:4;
}
.maskcontainer > div > img.dim{
	filter: brightness(50%);
}

/*.storydoll.saying{
	filter: brightness(100%);
	z-index: 100;
}*/

#SearchResults {
	cursor: pointer;
	display: block;
	text-align: left;
}
/*lol */
.collection-item.waves-effect {
	display: inherit;
}

</style>
<!-- tfw no bandwidth -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
<!--<script type="text/javascript" src="junk/materialize.js"></script>-->
<!--<script src="phaser.min.js"></script>-->
<script src="https://cdn.jsdelivr.net/npm/phaser@3.24.1/dist/phaser.min.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.js"></script>


<!--Helper functions-->
<script>
	//https://stackoverflow.com/a/57401891
	/*function adjustColor(color, amount) {
		return '#' + color.replace(/^#/, '').replace(/../g, color => ('0'+Math.min(255, Math.max(0, parseInt(color, 16) + amount)).toString(16)).substr(-2));
	}*/
	
	//https://www.w3schools.com/js/js_cookies.asp
	function setCookie(cname, cvalue, exdays) {
		var d = new Date();
		d.setTime(d.getTime() + (exdays*24*60*60*1000));
		var expires = "expires="+ d.toUTCString();
		document.cookie = cname + "=" + cvalue + ";SameSite=Lax;" + expires + ";path=/";
	}
	function getCookie(cname) {
		var name = cname + "=";
		var decodedCookie = decodeURIComponent(document.cookie);
		var ca = decodedCookie.split(';');
		for(var i = 0; i <ca.length; i++) {
			var c = ca[i];
			while (c.charAt(0) == ' ') {
				c = c.substring(1);
			}
			if (c.indexOf(name) == 0) {
				return c.substring(name.length, c.length);
			}
		}
		return "";
	}
	
	//https://stackoverflow.com/a/29998400
	function JavaSplit(string,separator,n) {
		var split = string.split(separator);
		if (split.length <= n)
			return split;
		var out = split.slice(0,n-1);
		out.push(split.slice(n-1).join(separator));
		return out;
	}
	
	
	/**
	 * String.prototype.replaceAll() polyfill
	 * https://gomakethings.com/how-to-replace-a-section-of-a-string-with-another-one-with-vanilla-js/
	 * @author Chris Ferdinandi
	 * @license MIT
	 */
	if (!String.prototype.replaceAll) {
		String.prototype.replaceAll = function(str, newStr){

			// If a regex pattern
			if (Object.prototype.toString.call(str).toLowerCase() === '[object regexp]') {
				return this.replace(str, newStr);
			}

			// If a string
			return this.replace(new RegExp(str, 'g'), newStr);

		};
	}

</script>
<!--The main program-->
<script>
	/*
	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU Affero General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU Affero General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.

	This program is written by Rhythm Lunatic.
	*/


	//I kept accidentally typing print ok
	window.print = function(param)
	{
		console.log(param);
	}
	function consoleWarn(param)
	{
		console.log("%c "+param,'background: black; color: yellow')
	}
	
	
	//FOR T-DOLL DISPLAY
	gfcolors = [
		"#000000", //NPCs & SF - Black?
		"0",        //Nothing has 1 stars.
		"#adadad", //2 stars   - Grey
		"#6bdfce", //3 stars   - Turquoise
		"#d6e35a", //4 stars   - Green
		"#ffb600", //5 stars   - Orange
		"#ff6a00", //6 stars   - Orange
		"#dfb6ff"  //EXTRAstar - Purple
	]
	
	function num2stars(div, numStars)
	{
		var _star_ = document.createElement("i");
		_star_.className = "material-icons";
		
		if (numStars < 1)
		{
		
		}
		else if (numStars == 7)
		{
			var star = _star_.cloneNode(false);
			star.innerHTML = "stars"
			star.style.color = gfcolors[7];
			div.appendChild(star);
		}
		else if (numStars > 5)
		{
			for (var j=0;j<numStars;j++)
			{
				var star = _star_.cloneNode(false);
				star.innerHTML = "star";
				star.style.color = gfcolors[numStars];
				div.appendChild(star);
			}
		}
		else
		{
			for (var j=0;j<5;j++)
			{
				var star = _star_.cloneNode(false);
				if (j < numStars)
					star.innerHTML = "star";
				else
					star.innerHTML = "star_border";
				star.style.color = gfcolors[numStars];
				div.appendChild(star);
			}
		}
	}
	
	
	//Night mode
	isDarkMode=false;
	function NightMode()
	{
		let theme = "dark-theme"
		if (document.body.classList.contains("dark-theme"))
		{
			theme='black-theme';
			document.body.classList.replace("dark-theme",theme);
			isDarkMode=true
		}
		else if (document.body.classList.contains("black-theme"))
		{
			theme='light-theme';
			document.body.classList.replace("black-theme",theme);
			isDarkMode=false;
		}
		else
		{
			document.body.classList.replace('light-theme',theme);
			isDarkMode=true;
		}
		setCookie('theme',theme,180);
	}
	
	//interpreter related
	
	const OPCODES = {
		STOPBGM : 0,
		BGM : 1,
		BG : 2,
		SPEAKER : 3,
		MSG : 4,
		PORTRAIT : 5,
		NOPORTRAIT : 6,
		MSGBOXTRANSITION : 7,
		SNOWEFFECT : 8,
		STOPEFFECTS : 9,
		NIGHTFILTER : 10,
		FADEOUT : 11,
		FADEIN : 12,
		CHOICE : 13,
		DESTINATION : 14,
		CREDITS : 15
		//SETMASKEDPORTRAIT : 8
	}
	
	//For JSON structured or making your own
	//Pro tip: use opcode2string.indexOf(s) to get the opcode number
	const opcode2string = [
		'stopBGM',
		'bgm',
		'bg',
		'speaker',
		'msg',
		'portrait',
		'noPortrait',
		'msgboxTransition',
		'snowEffect',
		'stopEffect',
		'nightFilter',
		'fadeOut',
		'fadeIn',
		'choice',
		'destination',
		'credits'
		//'setMaskedPortrait'
	]
	
	const tag2opcode = {
		"Speaker":OPCODES.SPEAKER,
		"BIN":OPCODES.BG,
		"BGM":OPCODES.BGM,
		"下雪":OPCODES.SNOWEFFECT,
		"火焰销毁":OPCODES.STOPEFFECTS,
		"Night":OPCODES.NIGHTFILTER,
		"黑屏1":OPCODES.FADEOUT,
		"黑屏2":OPCODES.FADEIN,
		'分支':OPCODES.DESTINATION,
		'名单':OPCODES.CREDITS
		//"通讯框":OPCODES.SETMASKEDPORTRAIT,
	}
	

	//To be loaded later or on-demand.
	let PORTRAITS = undefined;
	let BACKGROUNDS = undefined;
	let MUSIC = undefined;
	let CREDITSDATA = undefined;
	/*
	Night backgrounds are generated using html canvas,
	then to speed up their result is kept in memory in this table and indexed
	by the name of the original file
	*/
	let nightBackgrounds = {};
	//Check if nightBG generation is already queued for a BG
	let nightBGQueue = {};
	
	//For CSS
	var int2str = ['zero','one',  'two',   'three','four',  'five', 'six',  'seven',  'eight', 'nine']
	var int2strPos = ['N','first','second','third','fourth','fifth','sixth','seventh','eighth','ninth']
	
	//I moved everything to gfl subdomain so it's fine now
	//const portraitWebserver = "http://gfl.amaryllisworks.pw/pic/"
	
	function portraitStructToString(p)
	{
		return "idx: "+p[1]+" | name: "+p[2]+" | type: "+p[3]+" | dim: "+p[4]+" | isMasked: "+p[5]
	}
	
	//Don't care if it's all over the place. Fix it yourself. If this was SM I'd be using broadcasts anyways
	var nameActor;
	var bgActor;
	
	function loadBG(runtime, num)
	{
		console.log("Loading "+num+" | "+BACKGROUNDS[num])
		runtime.load.once('complete',function() { bgActor.setTexture(num);bgActor.displayWidth = 1280;bgActor.displayHeight= 720; },runtime)
		runtime.load.image(num,'avgtexture/'+BACKGROUNDS[num]+'.png');
		runtime.load.start();
	}
	
	var p3BGM;
	function loadBGM(runtime, fileName)
	{
		if (p3BGM != undefined)
			p3BGM.destroy();
		console.log("Loading "+fileName)
		runtime.load.once('complete',function() { 
			p3BGM = this.sound.add(fileName);
			p3BGM.play();
		},runtime)
		
		runtime.load.audio(fileName,[
			'audio/'+fileName+".ogg",
			'audio/'+fileName+".mp3" //Imagine using a browser that doesn't support ogg
		]);
		runtime.load.start();
	}
	//A pool of portraits since there's gonna be more than one
	var portraitCollection = []
	function loadPortrait(runtime,idx,name,type)
	{
		if (PORTRAITS[name] != undefined && PORTRAITS[name][type] != undefined)
		{
			let keyedPortrait=name+'-'+type;
			let fileName = PORTRAITS[name][type]
			console.log("Loading "+fileName);
			if (idx > portraitCollection.length-1)
			{
				runtime.load.once('complete',function() { portraitCollection.push( runtime.add.image(game.config.width/2,game.config.height-100,keyedPortrait) ) } );
			}
			else
			{
				runtime.load.once('complete',function() { portraitCollection[idx].setTexture(keyedPortrait) } );
			}
			runtime.load.image(keyedPortrait,'pic/'+fileName);
			runtime.load.start();
		}
		else
		{
			console.log("Portrait "+name+" missing from database.")
		}
	}
	
	//var interval;
	//Yes, I did translate it from lua. Lmao.
	class VNText4 {
		constructor(phaserRuntime,font,maxwidth,spd,msgTable)
		{
			this.phaserRuntime = phaserRuntime; //lol
			this.cur_len = 0;
			this.spd = spd;
			this.curIndex = 0;
			this.msgTable = msgTable;
			
			this.textActor = phaserRuntime.add.text(0,0,'Static Text Object', { fontFamily: 'Noto Sans KR', fontSize: 27, color: '#ffffff', wordWrap: {width:maxwidth, useAdvancedWrap:true} });
			
			
		}
		is_finished()
		{
			return this.cur_len == this.text.length;
		}
		
		//I finally found the correct way to do it
		play()
		{
			
			//console.log(this.text.length);
			this.timer = this.phaserRuntime.time.addEvent({
				targets:this.textActor,
				delay:1/this.spd*1000,
				callback: function() {
					this.textActor.setText(this.text.slice(0,this.textActor.text.length+1))
				},
				callbackScope: this,
				repeat: this.text.length,
			});
			
		}
		Text()
		{
			this.cur_len = this.textActor.text;
			if (this.cur_len < this.text.length)
				this.textActor.setText(this.text.slice(0,this.cur_len+1));
		}
		//Why is the processing code here? Why did I write it like this?
		advance()
		{
			if (this.no_more_text())
				return;
			//this.curIndex++;
			var noMsgYet = true;
			while (noMsgYet)
			{
				console.assert(this.msgTable[this.curIndex],"There is no opcode located at "+this.curIndex+". How did you even get this far?")
				let curMsg = this.msgTable[this.curIndex]
				let MsgOpcode = curMsg[0]
				//console.log(opcode)
				//console.log(this.curIndex);
				//console.log(MsgOpcode == OPCODES.MSG);
				switch(MsgOpcode) {
					case OPCODES.MSG:
						this.cur_len= 0
						this.text = curMsg[1]
						//this.text_actor:queuecommand("Check")
						noMsgYet = false;
						break;
					case OPCODES.SPEAKER:
						nameActor.setText(curMsg[1]);
						break;
					case OPCODES.BG:
						loadBG(this.phaserRuntime,curMsg[1]);
						break;
					case OPCODES.PORTRAIT:
						console.log(portraitStructToString(curMsg))
						loadPortrait(this.phaserRuntime,curMsg[1],curMsg[2],curMsg[3])
						break;
					case OPCODES.BGM:
						loadBGM(this.phaserRuntime,curMsg[1]);
						break;
					//lua junk from my message system. Just ignore it.
					/*case OPCODES.MSG:
						this.cur_len= 0
						this.text = this.msgTable[this.curIndex][2]()
						//this.text_actor:queuecommand("Check")
						break outLoop;
					elseif opcode == "func" then
						this.msgTable[this.curIndex][2]()
					elseif opcode == "choice" then
						ChoiceTable = {Result=1,Finished=false}
						assert(this.msgTable[this.curIndex][2],"Choice table is invalid.")
						ChoiceTable.Choices = this.msgTable[this.curIndex][2]
						assert(ChoiceTable.Choices)
					elseif opcode == "exit" then
						return false;
					elseif opcode == "condJumpSS" then
						Trace(table_print(this.selfSwitches))
						Trace(table_print(this.msgTable[this.curIndex]))
						if this.selfSwitches[this.msgTable[this.curIndex][2]] == true then
							//Subtract 1 to account for advance advancing one step, since we want to start on whatever it jumps to
							this.curIndex = this.msgTable[this.curIndex][3]-1
							Trace("Jumped to index "..this.curIndex)
						end
					elseif opcode == "condJump" then
						if this.msgTable[this.curIndex][2]() == true then
							//Subtract 1 to account for advance advancing one step, since we want to start on whatever it jumps to
							this.curIndex = this.msgTable[this.curIndex][3]-1
							Trace("Jumped to index "..this.curIndex)
						end
					elseif opcode == "selfSwitch" then
						this.selfSwitches[this.msgTable[this.curIndex][2]] = this.msgTable[this.curIndex][3]
					end;*/
				}
				this.curIndex++;
				//console.log(noMsgYet);
			}
			//Trace(this.text)
			//lua.Flush();
			//this.text_actor:settext(""):playcommand("Check");
			//console.log(this.text)
			document.getElementById('curIndexDebug').innerText="idx: "+(this.curIndex-1)+" | msg: "+this.msgTable[(this.curIndex-1)].toString()
			this.textActor.setText('');
			this.play();
		}
		no_more_text()
		{
			return this.curIndex >= this.msgTable.length-1;
		}
		skip()
		{
			this.textActor.setText(this.text);
			this.cur_len = this.text.length;
			this.timer.destroy();
		}
	}
	
	/*class SpriteActor() {
		constructor()
		{
			//this.
		}
	}*/
	
	//Shamelessly stolen from http://www.permadi.com/tutorial/jsCanvasGrayscale/index.html
	//Technically this could be reimplemented and run much faster if it was WebGL with a GLSL shader. Dunno if you can export it as an image like a canvas though.
	function nightFilter(image)
	{
		//console.log("processing "+image.src);
	  var myCanvas=document.createElement("canvas");
	  var myCanvasContext=myCanvas.getContext("2d");

		var imgWidth=image.naturalWidth;
		var imgHeight=image.naturalHeight;
	  // You'll get some string error if you fail to specify the dimensions
	  myCanvas.width= imgWidth;
	  myCanvas.height=imgHeight;
	  myCanvasContext.drawImage(image,0,0);

	  // This function cannot be called if the image is not from the same domain.
	  // You'll get security error if you do.
	  var imageData=myCanvasContext.getImageData(0,0, imgWidth, imgHeight);
	  
		//console.log(imageData.width +"x"+imageData.height);

		//debugger;
		/*
		imageData.data is a massive array of every pixel in the image
		order is R,G,B,A for every pixel, so it's pixels in image times 4
		We're only modifying red and green here
		*/
		for (j=0; j<imageData.data.length; j+=4)
		{
			var red=imageData.data[j];
			var green=imageData.data[j+1];
			var blue=imageData.data[j+2];
			//var alpha=imageData.data[j+3];
			imageData.data[j]=red*.4;
			imageData.data[j+1]=green*.4;
			imageData.data[j+2]=blue*.8;
			//imageData.data[j+3]=255;
		   
		}
		 
		//console.log("done!");
		myCanvasContext.putImageData(imageData,0,0,0,0, imageData.width,   imageData.height);
		return myCanvas.toDataURL();
	}
	
	//Turns a storybox into a baked image
	//for (let d of document.getElementsByClassName('storyImg')){bakeStoryBox(d)}
	function bakeStoryBox(d)
	{
		if (d==undefined)
			d=document.getElementById('storyBox0');
			
		let bg = d.getElementsByClassName('bg')[0]
		let dolls = d.getElementsByClassName('storydoll');
		
		//Unique hash should be generated based on bg number, dolls present, and dim/mask on dolls so CPU is not wasted generating it again
		let uint8toByte = function(n){let str= Number(n).toString(16); return str.length == 1 ? "0" + str : str}
		let uint16toByte = function(n){
			let str= Number(n).toString(16);
			while (str.length < 4)
				str='0'+str;
			return str;
		}
		let booltoByte = function(b){return b ? 'F' : '0' }
		
		let checksum = uint8toByte(bg.getAttribute('bg'))+booltoByte(bg.classList.contains('nightBG'));
		for (var i = 0;i<2;i++)
		{
			let doll = d.getElementsByClassName(int2str[i])[0]
			console.log(doll);
			if(doll)
			{
				//Concatenate a string for src because I'm comparing strings anyways and it's unique
				checksum+=doll.getAttribute('src').replace('/','_')+booltoByte(doll.classList.contains('dim'))
			}
			else
				checksum+="0000"
		}
		
		console.log(checksum)
		
		let canvas = document.createElement('canvas');
		canvas.width = 1280; //GFL's cutscenes seem to be scaled to this resolution and not 1024x576.
		canvas.height = 720;
		
		let ctx = canvas.getContext('2d');
		ctx.drawImage(bg,0,0,canvas.width,canvas.height)
		if (dolls.length > 0)
		{
			let doll = dolls[0]
			ctx.drawImage(doll,canvas.width/2-doll.naturalWidth/2,50)
		}
		
		d.innerHTML = "<img class='bakedStoryBox' style='width: 100%; position: relative; display: block;' src=\'"+canvas.toDataURL()+"\' checksum='"+checksum+"'>"
		
	}
	
	function sliceAndRemove(str, begin, end)
	{
		return str.slice(0,begin)+str.slice(end)
	}
	
	function getFromTag(str,tag)
	{
		const beginTag = "<"+tag+">"
		const endTag = "</"+tag+">"
		var n = str.indexOf(beginTag)
		if (n != -1){
			return str.slice(n+beginTag.length, str.indexOf(endTag))
		}
		return null
	}
	function removeTag(str,tag)
	{
		const beginTag = "<"+tag+">"
		const endTag = "</"+tag+">"
		return sliceAndRemove(str,str.indexOf(beginTag),str.indexOf(endTag)+endTag.length)
	}
	
	function playNewAudio(fileName)
	{
		let audioPlayer = document.getElementById('audioPlayer');
		audioPlayer.getElementsByClassName('a_ogg')[0].src = fileName+".ogg"
		audioPlayer.getElementsByClassName('a_mp3')[0].src = fileName+".mp3" //Imagine using a browser that doesn't support ogg
		audioPlayer.load();
		audioPlayer.play();
	}
	
	
	let curEpisodePart = 0
	var vntext;
	class GirlsFrontlineScene extends Phaser.Scene {
		constructor()
		{
			//I don't know what this does but the tutorial had it
			super('GirlsFrontlineScene');
		}
		
		 preload()
		{
			//this.load.image('test','test.png');
			this.load.image('textbox','textbox.png');
		}
		
		create()
		{
			//input.touch only works on mobile devices. So it will break on desktop. reeeee
			//game.input.touch.capture = false;
			
			bgActor = this.add.image(game.config.width/2,game.config.height/2);
			bgActor.texture = Phaser.Cache.DEFAULT;
			bgActor.setDepth(0);
			
			
			//Depth 2 is reserved for character portraits!
			
			imageActor = this.make.image({
				x:game.config.width /2,
				y:game.config.height-125,
				//scale:1,
				key:'textbox',
				add:true
			})
			imageActor.scaleY = 1
			imageActor.setDepth(3);
			
			//var blocks = this.add.group({ key: 'block', repeat: 139, setScale: { x: 0, y: 0 } });
			
			nameActor = this.add.text(240,500,'', { fontFamily: 'Noto Sans KR', fontSize: 30, color: '#ffffff' });
			nameActor.setDepth(4);
			
			//TODO
			document.getElementById("DebugTextArea").value = structuredLinesToString(currentEpisodeAsOpcodes[curEpisodePart]);
			
			vntext = new VNText4(this,'',800,20,currentEpisodeAsOpcodes[curEpisodePart]);
			vntext.textActor.x = 242;
			vntext.textActor.y = game.config.height-160
			vntext.textActor.setDepth(4);
			vntext.advance();
			
			this.input.on('pointerdown',function(){
				if (vntext.no_more_text())
				{
					console.log("Already hit the end!!!!");
					//'this' isn't passed in... No idea what I'm gonna do
					//If you spam click it will crash because you're removing and trying to add multiple scenes at the same time
					//this.input.onInputDown.removeAll();
					if (curEpisodePart < currentEpisodeAsOpcodes.length)
					{
						curEpisodePart++;
						game.scene.remove('GirlsFrontlineScene');
						game.scene.add('GirlsFrontlineScene',GirlsFrontlineScene,true);
					}
					else
					{
						//Oh no
						goToNextEpisode()
					}
					
				}
				else
				{
					if (vntext.is_finished())
					{
						vntext.advance();
					}
					else
					{
						vntext.skip();
					}
				}
			},vntext)
			//Hey look it's just like StepMania
			/*this.make.text({
				x: 100,
				y: 100,
				text: 'Phaser III',
				style: {
					fontSize: '48px',
					fontFamily: 'Arial',
					color: '#ffffff',
					metrics: {
						ascent: 45,
						descent: 10,
						fontSize: 55
					}
				}
			})*/
		}
		
		//I'm not even using this lmao
		 update()
		{
			
		}
	}
	
	let config = {
		type: Phaser.WEBGL,
		width: 1280,
		height: 720,
		parent: 'phaser',
		/*scene: {
			preload: preload,
			create: create,
		}*/
		scene: [GirlsFrontlineScene]
	};
	
	//phaser
	var game;
	
	var imageActor;
	
	//Input: string of gfl text, missionID
	//output: structured lines (array with opcodes)
	function convertGFLTextToOpcodes(out, missionID)
	{
		//console.log(out);
		var lines = out.split(/\r?\n/);
		//The GFL text system is stupid as fuck and I just spent a whole week writing my own VN system
		//So obviously I'm going to convert it to my own. fuck you
		//console.log(lines)
		//Fuck your opcodes
		let structuredLines = [];
		
		
		//It's really stupid but dimRightSide has to know the state of the previous dimmed portraits because normally the GFL engine only supports two portraits and I wanted more
		let prevLineHadAtLeastTwoPortraits = false;
		for(i=0;i<lines.length;i++)
		{
			if (!lines[i])
				continue;
			//print(lines[i]);
			let [cmds,text] = JavaSplit(lines[i].replace("：",':').replace("；",";"),":",2)
			console.assert(cmds,lines[i])
			//There can be lines without any text so asserting is pointless
			//console.assert(text,lines[i])
			//console.log(text)
			//
			
			//Yeah I know tags are supposed to be in order, No I don't really care sorry
			
			//So portraits are set in any order... But how the fuck are you supposed to tell when a name is if there's <> tags
			//I'm just going to search portraits after removing <> tags, it probably won't matter
			let numPortraits = 0;
			let thisLineHadAtLeastTwoPortraits = (cmds.indexOf(";") != -1)
				
			//Add portrait removal command
			if (prevLineHadAtLeastTwoPortraits && !thisLineHadAtLeastTwoPortraits)
			{
				let [charID,charSpr] = cmds.slice(0,cmds.indexOf(")")).split("(")
				//let newPortrait = 
				//It's -2 because the last line is always MSGBOXTRANSITION
				for(var lll=structuredLines.length-2; lll>=0; lll--)
				{
					let m = structuredLines[lll];
					if (m[0]==OPCODES.MSGBOXTRANSITION)
						break;
					else if (m[0]==OPCODES.PORTRAIT && m[2]!=charID)
					{
						structuredLines.push([OPCODES.NOPORTRAIT,m[1]])
						break;
					}
				}
			}
			
			
			//Apply dimming by checking position of <Speaker> command.
			//If ; is before the <Speaker> tag it dims the left, if it's after it dims the right.
			let shouldDimLeft = thisLineHadAtLeastTwoPortraits && cmds.lastIndexOf(";") < cmds.lastIndexOf("</Speaker>")
			
			
			
			//console.log(thisLineHadAtLeastTwoPortraits);
			//Limit it to 5 because I don't want a dumb infinite loop that crashes the browser
			for(j=0;j<5;j++)
			{
				//console.log(cmds)
				let charTagEnd = cmds.indexOf(")");
				if (charTagEnd != -1)
				{
					//It's +1 to get rid of the ;
					let charTagStart = Math.max(cmds.lastIndexOf(";",charTagEnd)+1,0)
					let [charID,charSpr] = cmds.slice(charTagStart,charTagEnd).split("(")
					//console.log(charID)
					//console.log(charSpr)
					//Ignore empty sprite IDs, they do nothing.
					
					//I know it's a hackjob fix but I don't think there's going to be () in any other tags
					if (charTagEnd > cmds.indexOf("<Speaker>") && charTagEnd < cmds.indexOf("</Speaker>"))
					{
						//console.log("Parenthesis is inside the speaker tag, ignoring");
						continue
					}
					
					if (charSpr != undefined && charSpr && charID)
					{
						
						let shouldDim = false;
						if (thisLineHadAtLeastTwoPortraits)
						{
							//shouldDim = numPortraits < 1 ? shouldDimLeft : !shouldDimLeft
							if (numPortraits < 1) //If we're handling the left portrait right now
								shouldDim= shouldDimLeft;
							else
								shouldDim = !shouldDimLeft;
						}
						
						//Search backwards for the previous mask value because the mask command is only applied once in GFL for some reason
						let shouldMask = false;
						//It's -2 because the last line is always MSGBOXTRANSITION.
						for(var lll=structuredLines.length-2; lll>=0; lll--)
						{
							let m = structuredLines[lll];
							if (m[0]==OPCODES.NOPORTRAIT && m[1]==numPortraits)
							{
								//console.log("Found noportrait at "+lll+", exit");
								//Portrait was cleared previously, so this is probably the first instance of the portrait and there's no need to determine previous masking
								//shouldMask=false;
								break;
							}
							//Search for single old portrait, if it matches then it shouldn't mask
							else if (m[0]==OPCODES.PORTRAIT)
							{
								if (m[2] == charID)
								{
									shouldMask = m[5]
									//console.log("Found previous portrait, previous mask value was "+shouldMask)
									break;
								}
							}
						}
						
						
						structuredLines.push([OPCODES.PORTRAIT,numPortraits,charID,charSpr,shouldDim,shouldMask])
						//nextPortraitIsMasked = false;
						numPortraits++;
					}
					//The () command sets the speaker to "".
					//In fact () always sets the name, you just don't see it because <Speaker> is used in EN.
					else
					{
						structuredLines.push([OPCODES.NOPORTRAIT,1])
						structuredLines.push([OPCODES.NOPORTRAIT,0])
						structuredLines.push([OPCODES.SPEAKER,""])					
						//numPortraits=0;
					}
					cmds = sliceAndRemove(cmds,charTagStart,charTagEnd+1);
				}
				else
				{
					//console.log("Done... Let's exit");
					break;
				}
			}
			prevLineHadAtLeastTwoPortraits = thisLineHadAtLeastTwoPortraits;
			
			
			let speakerRes = getFromTag(cmds,"Speaker")
			//debugger;
			if (speakerRes != undefined)
			{
				let prevLine = structuredLines[structuredLines.length-1]
				//Optimization: If prevLine was another speaker line, overwrite it instead of writing another
				if (prevLine[0]==OPCODES.SPEAKER)
					structuredLines[structuredLines.length-1]=[OPCODES.SPEAKER,speakerRes]
				else
					structuredLines.push([OPCODES.SPEAKER,speakerRes])
				cmds = removeTag(cmds,"Speaker")
			}
			
			let bgmRes = getFromTag(cmds,"BGM")
			
			if (bgmRes != null)
			{
				if(bgmRes=="BGM_Empty")
					structuredLines.push([OPCODES.STOPBGM])
				else
				{
					//If music exists in db then rename it before pushing
					structuredLines.push([OPCODES.BGM, MUSIC[bgmRes] || bgmRes])
				}
			}
			
			//It's impossble to filter out duplicate background commands ahead of time because the night command is applied after the background command
			const tags = ["BIN"]
			tags.forEach(tag => {
				//console.log(tag);
				let tagRes = getFromTag(cmds,tag);
				//console.log(tagRes)
				if (tagRes != null)
				{
					structuredLines.push([tag2opcode[tag],tagRes])
					cmds = removeTag(cmds,tag)
				}
			})
			
			//For commands that don't have an argument and require no special behavior to parse.
			/*const tagsNoArgs=['名单']
			tags.forEach(tag => {
				structuredLines.push([tag2opcode[tag]])
				cmds=cmds.replace("<"+tag+">","");
			})*/
			if (missionID != undefined && cmds.includes('<名单>'))
			{
				structuredLines.push([OPCODES.CREDITS,missionID])
				cmds=cmds.replace("<名单>","");
			}
			
			
			
			//Destination label
			let destRes = getFromTag(cmds,'分支')
			if (destRes != null)
			{
				for(var lll=structuredLines.length-1; lll>=0; lll--)
				{
					let m = structuredLines[lll];
					if(m[0]==OPCODES.MSGBOXTRANSITION)
					{
						structuredLines.splice(lll+1,0,[OPCODES.DESTINATION,destRes])
						//console.log("Pushed label tag at idx "+(lll+1))
						//console.log(structuredLinesToString(structuredLines))
						break;
					}
				}
				cmds = removeTag(cmds,'分支')
			}
			
			
			//Search backwards to find the last background command and set isNight flag true
			if (cmds.includes("<Night>"))
			{
				for(var lll=structuredLines.length-1; lll>=0; lll--)
				{
					let m = structuredLines[lll];
					console.assert(m)
					if(m[0]==OPCODES.BG)
					{
						m.push(true)
						break;
					}
				}
				cmds=cmds.replace("<Night>","");
			}
			//const tags = [
			//var nextPortraitIsMasked = false;
			//Since portraits are searched before modifiers...
			while (cmds.includes("<通讯框>"))
			{
				let idxToCheck = 0;
				
				let posOfMaskCmd = cmds.indexOf("<通讯框>");
				let posOfCmdDivider = cmds.indexOf(";")
				//console.log(posOfCmdDivider+" "+posOfMaskCmd+" "+cmds)
				//If this line had more than one portrait AND the ; is before the mask command, we should be masking the portrait at idx 1 instead of 0
				if (posOfCmdDivider > -1 && posOfCmdDivider < posOfMaskCmd)
				{
					//console.log("checking portrait on right side to mask")
					idxToCheck = 1;
				}
				
				for(var lll=structuredLines.length-1; lll>=0; lll--)
				{
					let m = structuredLines[lll];
					console.assert(m)
					if(m[0]==OPCODES.MSG)
					{
						//consoleWarn("Found a message opcode before a portrait opcode... Messages shouldn't exist at this point")
						break;
					}
					else if (m[0]==OPCODES.PORTRAIT && m[1] == idxToCheck)
					{
						//console.log("set mask true for portrait "+portraitStructToString(structuredLines[lll]))
						structuredLines[lll][5]=true
						break;
					}
				}
				cmds=cmds.replace("<通讯框>","");
			}
			
			//Now do text... But first check if there is any text (some lines are only commands)
			if (text)
			{
				//Snow effect is on the right hand side for some reason
				["火焰销毁",'下雪'].forEach(tag => {
					let tagRes = getFromTag(text,tag);
					if (tagRes != null)
					{
						structuredLines.push([tag2opcode[tag],tagRes])
						text = removeTag(text,tag)
					}
				})
				
				
				text.split("+").forEach(msg => {
					//Check for choice tag here. <c> is always at the end, so it's fine
					let choiceStart = msg.indexOf('<c>')
					if (choiceStart != -1)
					{
						structuredLines.push([OPCODES.MSG, msg.slice(0,choiceStart)])
						structuredLines.push([OPCODES.CHOICE, msg.slice(choiceStart+3).split('<c>')])
					}
					else
						structuredLines.push([OPCODES.MSG,msg])
				})
			}
			//open/close msgbox
			structuredLines.push([OPCODES.MSGBOXTRANSITION])
		}
		return structuredLines;
	}
	
	var curEpKey;
	var currentEpisodeAsOpcodes;
	
	//WHY DOES IT HAVE TO BE A SEPARATE FUNCTION
	/*async function fetchTextFile(fileName)
	{
		console.log("fetching "+fileName);
		const response = await fetch("avgtxt/"+fileName);
		console.log("got "+fileName);
		return await response.text();
		//const out = await response.text();
		//return out;
	}*/
	
	function structuredLinesToString(structuredLines)
	{
		let s = "";
		structuredLines.forEach(line => {
			s+=opcode2string[line[0]]+';'
			/*for(var i=1;i<line.length;i++)
				s+=line[i]*/
			s+=line.slice(1).join([separator = ';'])
			s+='\r\n'
			//s+=line.toString()+"\r\n";
		})
		return s;
	}
	function stringToStructuredLines(s)
	{
		var lines = s.split(/\r?\n/);
		let structuredLines = [];
		for(i=0;i<lines.length;i++)
		{
			let newMsg = lines[i].split(';')
			newMsg[0] = opcode2string.indexOf(newMsg[0])
			if (newMsg[0] == OPCODES.PORTRAIT)
			{
				//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining
				//Someone said the site stopped working because I used the operators so I had to change it back :V
				//It also doesn't work on the old version of Firefox for Android and I want Tampermonkey
				//newMsg[4] = (newMsg[4]?.toLowerCase() == "true")
				//newMsg[5] = (newMsg[5]?.toLowerCase() == "true")
				
				newMsg[4] = (newMsg[4] != undefined ? newMsg[4].toLowerCase() == "true" : false)
				newMsg[5] = (newMsg[5] != undefined ? newMsg[5].toLowerCase() == "true" : false)
			}
			structuredLines.push(newMsg)
		}
		return structuredLines;
	}
	
	//Anti-XSS
	function sanitize(string) {
		const map = {
			'&': '&amp;',
			'<': '&lt;',
			'>': '&gt;',
			'"': '&quot;',
			"'": '&#x27;',
			"/": '&#x2F;',
			"`": '&grave;'
		};
		const reg = /[&<>"'/]/ig;
		return string.replace(reg, (match)=>(map[match]));
	}
	
	//Converts GFL's text modifiers into HTML elements, as you might have guessed.
	//TODO: Ignore ALL unknown/illegal codes, not just <script>
	//let allowedHTMLTags = ['color','size','b','i','u','q','s']
	function parseGFLTextModifiers(message) {
		message = message.replaceAll("<script>","&lt;script&gt;").replaceAll("<\/script>","&lt;&#x2F;script&gt;")
		message = message.replaceAll("\"","&quot;")
		for(var ccc = 0; ccc < 50; ccc++)
		{
			/*if(ccc > 5)
			{
				consoleWarn("Encountered more than 5 color codes in a message... This is very unusual, so bailing out");
				break;
			}*/
			//If you haven't already guessed, I don't know regex
			let idx = message.indexOf("<color=");
			if (idx != -1)
			{
				//print('parsing colors: '+message);
				let end = message.indexOf('>',idx)
				let color = message.slice(idx+7,end)
				//console.log(color)
				let spanTagStart = "<span class='coloredDialogue' style='color:"+color+"'>"
				message = message.slice(0,idx)+spanTagStart+message.slice(end+1,message.indexOf("</color>"))+"</span>"+message.slice(message.indexOf("</color>")+8)
				//console.log("new msg: "+message);
			}
			else
			{
				break;
			}
		}
		for(var ccc = 0; ccc < 50; ccc++)
		{
			/*if(ccc > 5)
			{
				consoleWarn("Encountered more than 5 size codes in a message... This is very unusual, so bailing out");
				break;
			}*/
			//If you haven't already guessed, I don't know regex
			let idx = message.indexOf("<size=");
			if (idx != -1)
			{
				//console.log(message);
				let end = message.indexOf('>',idx)
				let size = message.slice(idx+6,end)/45*100 //Assume default is 45px
				let spanTagStart = "<span class='sizedDialogue' style='font-size:"+size+"%'>"
				
				message = message.slice(0,idx)+spanTagStart+message.slice(end+1,message.indexOf("</size>"))+"</span>"+message.slice(message.indexOf("</size>")+7)
			}
			else
			{
				break;
			}
		}
		message = message.replaceAll("//n","<br>")
		return message
	
	}
	
	//input: structuredLines (array), part (int starting at 0), partName (string. Optional, if present replaces the "Part X" header
	//output: a div with the elements rendered
	//This function does not cause side effects.
	function renderStructuredLinesToDiv(structuredLines,part,partName,isNight,numParts)
	{
		
		let thisPartDiv = document.createElement('div');
		thisPartDiv.id = 'part'+part
		let h3 = document.createElement('h3');
		//console.log(partNum);
		if (partName != undefined)
			h3.innerText="Part "+(part+1)+": "+partName
		else
			h3.innerText="Part "+(part+1);
		
		
		//partNum++;
		thisPartDiv.appendChild(h3);
		
		//Add part to top
		if (part != undefined && numParts != undefined && numParts > 1 && numParts < 25) //Don't bother if it's more than 25, it wastes too much CPU
		{
			let ul = document.createElement('ul')
			ul.classList.add('pagination');
			//ul.innerHTML = "<li class='disabled'><a style='color:var(--text-color); cursor:text;'>Jump to:</a></li>"
			if (part==0)
				ul.innerHTML = '<li class="disabled"><a><i class="material-icons">chevron_left</i></a></li>'
			else
				ul.innerHTML = '<li class="waves-effect"><a onclick="document.getElementById(\'part'+(part-1)+'\').scrollIntoView()"><i class="material-icons">chevron_left</i></a></li>'
			
			let li = ''
			for (var p = 0;p<numParts;p++)
			{
				li += '<li class="'+ (p==part ? 'active' : 'waves-effect')+ '"><a onclick="document.getElementById(\'part'+p+'\').scrollIntoView()">'+(p+1)+'</a></li>'
				
			}
			if (part==numParts-1)
				li += '<li class="disabled"><a><i class="material-icons">chevron_right</i></a></li>'
			else
				li += '<li class="waves-effect"><a onclick="document.getElementById(\'part'+(part+1)+'\').scrollIntoView()"><i class="material-icons">chevron_right</i></a></li>'
			
			ul.innerHTML = ul.innerHTML + li
			
			
			//It looks kind of ugly tbh
			/*if (episode['part_names'] != undefined)
				partJump+=': '+episode['part_names'][p]*/
			//partJump+='</a></li>'
			thisPartDiv.appendChild(ul);
		}
		
		if (document.getElementById('showDebugOpcodeButton').checked)
		{
			let button = document.createElement('a');
			//fuck your javascript
			button.setAttribute("class","waves-effect waves-light btn");
			button.setAttribute("onclick","showOpcodes('div_cutscene_iop_"+part+"')")
			button.innerText="Show opcodes for this section (For debugging)"
			thisPartDiv.appendChild(button);
			thisPartDiv.appendChild(document.createElement('br'));
		
			let opcodesDiv = document.createElement('div');
			opcodesDiv.id= "div_cutscene_iop_"+part
			opcodesDiv.style="display: none;"
			opcodesDiv.classList.add("textarea-wrapper");
			opcodesDiv.innerHTML = "<textarea rows='6' cols='50' id='textarea_cutscene_"+part+"' readonly>"+structuredLinesToString(structuredLines)+"</textarea><br>"
			//debugger;
			//TLN.append_line_numbers_obj(opcodesDiv.firstElementChild,"textarea_cutscene_"+part)
			thisPartDiv.appendChild(opcodesDiv)
		}
		
		let playBGMbutton = document.createElement('a');
		playBGMbutton.setAttribute("class","waves-effect waves-light btn");
		/*if (!!document.getElementById('audioPlayer').canPlayType('audio/ogg;').replace(/no/,'') == false)
		{
			'<i class="material-icons left">music_note</i>Sorry, your browser is missing ogg support.'
		}
		else*/
		playBGMbutton.innerHTML='<i class="material-icons left">music_note</i>Play audio for this cutscene'
		

		
		//<img src="avgtexture/夜间蒙版.png" class="storydoll first one mask" style="mask-image: url(pic/pic_NPC-Helian.png);">
		let maskThing = document.createElement('img');
		maskThing.src= "avgtexture/夜间蒙版.png";
		maskThing.classList.add("storydoll");
		maskThing.classList.add("mask");
		maskThing.style="z-index: 10";
		
		
		let lastSpeakerName = "";
		let lastBGUsed = []; // [9,false];
		//let didBGOrPortraitOrNameChange = false;
		
		let didBGChange = false;
		let didPortraitsChange = false;
		let didNameChange = false;
		
		let shownPortraits = []
		
		let fancyDisplayType = document.getElementById('fancyOrNot').checked;
		let quickScroll = document.getElementById('quickScroll').checked;
		let numStoryBoxRendered = part*1000+0; //For quick scroll. We start at a part because if there's multiple parts then it would jump back to the top and we don't want that.
		
		//let inlineText = document.getElementById('inlineText').checked
		let advancedCSS = document.getElementById('advancedCSS').checked;
		let skipGenerationOfDuplicateBoxes = document.getElementById('skipGenerationOfDuplicateBoxes').checked;
		var snowDiv;
		if (advancedCSS)
		{
			snowDiv = document.createElement('div');
			snowDiv.classList.add('snow');
			snowDiv.style='position: absolute; width:100%; height:100%;bottom: 0;'
		}
		let snowEffect = false
		//let curDestination = null;
		
		for(var i=0;i<structuredLines.length;i++)
		{
			let opcode = structuredLines[i][0]
			//console.log(structuredLines[i]);
			switch (opcode)
			{
				case OPCODES.BGM:
					let newPlayBGMButton = playBGMbutton.cloneNode(true);
					newPlayBGMButton.setAttribute("onclick","playNewAudio('audio/"+structuredLines[i][1]+"')")
					thisPartDiv.appendChild(newPlayBGMButton);
					break;
				case OPCODES.STOPBGM:
					let stopBGMButton = document.createElement('a');
					stopBGMButton.setAttribute("class","waves-effect waves-light btn");
					stopBGMButton.innerHTML='<i class="material-icons left">music_note</i>Stop audio'
					stopBGMButton.setAttribute('onclick',"document.getElementById('audioPlayer').pause()")
					thisPartDiv.appendChild(stopBGMButton);
					break;
				case OPCODES.CHOICE:
					structuredLines[i][1].forEach(c => {
						let choiceButton = document.createElement('a');
						choiceButton.setAttribute("class","waves-effect waves-light btn choiceButton");
						choiceButton.setAttribute("style","margin-right: 5px; margin-bottom: 5px; text-transform:unset;")
						choiceButton.innerText=c;
						thisPartDiv.appendChild(choiceButton);
					})
					break;
				case OPCODES.DESTINATION:
					//curDestination = structuredLines[i][1]
					let h5 = document.createElement('h5');
					h5.setAttribute('id','choiceDestination_'+(part*100+structuredLines[i][1]));
					h5.innerText="If choice "+structuredLines[i][1]+" was picked"
					thisPartDiv.appendChild(h5);
					break;
				case OPCODES.SPEAKER:
					if (lastSpeakerName != structuredLines[i][1])
					{
						lastSpeakerName=structuredLines[i][1];
						didNameChange = true
					}
					else
					{
						//console.log("speaker command was called but already matches previous speaker...");
					}
					break;
				case OPCODES.CREDITS:
					console.assert(structuredLines[i][1]);
					let creditsDiv = document.createElement('div');
					creditsDiv.setAttribute('style','text-align:center;font-family:serif;');
					if (CREDITSDATA)
					{
						creditsDiv.innerHTML = parseGFLTextModifiers(CREDITSDATA[structuredLines[i][1]])
					}
					else
					{
						creditsDiv.setAttribute('missionID',structuredLines[i][1]);
						console.log("Fetching credits data...")
						/*console.log("fetching "+fileName);
						const response = await fetch("avgtxt/"+fileName);
						const out = await response.text();
						console.log("got "+fileName);*/
						fetch('Language_AVG_US.txt')
						.then(response => response.text())
						.then(response => {
							console.log("credits data loaded!");
							CREDITSDATA = {}
							response.split(/\r?\n/).forEach(l => {
								if (l) { //Gotta check if the string is not empty
									let kv = l.split('|')
									//debugger;
									CREDITSDATA[parseInt(kv[0])]=kv[1]
								}
							})
							let interval=setInterval(function(){
								let nBGs = document.querySelectorAll('div[missionID]');
								if (nBGs.length == 0)
								{
									console.log("CreditsData: waiting for DOM to be ready before setting credits div for "+mID+"...");
									return;
								}
								nBGs.forEach(el => {
									el.innerHTML = parseGFLTextModifiers(CREDITSDATA[el.getAttribute('missionID')])
								});
								console.log("Set creditsDiv, exiting background task.");
								clearInterval(interval);
							},100);
						});
					}
					thisPartDiv.appendChild(creditsDiv);
					break;
				case OPCODES.PORTRAIT:
					if (!fancyDisplayType)
						break;
					//console.log(portraitStructToString(structuredLines[i]))
					let idx = structuredLines[i][1]
					let name = structuredLines[i][2]
					let type = structuredLines[i][3]
					if (PORTRAITS[name] && PORTRAITS[name][type])
					{
						//console.log(shownPortraits.length);
						if (structuredLines[i][1] > shownPortraits.length-1)
						{
							//console.log("Pushed new portrait with idx "+idx);
							shownPortraits.push(structuredLines[i]);
							didPortraitsChange = true;
						}
						else
						{
							let newPortrait = structuredLines[i]
							//newPortrait[2].replace('
							let oldPortrait = shownPortraits[idx]
							if (newPortrait[1] == oldPortrait[1] && newPortrait[2] == oldPortrait[2] && newPortrait[3] == oldPortrait[3] && newPortrait[4] == oldPortrait[4])
								console.log("New portrait set is identical to old one, ignoring change. (TODO: This should be left to the opcode interpreter to filter out!)");
							else
							{
								//console.log("Portrait replaced "+portraitStructToString(oldPortrait) +" -> "+portraitStructToString(newPortrait))
								shownPortraits[idx]=newPortrait;
								didPortraitsChange = true;
							}
						}
						//console.log("NumPortraits: "+shownPortraits.length);
					}
					else if (PORTRAITS[name])
					{
						if (document.getElementById('showDebugOpcodeButton').checked)
						{
							let p = document.createElement('p');
							p.innerHTML = "<span class='coloredDialogue' style='color:red'>PORTRAIT TYPE MISSING BELOW "+portraitStructToString(structuredLines[i])+"</span>";
							p.classList.add("storyText");
							thisPartDiv.appendChild(p);
						}
					
						consoleWarn("Portrait type missing. Falling back to default.")
						consoleWarn(portraitStructToString(structuredLines[i]))
						shownPortraits[idx]=structuredLines[i];
						shownPortraits[idx][3]=0
						didPortraitsChange=true; //Assume true for now
						

						
					}
					else
					{
						if (document.getElementById('showDebugOpcodeButton').checked)
						{
							let p = document.createElement('p');
							p.innerHTML = "<span class='coloredDialogue' style='color:red'>PORTRAIT MISSING BELOW: "+structuredLines[i][2]+"</span>";
							p.classList.add("storyText");
							thisPartDiv.appendChild(p);
						}
						consoleWarn(portraitStructToString(structuredLines[i]))
						consoleWarn("Portrait missing from database.")
						shownPortraits[idx]=structuredLines[i];
						shownPortraits[idx][2]='missing'
						shownPortraits[idx][3]=0
						didPortraitsChange=true; //Assume true for now
					}
					break;
				case OPCODES.NOPORTRAIT:
					if (shownPortraits.length > 0)
					{
						shownPortraits = [];
						didPortraitsChange = true;
					}
					else
					{
						//console.log("noportrait command was called but there are already no portraits...")
					}
					break;
				case OPCODES.BG:
					if (!fancyDisplayType)
						break;
						
					
					let newBG = [structuredLines[i][1],structuredLines[i][2]]
					if (newBG != lastBGUsed)
					{
						lastBGUsed=newBG;
						didBGChange=true;
					}
					break;
				case OPCODES.FADEIN:
					isNight=false;
					break;
				case OPCODES.SNOWEFFECT:
					snowEffect = true;
					break;
				case OPCODES.STOPEFFECTS:
					snowEffect = false;
					break;
				case OPCODES.MSG:
					//Spawn new BG with speaker and portrait here.
					let message = parseGFLTextModifiers(structuredLines[i][1])
					
					if (fancyDisplayType)
					{
						if (didBGChange || didNameChange || didPortraitsChange)
						{
							if ((!skipGenerationOfDuplicateBoxes && didNameChange) || (didBGChange || didPortraitsChange))
							{
								let storyBox = document.createElement('div');
								if (quickScroll)
								{
									//It's impossible to not have quickScroll unless it works backwards... So just ignore the errors on the last box I guess
									//TODO: Make it not error on the last box... I don't think that's actually possible
									storyBox.style.cursor='pointer';
									storyBox.setAttribute('id','storyBox'+numStoryBoxRendered)
									storyBox.setAttribute('onclick',"document.getElementById('storyBox"+(numStoryBoxRendered+1)+"').scrollIntoView({behavior:'auto',block:'center',inline:'center'});")
									numStoryBoxRendered++;
								}
								storyBox.classList.add('storyImg');
								let bgImage = document.createElement('img');
								bgImage.setAttribute('class','bg');
								bgImage.style = "width:100%; position:relative; display:block;";
								
								//It is entirely possible for there to be text without a BG being set, for some reason
								//TODO: Remove this and default to black background, and just don't render any more boxes when the same background is used multiple times. This is basically a hack
								if (lastBGUsed[0] != undefined)
								{
									if (BACKGROUNDS[lastBGUsed[0]] == undefined)
									{
										consoleWarn("Background "+lastBGUsed[0]+" is not indexed.")
										bgImage.src = "avgtexture/missing.png"
										
										if (document.getElementById('showDebugOpcodeButton').checked)
										{
											let p = document.createElement('p');
											p.innerHTML = "<span class='coloredDialogue' style='color:red'>PORTRAIT TYPE MISSING BELOW "+lastBGUsed[0]+"</span>";
											p.classList.add("storyText");
											thisPartDiv.appendChild(p);
										}
									}
									//If 10, a fully transparent image is used and meant to show the stage underneath. So instead pick PlaybackBG1/PlaybackBG2.
									//Read GF Syntax Information.md for more information.
									else if (lastBGUsed[0] == 10)
									{
										bgImage.src = isNight ? 'avgtexture/PlaybackBG2.png' : 'avgtexture/PlaybackBG1.png'
									}
									else
										bgImage.src = 'avgtexture/'+BACKGROUNDS[lastBGUsed[0]]+'.png'
									
									bgImage.setAttribute('bg',lastBGUsed[0]);
									//I don't think MICA ever accidentally colored the black wallpaper so I probably don't need to check
									if (lastBGUsed[1] /*&& lastBGUsed[0] != 9*/) //If this is a night background
									{
										if (!nightBackgrounds[lastBGUsed[0]]) //If background not generated yet
										{
											bgImage.classList.add('nightBG');
											if (!nightBGQueue[lastBGUsed[0]]) //If not queued for generation yet
											{
											
												bgImage.onload = function(){ //Wait for image to finish loading. Then run nightFilter on img. Not that onload != DOM is ready! That's why there's a background task below.
													let bgName = bgImage.getAttribute('bg')
													nightBackgrounds[bgName]=nightFilter(bgImage)
													console.log("NightBG: Generated "+bgName);
													bgImage.onload = null;
													
												}
												console.log("Queued generation of "+lastBGUsed[0]);
											
												//Use this array for storing background task.
												//This task will check every 100 if night BG is generated and if all the night BG boxes are rendered and ready to be set.
												nightBGQueue[lastBGUsed[0]]=setInterval(function(bgNum){
													let nBGs = document.querySelectorAll('img.bg.nightBG[bg="'+bgNum+'"]'); //ex. document.querySelectorAll('[bg="2"]')
													if (nBGs.length == 0 || !nightBackgrounds[bgNum])
													{
														console.log("NightBG: waiting for generation of bg "+bgNum+" to finish or DOM to be ready...");
														return;
													}
													nBGs.forEach(el => {
														el.src=nightBackgrounds[el.getAttribute('bg')]
														//el.classList.remove('nightBG');
													});
													console.log("NightBG: set night BGs for "+bgNum+", killing background task "+nightBGQueue[bgNum]);
													let t = nightBGQueue[bgNum]
													clearInterval(t);
												},100,lastBGUsed[0]);
												
												
												

											}
										}
										else
										{
											bgImage.src=nightBackgrounds[lastBGUsed[0]];
										}
									}
									storyBox.appendChild(bgImage);
								}
								
								for(var j=0;j<shownPortraits.length;j++)
								{
									console.assert(shownPortraits[j]);
									let portraitImg = document.createElement('img');
									//In case you forgot, it's ID and Type
									portraitImg.src = 'pic/'+PORTRAITS[shownPortraits[j][2]][shownPortraits[j][3]];
									
									//console.log(portraitImg.src);
									if (document.getElementById('showDebugOpcodeButton').checked)
										portraitImg.setAttribute('title',"ID: "+shownPortraits[j][2]+" | TYPE: "+shownPortraits[j][3]);
									
									if (!shownPortraits[j][5]) //If not mask
									{
										portraitImg.classList.add("storydoll");
										if (shownPortraits[j][4]==true)
											portraitImg.classList.add('dim')
										portraitImg.classList.add(int2strPos[j+1]);
										portraitImg.classList.add(int2str[shownPortraits.length]);
										storyBox.appendChild(portraitImg);
									}
									else //Behold, pain
									{
										let d = document.createElement('div');
										if (document.getElementById('showDebugOpcodeButton').checked)
											d.setAttribute('title',"ID: "+shownPortraits[j][2]+" | TYPE: "+shownPortraits[j][3]);
										d.style='position:absolute;width:100%;top:10%'
										d.classList.add('maskcontainer');
										d.classList.add(int2strPos[j+1]);
										d.classList.add(int2str[shownPortraits.length]);
										if (shownPortraits[j][4]==true)
											d.classList.add('dim')
										let h = "<img src='maskBox.png' style='position:absolute;width:30%'>"
										//width should be width of maskBox * 0.869209809 because width of this image is 86% of maskBox in terms of pixels
										h+="<div style='overflow:hidden;position:absolute;width:26.076%;left:3%;padding-top:1%;'>"
											//Don't forget display:block or the div containing this will be slightly too big. Because CSS is amazing.
											h+="<img src='maskBox2.png' style='position:relative;z-index:1;width:100%;display:block;'>"
											//How the fuck is it 270%? Or left -85%? How does this shit make ANY sense? WHY DO I NEED PADDING-TOP 4%?????
											h+="<img src='"+portraitImg.src+"' class='"+(shownPortraits[j][4]?"dim":"")+"' style='position:absolute; min-width:270%; top:0; left:-85%; width:100%; padding-top:4%;'>"
										h+="</div>"
										d.innerHTML=h
										storyBox.appendChild(d);
									}
									//If mask (new)
									//<img src="avgtexture/夜间蒙版.png" class="storydoll first one mask" style="mask-image: url(pic/pic_NPC-Helian.png);">
									//Mask is a transparent masked blue image, so we overlay on top of the other img
									/*if (shownPortraits[j][5]==true)
									{
										let m = maskThing.cloneNode(true);
										m.classList.add(int2strPos[j+1])
										m.classList.add(int2str[shownPortraits.length]);
										m.style = "mask-image: url('"+portraitImg.src+"');"+"-webkit-mask-image: url('"+portraitImg.src+"');"
										storyBox.appendChild(m);
									}*/
								}
								
								if (snowEffect && advancedCSS)
									storyBox.appendChild(snowDiv.cloneNode(false));
								
								thisPartDiv.appendChild(storyBox);
							}
							/*if (inlineText)
							{
								let textboxDiv = document.createElement('div');
								if (inlineText)
									textboxDiv.style="color:white; position: absolute; bottom: 0%; width:100%; z-index: 100; padding-top: 30px; padding-bottom:10px; background: linear-gradient(rgba(0, 0, 0, 0) 0%, rgb(0, 0, 0) 100%)"
								if (lastSpeakerName != "")
								{
									let p = document.createElement('p');
									p.innerText = lastSpeakerName;
									if (inlineText)
										p.style="margin-left: 10px; margin-right:10px;"
									//p.innerHTML = "<b>"+lastSpeakerName+"</b>";
									p.classList.add("storyText");
									p.classList.add("speakerName");
									textboxDiv.appendChild(p);
								}
								storyBox.appendChild(textboxDiv)
								
								
								thisPartDiv.appendChild(storyBox);
							}
							else
							{*/
								
								if (lastSpeakerName != "")
								{
									let p = document.createElement('p');
									p.innerText = lastSpeakerName;
									//p.innerHTML = "<b>"+lastSpeakerName+"</b>";
									p.classList.add("storyText");
									p.classList.add("speakerName");
									thisPartDiv.appendChild(p);
								}
							//}
							
							didBGChange = false;
							didPortraitsChange = false;
							didNameChange = false;
						}
						
						//No, it's not well written. No, I don't know how to fix it.
						/*if (inlineText)
						{
							let p = document.createElement('p');
							p.classList.add('storyText')
							p.style="color:white; margin-left: 10px; margin-right:10px; margin-bottom:5px; margin-top: 5px;"
							p.innerHTML = message;
							let d = thisPartDiv.lastChild.getElementsByTagName('div')[0].appendChild(p);
						}
						else
						{*/
							
							let p = document.createElement('p');
							p.classList.add('storyText')
							p.innerHTML = message;
							thisPartDiv.appendChild(p);
						//}
					}
					else
					{
						let p = document.createElement('p');
						if (lastSpeakerName == "")
							p.innerHTML = message;
						else
							p.innerHTML = lastSpeakerName + ": "+message;
						thisPartDiv.appendChild(p);
					}
					break;
				default:
					//console.log("unknown OPCODES..");
			}
		}
		return thisPartDiv;
	}
	
	//You're probably wondering why the fuck there's two of these functions when a routableKeyString is always passed in
	//That's because I want to support running from an episode object without the keyString (for user stuff)
	function runFromRoutableKeyString(value)
	{
		if (value == undefined)
			value = curEpKey;
		let [type,chapter,episode] = getKeysFromRoutableString(value)
		run(listOfChapters[type][chapter]['episodes'][episode],value)
	}
	
	function runFromUserInput()
	{
		let out = document.getElementById('textarea1').value;
		let structuredLines = document.getElementById('customIsTXTorIOP').checked ? stringToStructuredLines(out) : convertGFLTextToOpcodes(out);
		currentEpisodeAsOpcodes = [structuredLines];
		curEpKey = "";
		let simpleTextDiv = document.getElementById("verySimpleText");
		let NewSimpleTextDiv = document.createElement('div');
		NewSimpleTextDiv.id="verySimpleText";
		NewSimpleTextDiv.appendChild(renderStructuredLinesToDiv(structuredLines,0))
		
		simpleTextDiv.parentNode.replaceChild(NewSimpleTextDiv,simpleTextDiv);
		if (game == undefined)
			document.getElementById("startButton").classList.remove('disabled');
	}
	
	async function run(episode, routableKeyString)
	{
		currentEpisodeAsOpcodes = [];
		curEpisodePart = 0;
		curEpKey = routableKeyString;
		
		document.getElementById('chapterName').innerText = episode['name'];
		
		
		
		//Instead of just one part, put all of them in the verySimpleText div.
		let NewSimpleTextDiv = document.createElement('div');
		NewSimpleTextDiv.id="verySimpleText";
		
		/*let exporterButton = document.createElement('a');
		exporterButton.setAttribute("class","waves-effect waves-light btn modal-trigger");
		exporterButton.setAttribute("href","#savePageModal");
		exporterButton.innerText="Export options..."
		NewSimpleTextDiv.appendChild(exporterButton);
		NewSimpleTextDiv.appendChild(document.createElement('br'));*/
		
		//Don't keep audio running
		document.getElementById('audioPlayer').pause();
		
		
		
		
		for(var p = 0; p < episode.parts.length;p++)
		{
			let fileName = episode.parts[p];
			let partName = null
			let isNight = false
			let missionID = null
			if (episode['part_names'] != undefined)
				partName=episode['part_names'][p]
			if (episode['night'] != undefined)
				isNight=episode['night'][p]
			if(episode['mission_id'] != undefined)
				missionID=episode['mission_id'][p]
			
			//We have to await so it doesn't load the parts in the wrong order. Which is an actual thing that has happened.
			console.log("fetching "+fileName);
			const response = await fetch("avgtxt/"+fileName);
			const out = await response.text();
			console.log("got "+fileName);
			
			//console.log(fetchTextFile("avgtxt/"+fileName));
			
			//TODO: Add check if it's JSON (iop format) and then use a JSON parser if it is
			let structuredLines = convertGFLTextToOpcodes(out,missionID);
			
			if (document.getElementById('showDebugOpcodeButton').checked)
			{
				let button2 = document.createElement('a');
				//fuck your javascript
				button2.setAttribute("class","waves-effect waves-light btn");
				button2.setAttribute("href","avgtxt/"+fileName);
				button2.innerText="original text file for this section (For debugging)"
				NewSimpleTextDiv.appendChild(button2);
				NewSimpleTextDiv.appendChild(document.createElement('br'));
				
			}
			NewSimpleTextDiv.appendChild(renderStructuredLinesToDiv(structuredLines,p,partName,isNight,episode.parts.length));
			//Now replace the old div...
			/*let textboxDiv = document.getElementById("Textboxes");
			textboxDiv.parentNode.replaceChild(newTextboxDiv,textboxDiv);*/
			
			currentEpisodeAsOpcodes.push(structuredLines);
			
		}
		
		//If phaser is already init, go ahead and set the new scene
		//...By destroying the old one and recreating it.
		if (game != undefined)
		{
			game.scene.remove('GirlsFrontlineScene');
			game.scene.add('GirlsFrontlineScene',GirlsFrontlineScene,true);
		}
		let simpleTextDiv = document.getElementById("verySimpleText")
		simpleTextDiv.parentNode.replaceChild(NewSimpleTextDiv,simpleTextDiv);
		
		if (true && routableKeyString != undefined)
		{
			setCookie('lastViewedScene',routableKeyString,180);
		}
		
		//I have no idea why this was commented out in the first place
		if (routableKeyString != undefined)
			window.location.assign("#"+routableKeyString)
	}
	
	function reRunWithNewOpcodes()
	{
		let lines = document.getElementById("DebugTextArea").value;
		//console.log(lines);
		let newStructuredLines = stringToStructuredLines(lines);
		console.log(newStructuredLines)
		currentEpisodeAsOpcodes[curEpisodePart] = newStructuredLines;
		if (game != undefined)
		{
			game.scene.remove('GirlsFrontlineScene');
			game.scene.add('GirlsFrontlineScene',GirlsFrontlineScene,true);
		}
	}
	
	function initPhaser()
	{
		game = new Phaser.Game(config);
		let button = document.getElementById("startButton")
		button.style.display = "none";
		document.getElementById("interactiveInterpreterSection").style.display="";
		//button.classList.add("disabled");
		//button.innerText = "started!"
		
	}
	
	/*function fancyDisplayThing()
	{
	
	}*/
	/*function reset()
	{
		game.restart()
	}*/
	
	function showOpcodes(divId) {
		let x = document.getElementById(divId);
		if (x.style.display === "none") {
			x.style.display = "block";
			let t = x.getElementsByTagName('textarea')[0]
			console.log(t.scrollHeight);
			t.style.height = Math.min(t.scrollHeight, 500) + "px";
		} else {
			x.style.display = "none";
		}
	}
	
	
	function getRoutableKeyString(type,chapter,episode)
	{
		return type+'-'+chapter+'-'+episode
	}
	function getKeysFromRoutableString(s)
	{
		return s.split('-');
	}
	
	function onChapterSelected(value)
	{
		console.log(value);
		//let [type,chapter,episode] = getKeysFromRoutableString(value)
		runFromRoutableKeyString(value)
		if (game == undefined)
			document.getElementById("startButton").classList.remove('disabled');
	}
	function goToNextEpisode()
	{
		//To make it jump to the top
		document.getElementById('chapterName').scrollIntoView()
		
		let value = curEpKey;
		console.log(value);
		let [type,chapter,episode] = getKeysFromRoutableString(value)
		episode++;
		if (listOfChapters[type][chapter]['episodes'][episode])
		{
			runFromRoutableKeyString(getRoutableKeyString(type,chapter,episode))
			return true;
		}
		else
		{
			chapter++;
			episode = 0;
		}
		
		if (listOfChapters[type][chapter]['episodes'][episode])
		{
			runFromRoutableKeyString(getRoutableKeyString(type,chapter,episode))
			return true;
		}
		
		return false;
	}
	

	
	//I finally used a class, aren't you happy? 
	class FilterableList {
		constructor(data,keyToSearch,idToBind) {
			console.assert(data,"FilterableList: Data undefined!")
			this.data = data;
			this.fuse = new Fuse(data, {
				keys: [keyToSearch]
			})
			this.elementId = idToBind
			
			let el = document.getElementById(idToBind);
			el.innerHTML = "" //You shouldn't have anything in here in the first place
			
			
			let div = document.createElement('div');
			div.id = idToBind+'SearchDiv';
				let form = document.createElement('form');
				form.action = "?";
					let inputField = document.createElement('div');
					inputField.classList.add('input-field');
					inputField.style="text-align: left;";
						let i = document.createElement('i');
						i.classList.add("material-icons");
						i.classList.add('prefix');
						i.innerText="search";
						
						
						let input = document.createElement('input');
						input
						//input.onchange = function(ev) { console.log(ev); this.search(this) }
						input.setAttribute('onkeydown',"if (event.key == 'Enter') blur(); return;");
						input.addEventListener('change',this.search.bind(this) );
						input.id=idToBind+'search'
						input.type='search';
						input.onsubmit="blur()"
						input.required=true
						
					inputField.appendChild(i);
					inputField.appendChild(input);
					
				form.appendChild(inputField);
			div.appendChild(form);
			
			
			//Don't bother, none of it works anyways
			/*let inputFromDOM = document.getElementById(idToBind+'search');
			input.addEventListener('onkeyup',function() { console.log("aa") } );
			input.addEventListener('onkeydown',function() {if (event.key == 'Enter') blur(); return;})*/
			/*<form action="?">
				<div class="input-field" style="text-align: left;">
					<i class="material-icons prefix">search</i>
					<!--<label class="label-icon" for="search">
					</label>-->
					<input id="search" type="search" oninput="searchDolls(document.getElementById('search').value)" onkeydown="if (event.key == 'Enter') blur(); return;" onsubmit="blur()" required>
					
					<i class="material-icons" onclick="clearSearch()">close</i>
				</div>
			</form>*/
			
			el.appendChild(div);
			
			this.collection = document.createElement('div');
			this.collection.classList.add('collection');
			//this._li_=document.createElement('li');
			this._li_=document.createElement('a');
			this._li_.href="#theTop";
			this._li_.classList.add('collection-item');
			/*this._li_.classList.add('waves-effect');
			this._li_.classList.add('waves-light');
			this._li_.style="cursor:pointer;";*/
			
			el.appendChild(this.collection);
			
			this.generateResults(this.data);
		}
		
		//It's just like lua Kappa
		search()
		{
			console.assert(this)
			let query = document.getElementById(this.elementId+'search').value
			console.log(query);
			clearTimeout(this.delayTimer);
			this.delayTimer = setTimeout(function() {
				
				if (query == "" || query == undefined)
				{
					this.generateResults(this.data);
				}
				else
				{
					
					/*query = query.toLowerCase();
					console.log("Searching for "+query);*/
					
					var results = this.fuse.search(query);
					console.log("Got "+results.length + " results");
					//I don't care if it's slow
					this.generateResults(Array.from(results, r => r['item']));
				}
			}.bind(this), 300);
		}
		
		generateResults(results)
		{
			console.log(results);
			this.collection.innerHTML="";
			for (var i = 0; i < results.length; i++)
			{
				let li = this._li_.cloneNode(true);
				li.innerText=results[i]['name'];
				this.collection.appendChild(li);
			}
		}
		
	}
	
	//name field is structured like type-chapter-episode
	listOfChapters=false;
	
	function generateTables() {
		
		console.log(listOfChapters);
		
		var _dropDownTrigger_ = document.createElement('a');
		_dropDownTrigger_.href = "#";
		_dropDownTrigger_.classList.add('dropdown-trigger');
		_dropDownTrigger_.classList.add('btn');
		
		var _dropDown_ = document.createElement('ul');
		_dropDown_.classList.add('dropdown-content');
		
		var _li_ = document.createElement('li'),
			_a_ = document.createElement('a');
		
		//No idea what this is supposed to do.
		_a_.href="#!";
		
		for (const key in listOfChapters)
		{
			//console.log(key)
			let episodeContainer = document.getElementById(key+'Episodes')
			//let trChapterDropdowns = _tr_.cloneNode(false);
			//let trChapterDropdowns = 
			for(i=0;i<listOfChapters[key].length;i++)
			{
				//let td = _td_.cloneNode(false);
				let flexBoxDiv = document.createElement('div');
				/*let select = _select_.cloneNode(false);
				select.setAttribute('id',"selectChapter"+i)
				select.setAttribute('onchange','onChapterSelected(value);');*/
				let dropDownTrigger = _dropDownTrigger_.cloneNode(true)
				dropDownTrigger.setAttribute('data-target','dropdown-'+key+'-'+i)
				
				if (listOfChapters[key][i].hasOwnProperty('shortName'))
				{
					let s = "<span class='chapterTitles-desktop'>"+listOfChapters[key][i]['name']+"</span>"
					s+=     "<span class='chapterTitles-mobile'>"+listOfChapters[key][i]['shortName']+"</span>"
					dropDownTrigger.innerHTML = s
				}
				else
				{
					dropDownTrigger.innerText=listOfChapters[key][i]['name']
				}
				
				let dropdown = _dropDown_.cloneNode(true);
				dropdown.id = 'dropdown-'+key+'-'+i;
				
				//Now let's do the episodes
				let curChapter = listOfChapters[key][i]['episodes'];
				for(j=0;j<curChapter.length;j++)
				{
					
					let ep = _li_.cloneNode(true);
					ep.innerHTML = "<a href='#"+getRoutableKeyString(key,i,j)+"' onclick=\"onChapterSelected('"+getRoutableKeyString(key,i,j)+"')\">"+curChapter[j]['name']+"</a>"
					dropdown.appendChild(ep);
					/*let option = _option_.cloneNode(false);
					option.value=getRoutableKeyString(key,i,j)
					option.innerText=curChapter[j]['name'];
					select.appendChild(option);*/
				}
				//flexBoxDiv.appendChild(select);
				flexBoxDiv.appendChild(dropDownTrigger);
				flexBoxDiv.appendChild(dropdown);
				
				episodeContainer.appendChild(flexBoxDiv);
				//td.appendChild(select);
				//trChapterDropdowns.appendChild(td);
			}
		}
		
		//test = new FilterableList(listOfChapters['side'][0]['episodes'],'name',"sideEpisodesWrapper")

		//tbody.appendChild(trChapterDropdowns);
		
		//table.appendChild(thead);
		//table.appendChild(tbody);
		
	}
	
	//materialize.js makes it irrelevant
	/*function showSelectedEpisodes(id)
	{
		let episodesDivs = document.getElementById("Episodes").children;
		for (var i = 0; i < episodesDivs.length;i++){
			if (episodesDivs[i].id == id)
				episodesDivs[i].style="";
			else
				episodesDivs[i].style="display: none;"
		}
		//console.log(episodesDiv.children);
	}*/
	
	//T-Doll search shit
	let frontlinedex = null;
	let CharacterVoice = null;
	
	let dialogueKeysToEnglish = {
		'dialogue1':"Adjutant 1",
		'dialogue2':"Adjutant 2",
		'dialogue3':"Adjutant 3",
		'soulcontract':"Marriage Line",
		'introduce':"Introduction (In the index, but usually identical to obtain)",
		'gain':'When Obtained',
		'allhallows':"During Halloween",
		'christmas':"During Christmas",
		'valentine':"During Valentine's",
		'dialoguewedding':"Adjutant 4 (After Marriage)"
	}
	
	function TDollInfo(dollName)
	{
		/*console.log(dollName);
		console.assert(CharacterVoice)
		console.log(CharacterVoice);*/
		//Destroy everything in here
		let tDollDialogue = document.getElementById('tDollDialogue')
		tDollDialogue.innerHTML = "";
		/*let ul = document.createElement("ul");
		ul.className = 'collapsible'*/
		let _div_ = document.createElement('div');
		_div_.classList.add("card");
		let _cardContent = document.createElement('div');
		_cardContent.classList.add("card-content");
		let dialogue = CharacterVoice[dollName];
		if (dialogue)
		{
			Object.keys(dialogue).forEach(key => {
				let card = _div_.cloneNode(true);
				let cardContent = _cardContent.cloneNode(true);
				let cardTitle = document.createElement('span');
				cardTitle.classList.add('card-title');
				if (dialogueKeysToEnglish[key])
					cardTitle.innerText = dialogueKeysToEnglish[key];
				else
					cardTitle.innerText = key;
				let p = document.createElement('p');
				//console.log(typeof dialogue[key]);
				p.innerHTML= dialogue[key].join([separator = '<br>'])
				cardContent.appendChild(cardTitle);
				cardContent.appendChild(p);
				card.appendChild(cardContent);
				tDollDialogue.appendChild(card);
			});
			
			
			document.getElementById('tDollDialogueName').firstChild.textContent=dollName;
			//document.getElementById('tDollDialogueName').setAttribute('href',"#tDollSearch"+dollName)
			M.Modal.getInstance(document.getElementById('tDollDialogueActivity')).open()
			//jump to top of page
			//window.location.href="#tDollDialogueActivity"
		}
		else
		{
			//console.log("aa");
			M.toast({html: "T-Doll "+dollName+" not present in json..."})
		}
		//document.getElementById('tDollDialogue').appendChild(_div_);
	}
	
	function listResults(results)
	{
		//console.log(results);
			/*<li class="collection-item avatar">
		  <img src="images/yuna.jpg" alt="" class="circle">
		  <span class="title">Title</span>
		  <p>First Line <br>
		     Second Line
		  </p>
		  <a href="#!" class="secondary-content"><i class="material-icons">grade</i></a>
		</li>*/
		//Destroy everything inside the div.
		document.getElementById("SearchResultsDiv").innerHTML = "";
		var ul = document.createElement("ul");
		ul.className= "collection";
		ul.id = "SearchResults";
		for (var i=0, n=results.length; i<n; ++i)
		{
			//let result = frontlinedex[results]
			var li = document.createElement("li");
			li.className = "collection-item avatar waves-effect"; //waves-effect waves-light
			li.style.display = '';
			
			
			var icon = document.createElement("i");
			icon.className = "material-icons circle red";
			li.appendChild(icon);
			
			var span = document.createElement("span");
			span.className = "title";
			span.innerText = results[i].name;
			li.appendChild(span);
			
			var p = document.createElement("p");
			p.innerHTML = results[i].type + " <br> No." + (results[i].num>0 ? results[i].num : "?");
			li.appendChild(p);
			
			//You're probably gonna say this is terrible and blah blah but T-Doll names are unique anyways
			/*for (var j =0; j < frontlinedex.length;j++)
			{
				
			}*/
			if (results[i].internalName)
			{
				li.setAttribute("onclick","TDollInfo(\""+results[i].internalName+"\")")
				li.id = "tDollSearch"+results[i].internalName
			}
			
			
			//Handle stars
			var secondaryContent = document.createElement("div");
			secondaryContent.className = "secondary-content";
			num2stars(secondaryContent,results[i].rating)
			li.appendChild(secondaryContent);
			
			ul.appendChild(li);
		}
		
		document.getElementById("SearchResultsDiv").appendChild(ul);
	}
	
	var delayTimer;
	function searchDolls(query)
	{
		clearTimeout(delayTimer);
		delayTimer = setTimeout(function() {
			
			if (query == "" || query == undefined)
			{
				listResults(frontlinedex);
			}
			else
			{
				
				query = query.toLowerCase();
				/*for (var i=0, n=frontlinedex.length; i<n; ++i)
				{
					if ('alias' in frontlinedex[i] && query == frontlinedex[i]['alias'].toLowerCase())
					{
						console.log("Found alias for "+frontlinedex[i]['name']);
						//console.log(frontlinedex[i]);
						listResults([frontlinedex[i]]);
						return true;
					}
				}*/
				console.log("Searching for "+query);
				
				var results = fuse.search(query);
				console.log("Got "+results.length + " results");
				//I don't care if it's slow
				listResults(Array.from(results, r => r['item']));
			}
		}, 300);
	}
	
	function FetchTDollInfo()
	{
		if (frontlinedex != null && CharacterVoice != null)
			return;
		fetch("girlsfrontline-min.json")
		.then(response => response.json())
		.then(json => {
			console.log("girlsfrontline-min loaded!");
			console.log(json);
			
			frontlinedex = json;
			
			/*fetch("gf_flavortext.json").then(response => response.json()).then(json2 => {
				console.log("Bonus information loaded.");
				console.log("Injecting aliases and quotes...");
				bonusdex = json2;
				frontlinedex.forEach(doll => {
					if (doll['name'] in bonusdex)
					{
						if ('alias' in bonusdex[doll['name']])
							doll['alias'] = bonusdex[doll['name']]['alias']
					}
				})
				console.log("Done.");
			});*/
			
			fuse = new Fuse(frontlinedex, {
				keys: ['name']
			})
			//fuse = new Fuse(Object.keys(frontlinedex));
			

			
			listResults(frontlinedex);
		});
		
		fetch('CharacterVoicePlus.json')
		.then(response => response.json())
		.then(json => {
			console.log("NewCharacterVoice.json loaded!");
			CharacterVoice = json;
		});
	}
	
	MissingPortraits = null;
	function FetchMissingPortraitDB()
	{
		if (MissingPortraits != undefined)
			return
		fetch('missingPortraits.json')
		.then(response => response.json())
		.then(json => {
			console.log("missingPortraits.json loaded!");
			console.log(json);
			MissingPortraits = json;
			let stuff = document.getElementById("helpInterpreterChapters");
			
			let ul = document.createElement('ul');
			ul.classList.add('collapsible')
			let li = document.createElement('li');
			li.style="text-align:left"
			let collapsible_header = document.createElement("div");
			collapsible_header.classList.add('collapsible-header');
			let collapsible_body = document.createElement('div');
			collapsible_body.classList.add('collapsible-body');
			collapsible_body.classList.add('collection');
			
			let collectionItem = document.createElement('a');
			collectionItem.classList.add('collection-item');
			for (const key in MissingPortraits)
			{
				let thisSection = li.cloneNode(true);
				let sectionTitle = collapsible_header.cloneNode(true)
				sectionTitle.innerHTML='<i class="material-icons">expand_more</i>'+key;
				thisSection.appendChild(sectionTitle)
				
				let sectionData = collapsible_body.cloneNode(true)
				for (const epName in MissingPortraits[key])
				{
					let item = collectionItem.cloneNode(true)
					item.innerText = epName
					item.href="#"+MissingPortraits[key][epName];
					item.setAttribute("onclick","onChapterSelected('"+MissingPortraits[key][epName]+"'); document.getElementById('chapterName').scrollIntoView()")
					sectionData.appendChild(item)
				}
				thisSection.appendChild(sectionData)
				ul.appendChild(thisSection);
			}
			stuff.innerHTML = ""
			stuff.appendChild(ul)
			
			//I'm lazy, so deal with it
			document.querySelectorAll('.collapsible').forEach(el => {
				var instance = M.Collapsible.init(el, null);
			});

			//
			
		});
	}
	
	
	//Keep this at the bottom
	window.onload=function()
	{
		setCheckboxFromCookie('fancyOrNot',true);
		setCheckboxFromCookie('quickScroll',true);
		//setCheckboxFromCookie('inlineText',false);
		setCheckboxFromCookie('advancedCSS',true);
		setCheckboxFromCookie('showInteractiveInterpreter',false);
		hideInterpreterButton();
		setCheckboxFromCookie('showDebugOpcodeButton',false);
		setCheckboxFromCookie('skipGenerationOfDuplicateBoxes',false);
	
		fetch('chapterDatabase.json')
		.then(response => response.json())
		.then(json => {
			console.log("cutscene information loaded!");

			listOfChapters = json['story'];
			MUSIC = json['music'];
			BACKGROUNDS = json['bg'];
			
			generateTables();
			document.querySelectorAll('.dropdown-trigger').forEach(elems => {
				var instances = M.Dropdown.init(elems, {constrainWidth:false});
			});
			
			//Can't run until chapters and portraits are loaded...... Which means this can fail because portraitInformation.json isn't awaited
			//TODO: Fix it, duh
			if (true)
			{
				let [type,chapter,episode] = getKeysFromRoutableString(window.location.hash.slice(1))
				if (type && chapter && episode && listOfChapters[type][chapter]['episodes'][episode])
					runFromRoutableKeyString(window.location.hash.slice(1));
				else
					runFromRoutableKeyString(getCookie('lastViewedScene'));
			}
		});
		
		document.querySelectorAll('.tabs').forEach(el => {
			var instance = M.Tabs.init(el, null);
			//instance.updateTabIndicator();
		});
		
		/*document.querySelectorAll('.dropdown-trigger').forEach(elems => {
			var instances = M.Dropdown.init(elems, {constrainWidth:false});
		});*/
		
		 
		document.querySelectorAll('.collapsible').forEach(elems => {
			var instances = M.Collapsible.init(elems, null);
		});
		
		document.querySelectorAll('.modal').forEach(el => {
			var instance = M.Modal.init(el, null);
			//instance.updateTabIndicator();
		});
		
		M.FormSelect.init(document.querySelectorAll('select'), null);
		
		fetch('portraitInformation.json')
			.then(response => response.json())
			.then(json => {
				console.log("portraitinformation.json loaded!");
				PORTRAITS = json;
			});
		
		// Select the button
		//const btn = document.querySelector(".nightMode-toggle");
		// Check for dark mode preference at the OS level
		const prefersDarkScheme = window.matchMedia("(prefers-color-scheme: dark)");
		// Get the user's theme preference from local storage, if it's available
		//const currentTheme = localStorage.getItem("theme");
		const currentTheme = getCookie('theme');
		//print(currentTheme);


		// If the user's preference in localStorage is dark...
		if (currentTheme == "")
		{
			document.body.classList.toggle(prefersDarkScheme ? "dark-theme" : "light-theme")
			setCookie('theme',prefersDarkScheme ? "dark-theme" : "light-theme",180);
		}
		else if (currentTheme == "black-theme") {
			document.body.classList.toggle("black-theme");
			isDarkMode=true
		}
		else if (currentTheme == "dark-theme") {
		  // ...let's toggle the .dark-theme class on the body
		  document.body.classList.toggle("dark-theme");
		  isDarkMode=true
		// Otherwise, if the user's preference in localStorage is light...
		} else {
		  // ...let's toggle the .light-theme class on the body
		  document.body.classList.toggle("light-theme");
		  isDarkMode=false;
		}
		
		
		let textarea = document.getElementById('textarea1')
		textarea.oninput = function(e,el) {
			let self = e ? e.target : el
			self.style.height = "";
			self.style.height = Math.min(self.scrollHeight, 300) + "px";
		};
		textarea.value = `portrait;0;FAIL;0;false;false;
speaker;El Fail
bgm;intro_number_61
bg;140
msg;Hello world!
msg;<color=#00CCFF>This is</color> <color=#FF00AA>colored text.</color>
msg;<size=50>This is sized text.</size>
msg;<size=60>This is even bigger text.</size>
msg;As you can see, this section is still a work in progress. So you should probably check back later.
portrait;0;FAIL;0;true;false;
portrait;1;NytoIsomer;4;false;false;
speaker;Dandelai;
msg;<color=#1aff1a>Make sure you save your work in a text file, as it will not be saved here.</color>`
		//Unfortunately oninput() function doesn't work to calculate the size when the element display is none, so just pick a value
		textarea.style.height='230px'
	}
	
	function setCheckboxFromCookie(idOfCheckbox,defaultValueIfNotSet)
	{
		let c = getCookie(idOfCheckbox);
		if (c==undefined || c=="")
		{
			//Cookies can only be strings
			c=defaultValueIfNotSet.toString();
			setCookie(idOfCheckbox,defaultValueIfNotSet,180);
		}
		//console.assert(c);
		console.assert(document.getElementById(idOfCheckbox),"no element named "+idOfCheckbox)
		console.log("Setting "+idOfCheckbox+" to "+c);
		document.getElementById(idOfCheckbox).checked = (c=='true');
	}
	function setCookieFromCheckbox(idOfCheckbox)
	{
		setCookie(idOfCheckbox,document.getElementById(idOfCheckbox).checked,180);
	}
	
	function hideInterpreterButton()
	{
		if (!document.getElementById('showInteractiveInterpreter').checked)
		{
			document.getElementById("startButton").style="display:none"
		}
		else
		{
			document.getElementById("startButton").style=""
		}
	}


	
</script>
<body>
  <nav class='nav-extended'>
    <div class="nav-wrapper" id='theTop' style="overflow:hidden;">
      <a href="#" class="brand-logo center" style="text-overflow: ellipsis; white-space: nowrap;">
      	<span class='header-desktop'>GFL Cutscene Interpreter (beta)</span>
      	<span class='header-desktop-shorter'>GFL Cutscene Interpreter</span>
      	<span class='header-mobile'>GFL C.I.</span>
      	
	</a>
	
      <ul id="nav-mobile" class="right">
        <li><a onclick="NightMode()" class="waves-effect waves-light navbarButton"><i class="material-icons left">brightness_2</i><span class='header-desktop'>Night Mode</span></a></li>
        <li><a href="#settingsModal" class="waves-effect waves-light modal-trigger navbarButton"><i class="material-icons left">settings</i><span class='header-desktop'>Settings</span></a></li>
      </ul>
    </div>
			<div class="col s12 nav-content">
				<ul class="tabs tabs-transparent">
					<li class="tab col s3"><a href="#mainEpisodesWrapper">Main Story Chapters</a></li>
					<li class="tab col s3"><a href="#eventEpisodesWrapper">Story Events</a></li>
					<li class="tab col s3"><a href="#sideEpisodesWrapper">Side Stories</a></li>
					<li class="tab col s3"><a href="#crossoverEpisodesWrapper">Crossover Stories</a></li>
					<li class="tab col s3"><a href="#helpInterpreter" onclick="FetchMissingPortraitDB()">Help the interpreter</a></li>
					<li class="tab col s3"><a href="#TDollStuff" onclick="FetchTDollInfo()">T-Doll Dialogue (WIP)</a></li>
					<li class="tab col s3"><a href="#customCutsceneWrapper">Write your own cutscene (WIP)</a></li>
				</ul>
			</div>
  </nav>

	<!-- Modal Structure -->
	<div id="settingsModal" class="modal">
		<div class="modal-content">
		<h4>Settings</h4>

		<table class="material-settings-table">
			<!--<tr>
				<td style="width:100%">
					<span class="title">Use system dark mode</span>
					<p>Are you one of those cool kids that has Android 10 or iOS 13 or Windows 10? Turn this on to match your device&apos;s preferences.</p>
				</td>
				<td>
					<div class="switch">
						<label>
						  <input type="checkbox" onclick="setCookieFromCheckbox('systemDarkMode');" id="fancyOrNot">
						  <span class="lever"></span>
						</label>
					</div>
				</td>
			</tr>-->
			<tr>
				<td style="width:100%">
					<span class="title">Display images and portraits in cutscenes</span>
					<p>Turn it off if you want to save your mobile data.</p>
				</td>
				<td>
					<div class="switch">
						<label>
						  <input type="checkbox" onclick="setCookieFromCheckbox('fancyOrNot'); runFromRoutableKeyString()" id="fancyOrNot">
						  <span class="lever"></span>
						</label>
					</div>
				</td>
			</tr>
			<tr>
				<td style="width:100%">
					<span class="title">Quick scrolling</span>
					<p>Click or tap an image to jump to the next one in cutscenes.</p>
				</td>
				<td>
					<div class="switch">
						<label>
						  <input type="checkbox" onclick="setCookieFromCheckbox('quickScroll'); runFromRoutableKeyString()" id="quickScroll">
						  <span class="lever"></span>
						</label>
					</div>
				</td>
			</tr>
			<!--<tr>
				<td style="width:100%">
					<span class="title">Inline Text</span>
					<p>Make the text display on top of the image.</p>
				</td>
				<td>
					<div class="switch">
						<label>
						  <input type="checkbox" onclick="setCookieFromCheckbox('inlineText'); runFromRoutableKeyString()" id="inlineText">
						  <span class="lever"></span>
						</label>
					</div>
				</td>
			</tr>-->
			<tr>
				<td style="width:100%">
					<span class="title">Advanced CSS Effects</span>
					<p>Enable more demanding effects like snow animations. It might lag on mobile devices.</p>
				</td>
				<td>
					<div class="switch">
						<label>
						  <input type="checkbox" onclick="setCookieFromCheckbox('advancedCSS'); runFromRoutableKeyString()" id="advancedCSS">
						  <span class="lever"></span>
						</label>
					</div>
				</td>
			</tr>
			<!--<tr>
				<td style="width:100%" colspan="2">
					<span class="title">Effect Detail Level</span>
					<p>More advanced effects. Lower the value if your device is lagging.</p>
					<p>Off: No fancy HTML stuff.</p>
					<p>Medium: Night BGs are rendered and blue portrait masks display correctly.</p>
					<p>High: CSS snow and fire effects are displayed.</p>
					<div class="input-field col s12">
						<select>
						  <option value="1">Off</option>
						  <option value="2">Medium</option>
						  <option value="3">High</option>
						</select>
					</div>
				</td>
			</tr>-->
			<tr>
				<td style="width:100%">
					<span class="title">Show interactive interpreter button</span>
					<p>It doesn't work well and not every browser supports it. You probably want to keep this disabled.<br>(Interpreter v2 coming eventually I swear)</p>
				</td>
				<td>
					<div class="switch">
						<label>
						  <input type="checkbox" id="showInteractiveInterpreter" onclick="setCookieFromCheckbox('showInteractiveInterpreter'); hideInterpreterButton()">
						  <span class="lever"></span>
						</label>
					</div>
				</td>
			</tr>
			<tr>
    			<td style="width:100%">
    				<span class="title">Skip duplicate story CG boxes</span>
    				<p>Skips generating a new CG box if only the speaker's name changed.</p>
    			</td>
    			<td>
					<div class="switch">
						<label>
						  <input type="checkbox" id="skipGenerationOfDuplicateBoxes" onclick="setCookieFromCheckbox('skipGenerationOfDuplicateBoxes'); runFromRoutableKeyString()">
						  <span class="lever"></span>
						</label>
					</div>
				</td>
			</tr>
			<tr>
				<td style="width:100%">
					<span class="title">Debug Mode</span>
					<p>Displays buttons for showing debug opcodes in cutscenes and warns if a portrait is missing. You probably don't want this enabled.</p>
				</td>
				<td>
					<div class="switch">
						<label>
						  <input type="checkbox" id="showDebugOpcodeButton" onclick="setCookieFromCheckbox('showDebugOpcodeButton')">
						  <span class="lever"></span>
						</label>
					</div>
				</td>
			</tr>
			<!--<tr>
				<td style="width:100%">
					<span class="title">Show export button</span>
					<p>Export current cutscene to an html or odt file.</p>
				</td>
				<td>
					<div class="switch">
						<label>
						  <input type="checkbox" id="showDebugOpcodeButton" onclick="setCookieFromCheckbox('showDebugOpcodeButton')">
						  <span class="lever"></span>
						</label>
					</div>
				</td>
			</tr>-->
		</table>
		</div>
		<div class="modal-footer">
		  <a class="modal-close waves-effect waves-green btn-flat">Close</a>
		</div>
	</div>
	<div id="savePageModal" class="modal">
		<div class="modal-content">
			<h4>Exporter</h4>
			<p>Pick how you want stuff to be saved.</p>
			<!--<p>Self contained: all images will be converted to base64 and embedded in the HTML file. This generally makes webpages <b>very</b> large and upwards of 100MB. You should only use this if you're planning on uploading it to Google Docs.</p>-->
			<!--<p>Self contained js-compressed: Images are stored in a JavaScript var and then applied through JS to save disk space, but JavaScript is required.</p>-->
			<p>.odt: OpenDocument Text Format. Great for uploading to Google Docs and editable in various word processors. All storyboxes with portraits will be baked into unique images. <b>This process requires a lot of memory, so please do it on a computer or a moderately powerful device.</b></p>
			<p>Zipped: Images are outside of the webpage.</p>
		</div>
		<div class="modal-footer">
		  <a class="modal-close waves-effect waves-green btn-flat">self contained html</a>
		  <a class="modal-close waves-effect waves-green btn-flat">self contained js-compressed html</a>
		  <a class="modal-close waves-effect waves-green btn-flat">.odt</a>
		  <a class="modal-close waves-effect waves-green btn-flat">zipped</a>
		  <a>
		</div>
	</div>
	<!-- Needs to be here so the modal for T-Doll search will be fullscreen on mobile devices. Otherwise it will be below the navbar.-->
	<div id="tDollDialogueActivity" class="modal modal-fixed-footer" style="overflow:hidden">
		<nav style="position:initial;">
			<div class="nav-wrapper blue" style="text-align: left;">
			  <a href="#!" class="brand-logo modal-close" id='tDollDialogueName'>Insert T-Doll Name Here<i class="material-icons">arrow_back</i></a>
			</div>
		</nav>
		<div id="tDollDialogue" class='modal-content'>
		
		</div>
	</div>
  
	<noscript><h1>Turn on JavaScript. This is not a static webpage, it is literally interpreting the GFL text on the fly using JS and rendering it to HTML elements to display it in your browser.</h1></noscript>
	<noscript><h3>Static HTTP pages are coming never. You'll have to look at the source code and write it yourself.</h3></noscript>
	<div id='chapterSelect' class='navbar-fixed'>
		<div class='row'>
			<!--<a href=#modal1" class="modal-trigger" >Settings</a>-->

			<!--Because materialize.js is stupid -->
			<div class="col s12" id="mainEpisodesWrapper">
				<div class="flex-container col s12" id="mainEpisodes"></div>
			</div>
			
			<div class="col s12" id="eventEpisodesWrapper">
				<p>Deep Dive, Singularity, and Continuum Turbulence are not sorted yet. Polarized Light&apos;s portraits will be finished by 5/18 at the latest, I swear!</p>
				<div class="flex-container col s12" id="eventEpisodes"></div>
			</div>
			<div class="col s12" id="sideEpisodesWrapper">
				<div class="flex-container col s12" id="sideEpisodes"></div>
			</div>
			<div class="col s12" id="crossoverEpisodesWrapper">
				<div class="flex-container col s12" id="crossoverEpisodes"></div>
			</div>
			<!--<div class="col s12" id="fanmadeEpisodesWrapper">
				<h2>Yep, there's fanmade stuff here! Mostly just interpreter tests, though.</h2>
				<h2>Want your fanfiction featured here? Email me whatever you wrote and I'll put it up.</h2>
				<div class="flex-container col s12" id="fanmadeEpisodes"></div>
			</div>-->
			<div class="col s12" id="helpInterpreter">
			
				  <div class="card blue-grey darken-1" style="text-align:left">
					<div class="card-content white-text">
					  <span class="card-title">Help fix missing portraits!</span>
					  <p>Portraits have to be entered into the database manually if they don't follow a standardized naming scheme. (Which is something MICA likes to do a lot.)</p>
					  <p>You can help fix missing portraits faster by checking the cutscenes ingame, comparing it with the interpreter, and emailing me a screenshot along with ID and type of the missing portrait.</p>
					  <p><b>Turn on debug mode</b> in interpreter settings to see the exact ID and type of a missing portrait. It will show <b>above</b> the cutscene box.</p>
					  <p>My email is at the bottom of the page.</p>
					</div>
				  </div>
				<h3>Chapters With Missing Portraits</h3>
				<div id="helpInterpreterChapters">
				
					<div class="progress">
					  <div class="indeterminate"></div>
					</div>
				</div>
				<hr>
			</div>
			<div class="col s12" id="TDollStuff">
				<!--I don't know how to do iframes or AJAX, apparently-->
				<!--<iframe src="quoteBrowser.html"></iframe>-->

				<div id="tDollSearchActivity">
					<form action="?">
					<div class="input-field" style="text-align: left;">
						<i class="material-icons prefix">search</i>
						<!--<label class="label-icon" for="search">
						</label>-->
						<input id="search" type="search" oninput="searchDolls(document.getElementById('search').value)" onkeydown="if (event.key == 'Enter') blur(); return;" onsubmit="blur()" required>
						
						<i class="material-icons" onclick="clearSearch()">close</i>
					</div>
					</form>
					
					<div id="SearchResultsDiv"  class="" >
						<p>If you are seeing this it's still loading, please wait 1 second for the JSON to load</p>
						<p>Either that or your browser is broken, please check for an update.</p>
						<div class="progress">
						  <div class="indeterminate"></div>
						</div>
		    
					</div>
				</div>
			</div>
			<div class="col s12" id="customCutsceneWrapper">
				<div id="customCutscene">
					<p>WORK IN PROGRESS - IGNORE THE TERRIBLE UI - HALF THESE THINGS DON'T WORK YET</p>
					<p>These buttons don't do anything yet, but you can type in the textbox below and run your custom cutscene.</p>
					<a class="waves-effect waves-light btn" onclick="document.getElementById('file-input-txt').click();"><i class="material-icons right">folder_open</i>Load .txt</a>
					<a class="waves-effect waves-light btn" onclick="document.getElementById('file-input-json').click();"><i class="material-icons right">folder_open</i>Load .json</a>
					
					<!--<a class="waves-effect waves-light btn modal-trigger" href="#modal1">Modal</a>
					<div id="modal1" class="modal">
						<div class="modal-content">
						  <h4>This will replace your work! Are you sure?</h4>
						</div>
						<div class="modal-footer" style='background-color:rgba(128,128,128,0.3)'>
						  <a href="#!" class="modal-close waves-effect waves-green btn-flat" style='color:var(--text-color)'>No</a>
						  <a href="#!" class="modal-close waves-effect waves-green btn-flat" style='color:var(--text-color)'>Yes</a>
						</div>
					</div>-->
					
					<input id="file-input-txt" type="file"  accept='.txt'  name="name" style="display: none;" multiple />
					<input id="file-input-json" type="file" accept='.json' name="name" style="display: none;" />
					<br>
					<!--<h1>Materialize.js is buggy and input boxes break the website on mobile. The cutscene writer is currently disabled until I can fix it.</h1>
					<div class="input-field col s6">
					  <input id="first_name" type="text">
					  <label for="first_name">Custom Chapter Name (Optional)</label>
					</div>
					<div class="input-field col s6">
					  <input id="last_name" type="text">
					  <label for="last_name">Custom Part Name (Optional)</label>
					</div>-->
					<!--<div class="input-field col s12">
						<textarea id="textarea1" class="materialize-textarea"></textarea>
						<label for='textarea1'>Type in your txt (GFL) or iop (Interpreter) styled codes here.</label>
					</div>-->
					<!--Generic simple textarea1 that doesn't break like materialize... The div is for padding-->
					<div style='padding-top:10px'>
						<div style='text-align:left;'>Part 1</div>
						<textarea placeholder="Type in your txt (GFL) or iop (Interpreter) styled codes here." id="textarea1"></textarea>
					</div>
					<a class="waves-effect waves-light btn disabled" onclick=""><i class="material-icons add">folder_open</i>Add another part</a>
					<a class="waves-effect waves-light btn disabled" onclick=""><i class="material-icons delete">folder_open</i>Delete last part</a>
					<p>Select 'txt' if you've been using the syntax GFL uses. Select 'iop' if you've been using the interpreter's syntax.</p>
					<p>If you want to save your progress it will either save as .txt.json or .iop.json, since json would be the only possible way to store multiple parts and metadata like part and chapter titles.</p>
					<div class="switch">
						<label>
						  txt
						  <input type="checkbox" checked onclick="" id="customIsTXTorIOP">
						  <span class="lever"></span>
						  iop
						</label>
					</div>
					<br>
					<a class="waves-effect waves-light btn disabled" onclick=""><i class="material-icons right">save</i>Save as .json</a>
					<a class="waves-effect waves-light btn" onclick="runFromUserInput();"><i class="material-icons right">code</i>Run!</a>
				    <div class="card blue-grey darken-1" style="text-align:left">
        				<div class="card-content white-text">
						<span class="card-title">About .txt vs .iop.json</span>
						<p>.txt is the cutscene scripting language GFL uses. The interpreter will always support importing .txt and playing it back.</p>
						<p>.iop.json (<b>I</b>ntermediate <b>Op</b>codes, definitely not a coincidence) is the scripting language designed for the interpreter. It has some advantages compared to the GFL engine:</p>
						<p>- Display more than two characters at a time. Dim multiple charcters. Dim no characters.</p>
						<p>- Dimming doesn't randomly break, because dimming is manually set. </p>
						<p>- The commands are in english. It's also very verbose.</p>
						<p>- You can use + in messages. (GFL's txt script treats + as 'next line')</p>
						<p>- (Coming soon) branch paths, allowing you to use the interpreter like a VN engine of sorts and write interactive stories</p>
						<p>- Load multiple parts, since the only reasonable way to have more than one part would be to use JSON.</p>
						<p>The disadvantages:</p>
						<p>- The verbosity will make you type a lot.</p>
						<p>- Since dimming is manually done, it might get confusing.</p>
						<p>- Good luck memorizing all 5 arguments for a message opcode.</p>
						</div>
					</div>
					<div class="card blue-grey darken-1" style="text-align:left">
        				<div class="card-content white-text">
							<span class="card-title">.txt (MICA format) documentation</span>
						</div>
						<div class="card-action">
							<a href="https://github.com/RhythmLunatic/gfl-cutscene-interpreter/blob/main/GF%20Syntax%20Information.md">Click Me</a>
						</div>
					</div>
					<div class="card blue-grey darken-1" style="text-align:left">
        				<div class="card-content white-text">
							<span class="card-title">.iop.json documentation</span>
							<p>Work in progress... Please be patient...</p>
						</div>
						<div class='card-tabs'>
							<ul class="tabs blue-grey darken-1 tabs-fixed-width white-text">
								<li class="tab"><a class='active' href="#bg">Background (bg)</a></li>
								<li class="tab"><a href="#bgm">Music (bgm)</a></li>
								<li class="tab"><a href="#portrait">Portraits (portrait)</a></li>
							</ul>
							<div class='card-content white-text'>
								<div id='bg'>
									<p>BG Syntax: ID;isNight (optional).</p>
									<p>Backgrounds are stored in the avgtexture folder and indexed in-game with profiles.txt.</p>
									<p>As displaying every single image would be disasterous and I only have about 500GB of bandwidth per month on this webserver, please click the link below to show an image of all the backgrounds with IDs arranged in a neat grid.</p>
								</div>
								<div id='portrait'>
									<p>Portraits are in the format of: idx;name;type;dim;isMasked</p>
									<p>Arguments 4 and 5 can be omitted, they will automatically be converted to false.<p>
									<p>idx - Which side. 0 for left, 1 for right. (indexes above 1 are not supported currently)</p>
									<p>name - The internal name of the T-Doll. Hint: Ctrl+F portraitInformation.json</p>
									<p>type - Usually costume, sometimes expression</p>
									<p>dim (optional) - true for dim, false for not dim</p>
									<p>isMasked (optional) - like dim</p>
									<a href="/portraitInformation.json">portraitInformation.json</a>
								</div>
								<div id='bgm'>
									<p>Music is just the filename.</p>
									<p>The file index is enabled. Click the button to see all the files.</p>
									<a href="/audio">Index</a>
									<!--<div class="card-action">
										<a href="/audio">Index</a>
										<a href="#" class='dropdown-trigger' data-target='dropdownMusic'>Select by name</a>
									</div>-->
								</div>
							</div>
						</div>
					</div>
					<div class="card blue-grey darken-1" style="text-align:left">
        				<div class="card-content white-text">
							<span class="card-title">How to specify music?</span>
							<p>Music is just the filename.</p>
							<p>The file index is enabled. Click the button to see all the files.</p>
							<p>Alternatively you can use the dropdown and it will paste a bgm command at the end. As it is still WIP and has to be updated manually, you're better off using the index.</p>
						</div>
						<div class="card-action">
							<a href="/audio">Index</a>
							<a href="#" class='dropdown-trigger' data-target='dropdownMusic'>Select by name</a>
						</div>
					</div>
					  <!-- Dropdown Structure -->
					  <ul id='dropdownMusic' class='dropdown-content'>
						<li><a href="#!">one</a></li>
						<li><a href="#!">two</a></li>
					  </ul>
					<!--<ul class="collapsible">
						<li>
						  <div class="collapsible-header">About .txt vs .iop.json</div>
						  <div class="collapsible-body"></div>
						</li>
					</ul>-->
				</div>
			</div>
				
		</div>
		
	</div>
	
	<h2 id="chapterName" style="display:inline">Chapter Name Here</h2>
	<!--<ul class="pagination" id='partSelect'>
		<li class='disabled'><a style='color:var(--text-color);'>Jump to:</a></li>
		<li class="active"><a href="#!">Part 1</a></li>
		<li class="active waves-effect"><a href="#!">Part 2</a></li>
		<li class="active waves-effect"><a href="#!">Part 3</a></li>
		<li class="active waves-effect"><a href="#!">Part 4</a></li>
	</ul>-->
	<!--<a onclick="copyLink()" class="waves-effect waves-light btn">Copy chapter link</a>-->
    <a id="startButton" onclick="initPhaser()" class="waves-effect waves-light btn">Start interactive interpreter (It's like playing the game!)</a>
	<div id="interactiveInterpreterSection" style="display:none;">
		<a id='stopButton' class="waves-effect waves-light btn"> Stop the interpreter (You'll have to refresh the site to start it up again, sorry)</a>
		<p id="curIndexDebug"></p>
		<div id="phaser"></div>
		<!--This is for phaser only!-->
		<br><br><button onclick="showOpcodes('myDIV')">Show converted opcodes (For debugging)</button><br>
		<div id='myDIV' style="display: none;">
			<textarea rows='6' cols='50' id="DebugTextArea"></textarea><br>
			<button onclick="reRunWithNewOpcodes()">Re-run scene with these opcodes</button>
		</div>
	</div>

	<hr>

	<div id="verySimpleText"></div>
	<a class="waves-effect waves-light btn" onclick="document.getElementById('theTop').scrollIntoView()"><i class="material-icons left">vertical_align_top</i>Back to top</a> <a class="waves-effect waves-light btn" onclick="goToNextEpisode();"><i class="material-icons left">chevron_right</i>Go to the next cutscene</a>
	<hr>
	<audio controls loop id="audioPlayer">
		<source class='a_ogg' src="" type="audio/ogg"> <!-- Turns out putting something in makes firefox load it when you load the page, wasting bandwidth. But leaving it blank is fine. -->
		<source class='a_mp3' src="" type="audio/mp3"> <!-- Because iOS doesn't support ogg -->
		Your browser does not support the audio tag.
	</audio>
	<p>Dandelion is my wife, greets to /gfg/, <a href="https://github.com/RhythmLunatic/gfl-cutscene-interpreter">harass me on github (bug reports, check the source code, fork it)</a></p>
	<!--<p>If you would like an improved UI, fix it yourself and submit a pull request. I don't know React/Vue/etc.</p>-->
	<p>If you want a feature or something is broken, <b><a href="https://github.com/RhythmLunatic/gfl-cutscene-interpreter/issues">file a bug report</a></b> or <a onmousemove="(function(self){self.href='mailto:kirbyrulez'+String.fromCharCode(64)+'att.net'})(this)" href="mailto:'hover mouse over the link twice to pass the bot check'"><b>email me</b></a>.</p>
	<p><a href='/LICENSE.html'>The interpreter is free and open source software and licensed under AGPLv3.</a></p>
	<p>Designed using <a href='https://materializecss.com'>Materialize</a>, the ultimate front-end framework for people like me who can't be bothered to learn the hard shit like react or vue. <a href='https://github.com/Dogfalo/materialize/blob/master/LICENSE'>MIT license</a></p>
	
	<hr>
	<!--<p><b>e-begging</b></p>-->
	<p><a href="http://amaryllisworks.pw/getraveitout">Try the rhythm game I programmed, it's free and open source</a></p>
	<!--<a href='https://ko-fi.com/D1D7Y21A'>Help pay for server hosting because it costs $30 a year for the server and $10 a year for the domain name</a>-->
	<p>I'm currently jobless so if you're reading this and you need a programmer, email me. I have 5 years of experience with lua and some experience with Python, C++, JavaScript, and C#.</p>
	<!--<p>Donate if you like the site and its features. Of course, development will continue regardless of donations. Money will go towards paying for the server ($2.50/mo) and the domain name ($20/yr).</p>
	<script src='https://storage.ko-fi.com/cdn/scripts/overlay-widget.js'></script>
<script type='text/javascript' src='https://storage.ko-fi.com/cdn/widget/Widget_2.js'></script><script type='text/javascript'>kofiwidget2.init('Support Me on Ko-fi', '#29abe0', 'D1D7Y21A');kofiwidget2.draw();</script> -->
	<!--<p><a href="https://github.com/RhythmLunatic/Girls-Frontline-Discord-Search">Try out my Girls' Frontline discord bot.</a> T-Doll info, quotes, costumes, and more!</p>-->
	<!--<hr>
	<p>Message Board: Leave a message here for me or others to see.</p>
	<form>
	        <div class="input-field col s6">
          <input id="first_name" type="text" class="validate">
          <label for="first_name">Nickname</label>
        </div>
		<textarea id="" placeholder="Put your comment here"></textarea>
	</form>-->
</body>
