<!doctype html>
<head>
	 <meta charset="utf-8"/>
    <title>GFL cutscene interpreter</title>
     <link rel="preconnect" href="https://fonts.gstatic.com">
     <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR&display=swap" rel="stylesheet"> 
</head>
<style type="text/css">
body
{
	background-color: black;
	text-align:center;
	color: white
}
button
{
	background-color: black;
	color:white;
}

table, th, td {
   border: 1px solid #222222;
   border-collapse: collapse;
}
th {
	background-color: purple;
}
select {
	color: white;
}

tr:nth-child(odd) {
    background-color: #000000CC;
}
tr:nth-child(even) {
    background-color: #111111CC;
}

#verySimpleText{
	text-align: left;
}

.container {
  position: relative;
  text-align: center;
  color: white;
}

.charName {
      font-family: 'Noto Sans KR', sans-serif;
  position: absolute;
  top: 5px;
  left: 16px;
  font-size: 2vw;
}

.absText {
      font-family: 'Noto Sans KR', sans-serif;
  position: absolute;
  top: 45px;
  left: 16px;
  font-size: 2.2vw;
}
</style>
<script type="text/javascript"></script>
<!--<script src="phaser.js"></script>-->
<script src="//cdn.jsdelivr.net/npm/phaser@3.24.1/dist/phaser.min.js"></script> 
<script>
	/*
	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU Affero General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU Affero General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.

	This program is written by Rhythm Lunatic.
	*/
	
	/*
		Just gonna say it right now, I don't know an ounce of JavaScript or phaser.
		I interpreted lua and my game engine knowledge until this worked.
		
		So that's the answer as to why the chapter select looks like dogshit. Make a PR if you want it to be fixed.
	*/

	/* opcode dictionary
		Seriously who designed this, can't you use normal fucking opcodes?
		XXX() - Set portrait. XXX is character sprite. Can have multiple of these. Actually does not need to be the first opcode.
		; - Unknown purpose. Could be used for switching highlights? Seems to separate two portrait opcodes.
		<BGM> - Set BGM
		<BIN> - Set background
		<Speaker> - Set the speaker name
		|| - Separator. Things after this separator will be run later, maybe? Usually transition commands, shake effects, etc are after these
		<黑点X> - Black dot screen transition. X=1 for in, 2 for out.
		<通讯框> - "Communication box". Display character portrait inside a communication box.
		<震屏> - Screen shake effect
		: - End of opcodes, text goes here (Other than +)
		+ - End text. Text will continue in a new box (no close/open animation) when clicked.
		
	*/
	//I kept accidentally typing print ok
	window.print = function(param)
	{
		console.log(param);
	}
	
	const opcode = {
		BGM : 1,
		BG : 2,
		SPEAKER : 3,
		MSG : 4,
		PORTRAIT : 5,
		NOPORTRAIT : 6,
		MSGBOXTRANSITION : 7,
	}
	const tag2opcode = {
		"Speaker":opcode.SPEAKER,
		"BIN":opcode.BG,
		"BGM":opcode.BGM
	}
	
	const backgrounds = {
		8: "作战室avg",
		9: "black",
		10: "PlaybackBG1",
		15: "室内战斗",
	}
	
	//It's a separate directory because... I don't know. Just live with it.
	const portraitWebserver = "http://gfl.amaryllisworks.pw:998/pic/"
	
	//Don't care if it's all over the place. Fix it yourself. If this was SM I'd be using broadcasts anyways
	var nameActor;
	var bgActor;
	
	function loadBG(runtime, num)
	{
		console.log("Loading "+num+" | "+backgrounds[num])
		runtime.load.once('complete',function() { bgActor.setTexture(num);bgActor.displayWidth = 1280;bgActor.displayHeight= 1280; },runtime)
		runtime.load.image(num,'avgtexture/'+backgrounds[num]+'.png');
		runtime.load.start();
	}
	
	//var interval;
	//Yes, I did translate it from lua. Lmao.
	class VNText4 {
		constructor(phaserRuntime,font,maxwidth,spd,msgTable)
		{
			this.phaserRuntime = phaserRuntime; //lol
			this.cur_len = 0;
			this.spd = spd;
			this.curIndex = 0;
			this.msgTable = msgTable;
			
			this.textActor = phaserRuntime.add.text(0,0,'Static Text Object', { fontFamily: 'Noto Sans KR', fontSize: 27, color: '#ffffff', wordWrap: {width:maxwidth,useAdvancedWrap:true} });
		}
		is_finished()
		{
			return this.cur_len == this.text.length;
		}
		
		//In StepMania you can just chain a command (within an actor) with sleep over and over, but in phaser you have to attach it to the game engine?
		//Attaching tweens to the game engine instead of actors is kind of a weird decision by the way, why wouldn't you attach them to the actor?
		//I'm using setInterval anyways
		play()
		{
			
			let f = function(self){
				self.cur_len = self.textActor.text.length;
				//console.log(self.cur_len+"/"+self.text.length);
				if (self.cur_len < self.text.length)
				{
					let txt = self.text.slice(0,self.cur_len+1)
					//console.log(txt);
					self.textActor.setText(txt);
				}
				else
				{
					clearInterval(f);
				}
			}
			
			f(this);
			
			//console.log(1/this.spd*1000);
			let interval = setInterval(f,1/this.spd*1000,this);
			//This can't possibly be high performance...
			
			/*phaserRuntime.tweens.add({
				targets:this.textActor,
				ease:'Linear',
				duration:1/this.spd,
				onComplete:this.play
			)}*/
				
			
		}
		Text()
		{
			this.cur_len = this.textActor.text;
			if (this.cur_len < this.text.length)
				this.textActor.setText(this.text.slice(0,this.cur_len));
		}
		advance()
		{
			if (this.no_more_text())
				return;
			//this.curIndex++;
			var noMsgYet = true;
			while (noMsgYet)
			{
				console.assert(this.msgTable[this.curIndex],"There is no opcode located at "+this.curIndex+". How did you even get this far?")
				let MsgOpcode = this.msgTable[this.curIndex][0]
				//console.log(opcode)
				//console.log(this.curIndex);
				//console.log(MsgOpcode == opcode.MSG);
				switch(MsgOpcode) {
					case opcode.MSG:
						this.cur_len= 0
						this.text = this.msgTable[this.curIndex][1]
						//this.text_actor:queuecommand("Check")
						noMsgYet = false;
						break;
					case opcode.SPEAKER:
						nameActor.setText(this.msgTable[this.curIndex][1]);
						break;
					case opcode.BG:
						loadBG(this.phaserRuntime,this.msgTable[this.curIndex][1]);
						break;
					case opcode.PORTRAIT:
						console.log(this.msgTable[this.curIndex][1])
						break;
					//lua junk from my message system. Just ignore it.
					/*case opcode.FMSG:
						this.cur_len= 0
						this.text = this.msgTable[this.curIndex][2]()
						//this.text_actor:queuecommand("Check")
						break outLoop;
					elseif opcode == "func" then
						this.msgTable[this.curIndex][2]()
					elseif opcode == "choice" then
						ChoiceTable = {Result=1,Finished=false}
						assert(this.msgTable[this.curIndex][2],"Choice table is invalid.")
						ChoiceTable.Choices = this.msgTable[this.curIndex][2]
						assert(ChoiceTable.Choices)
					elseif opcode == "exit" then
						return false;
					elseif opcode == "condJumpSS" then
						Trace(table_print(this.selfSwitches))
						Trace(table_print(this.msgTable[this.curIndex]))
						if this.selfSwitches[this.msgTable[this.curIndex][2]] == true then
							//Subtract 1 to account for advance advancing one step, since we want to start on whatever it jumps to
							this.curIndex = this.msgTable[this.curIndex][3]-1
							Trace("Jumped to index "..this.curIndex)
						end
					elseif opcode == "condJump" then
						if this.msgTable[this.curIndex][2]() == true then
							//Subtract 1 to account for advance advancing one step, since we want to start on whatever it jumps to
							this.curIndex = this.msgTable[this.curIndex][3]-1
							Trace("Jumped to index "..this.curIndex)
						end
					elseif opcode == "selfSwitch" then
						this.selfSwitches[this.msgTable[this.curIndex][2]] = this.msgTable[this.curIndex][3]
					end;*/
				}
				this.curIndex++;
				//console.log(noMsgYet);
			}
			//Trace(this.text)
			//lua.Flush();
			//this.text_actor:settext(""):playcommand("Check");
			//console.log(this.text)
			document.getElementById('curIndexDebug').innerText="idx: "+(this.curIndex-1)+" | msg: "+this.msgTable[(this.curIndex-1)].toString()
			this.textActor.setText('');
			this.play();
		}
		no_more_text()
		{
			return this.msgTable.length == this.curIndex;
		}
		skip()
		{
			this.textActor.setText(this.text);
			this.cur_len = this.text.length;
		}
	}
	
	/*class SpriteActor() {
		constructor()
		{
			//this.
		}
	}*/
	
	function sliceAndRemove(str, begin, end)
	{
		return str.slice(0,begin)+str.slice(end)
	}
	
	function getFromTag(str,tag)
	{
		const beginTag = "<"+tag+">"
		const endTag = "</"+tag+">"
		var n = str.indexOf(beginTag)
		if (n != -1){
			return str.slice(n+beginTag.length, str.indexOf(endTag))
		}
		return null
	}
	function removeTag(str,tag)
	{
		const beginTag = "<"+tag+">"
		const endTag = "</"+tag+">"
		return sliceAndRemove(str,str.indexOf(beginTag),str.indexOf(endTag)+endTag.length)
	}
	
	
	var config = {
		type: Phaser.WEBGL,
		width: 1280,
		height: 720,
		parent: 'phaser',
		scene: {
			preload: preload,
			create: create,
		}
	};
	
	//phaser
	var game;
	
	var imageActor;
	var vntext;
	
	function preload()
	{
		//this.load.image('test','test.png');
		this.load.image('textbox','textbox.png');
	}
	
	function create()
	{
		//input.touch only works on mobile devices. So it will break on desktop. reeeee
		//game.input.touch.capture = false;
		
		//var img = this.make.image({ x:game.config.width/2, y:game.config.height/2, key:'test',add:true })
		//img.displayWidth = game.config.width
		//img.displayHeight= game.config.height
		
		//GFL, in all of it's genius, uses 1024x1024 images. With black borders.
		/*bgActor = this.make.image({ x:game.config.width/2, y:game.config.height/2, add:true });
		bgActor.displayWidth = 1024
		bgActor.displayHeight= 1024*/
		bgActor = this.add.image(game.config.width/2,game.config.height/2);
		bgActor.texture = Phaser.Cache.DEFAULT;
		
		imageActor = this.make.image({
			x:game.config.width /2,
			y:game.config.height-125,
			//scale:1,
			key:'textbox',
			add:true
		})
		imageActor.scaleY = 1
		
		//var blocks = this.add.group({ key: 'block', repeat: 139, setScale: { x: 0, y: 0 } });
		
		nameActor = this.add.text(240,500,'', { fontFamily: 'Noto Sans KR', fontSize: 30, color: '#ffffff' });
		
		vntext = new VNText4(this,'',800,13,structuredLines);
		vntext.textActor.x = 240;
		vntext.textActor.y = game.config.height-160
		vntext.advance();
		
		this.input.on('pointerdown',function(){
			if (vntext.no_more_text())
			{
				console.log("Already hit the end!!!!");
			}
			else
			{
				if (vntext.is_finished())
				{
					vntext.advance();
				}
				else
				{
					vntext.skip();
				}
			}
		},vntext)
		//Hey look it's just like StepMania
		/*this.make.text({
			x: 100,
			y: 100,
			text: 'Phaser III',
			style: {
				fontSize: '48px',
				fontFamily: 'Arial',
				color: '#ffffff',
				metrics: {
				    ascent: 45,
				    descent: 10,
				    fontSize: 55
				}
			}
		})*/
	}
	
	//I'm not even using this lmao
	function update()
	{
		
	}
	
	function run(fileName)
	{
		console.log("fetching "+fileName);
		//let url = '1-1-1.txt';
		fetch("avgtxt/"+fileName)
		.then(response => response.text())
		.then((out) => {
			console.log(out);
			var lines = out.split(/\r?\n/);
			//The GFL text system is stupid as fuck and I just spent a whole week writing my own VN system
			//So obviously I'm going to convert it to my own. fuck you
			console.log(lines)
			//Fuck your opcodes
			structuredLines = [];
			for(i=0;i<lines.length;i++)
			{
				if (!lines[i])
					continue;
				let [cmds,text] = lines[i].split(':')
				console.assert(cmds,lines[i])
				console.assert(text,lines[i])
				
				//Yeah I know tags are supposed to be in order, No I don't really care sorry
				const tags = ["Speaker","BGM","BIN"]
				tags.forEach(tag => {
					//console.log(tag);
					let tagRes = getFromTag(cmds,tag);
					//console.log(tagRes)
					if (tagRes != null)
					{
						structuredLines.push([tag2opcode[tag],tagRes])
						removeTag(cmds,tag)
					}
				})
				
				//So portraits are set in any order... But how the fuck are you supposed to tell when a name is if there's <> tags
				//I'm just going to search portraits after removing <> tags, it probably won't matter
				let numPortraits = 0;
				//Limit it to 5 because I don't want a dumb infinite loop that crashes the browser
				for(j=0;j<5;j++)
				{
					//console.log(cmds)
					let charTagEnd = cmds.indexOf(")");
					if (charTagEnd != -1)
					{
						let charTagStart = Math.max(cmds.lastIndexOf(";",charTagEnd),0)
						let [charID,charSpr] = cmds.slice(charTagStart,charTagEnd).split("(")
						//console.log(charID)
						//console.log(charSpr)
						//Ignore empty sprite IDs, they do nothing.
						if (charSpr != "")
						{
							numPortraits++;
							structuredLines.push([opcode.PORTRAIT,charID,charSpr])
						}
						//I think speaker name gets cleared if it's ()? Not sure
						//Portrait gets cleared
						else
						{
							structuredLines.push([opcode.NOPORTRAIT])
						}
						cmds = sliceAndRemove(cmds,charTagStart,charTagEnd+1);
					}
					else
					{
						//console.log("Done... Let's exit");
						break;
					}
				}
				
				//Now do text
				text.split("+").forEach(msg => {
					structuredLines.push([opcode.MSG,msg])
				})
				//open/close msgbox
				structuredLines.push([opcode.MSGBOXTRANSITION])
			}
			
			//console.log(structuredLines)
			let s = "";
			structuredLines.forEach(line => {
				s+=line.toString()+"\r\n";
			})
			document.getElementById("DebugTextArea").value = s;
			
			
			let lastSpeakerName = "";
			
			//It has underscores because it's going to be cloned
			let _div_ = document.createElement('div');
			_div_.className="container";
			
			let _img_ = document.createElement("img");
			_img_.src="textbox.png";
			_img_.style.width="100%";
			_div_.appendChild(_img_);
			
			let charName = document.createElement("div");
			charName.className="charName";
			_div_.appendChild(charName);
			
			let text = document.createElement("div");
			text.className="absText";
			text.id="text";
			_div_.appendChild(text);
			
			//let textboxDiv = document.getElementById("Textboxes");
			let newTextboxDiv = document.createElement('div');
			newTextboxDiv.id="Textboxes";
			
			let NewSimpleTextDiv = document.createElement('div');
			NewSimpleTextDiv.id="verySimpleText";
			for(i=0;i<structuredLines.length;i++)
			{
				if (structuredLines[i][0] == opcode.SPEAKER)
				{
					lastSpeakerName=structuredLines[i][1];
				}
				else if (structuredLines[i][0] == opcode.MSG)
				{
					let newTextbox = _div_.cloneNode(true);
					//console.log(newTextbox);
					newTextbox.getElementsByClassName("absText")[0].innerText = structuredLines[i][1]
					newTextbox.getElementsByClassName("charName")[0].innerText = lastSpeakerName;
					newTextboxDiv.appendChild(newTextbox);
					
					let p = document.createElement('p');
					if (lastSpeakerName == "")
						p.innerText = structuredLines[i][1];
					else
						p.innerText = lastSpeakerName + ": "+structuredLines[i][1];
					NewSimpleTextDiv.appendChild(p);
				}
				/*else if (structuredLines[i][0] == opcode.MSGBOXTRANSITION)
				{
					let p = document.createElement('p');
					p.innerText = "(newTextbox)";
					simpleTextDiv.appendChild(p);
				}*/
			}
			//Now replace the old div...
			let textboxDiv = document.getElementById("Textboxes");
			textboxDiv.parentNode.replaceChild(newTextboxDiv,textboxDiv);
			
			let simpleTextDiv = document.getElementById("verySimpleText")
			simpleTextDiv.parentNode.replaceChild(NewSimpleTextDiv,simpleTextDiv);
			//Init phaser
			//jk I don't want it automatic anymore
		})
	}
	function initPhaser()
	{
		game = new Phaser.Game(config);
		let button = document.getElementById("startButton")
		button.disabled = true
		button.innerText = "started!"
		
	}
	/*function reset()
	{
		game.restart()
	}*/
	
	function showOpcodes() {
		let x = document.getElementById("myDIV");
		if (x.style.display === "none") {
			x.style.display = "block";
		} else {
			x.style.display = "none";
		}
	}
	
	function onChapterSelected(value)
	{
		console.log(value);
		let [chapter,episode] = value.split('-');
		run(listOfChapters[chapter]['episodes'][episode]['begin'])
		document.getElementById("startButton").disabled = false
	}
	
	function appendFromij(i,j,name,letter)
	{
		return {
			name:  name+' '+i+'-'+j,
			begin: i+'-'+j+'-1'+letter+'.txt',
			end:   i+'-'+j+'-2'+letter+'.txt',
		}
	}
	
	listOfChapters=[]
	function generateTables() {
		
		//Special for chapter 0
		{
			let chapterZero = []
			for(j=1;j<5;j++)
			{
				chapterZero.push(appendFromij(0,j,"Normal",''))
			}
			listOfChapters.push({name:"Chapter 0",episodes:chapterZero});
		}
		//Normal chapters
		for(i=1;i<13;i++)
		{
			let curChapter = []
			for(j=1;j<=6;j++)
			{
				curChapter.push(appendFromij(i,j,"Normal",''))
			}
			for(j=1;j<=4;j++)
			{
				curChapter.push(appendFromij(i,j,"Emergency",'E'))
			}
			for(j=1;j<=4;j++)
			{
				curChapter.push(appendFromij(i,j,"Midnight",'N'))
			}
			listOfChapters.push({name:'Chapter '+i,episodes:curChapter});
			
			//What am I supposed to do?
			/*if (i==5)
			{
				listOfChapters.push({
					name:"Operation Cube",
					episodes:[
						{name:"Seven Step Puzzle",begin:,mid:end:},
					]
				})
			}*/
		}
		
		var _table_ = document.createElement('table'),
			//_tbody_ = document.creat
			_tr_ = document.createElement('tr'),
			_th_ = document.createElement('th'),
			_td_ = document.createElement('td'),
			_select_ = document.createElement('select'),
			_option_ = document.createElement('option');
		
		var table = document.getElementById("table");
		let thead = document.createElement("thead");
		thead.innerHTML = "<tr><th colspan='"+listOfChapters.length+"'>Pick a chapter</th></tr>"
		table.appendChild(thead);
		
		//Behold, the most god awful code ever written
		let tbody = document.createElement('tbody');
		
		/*let trChapterNames = _tr_.cloneNode(false);
		for(i=0;i<listOfChapters.length;i++)
		{
			let td = _td_.cloneNode(false);
			td.appendChild(document.createTextNode(listOfChapters[i]['name']));
			trChapterNames.appendChild(td);
		}
		tbody.appendChild(trChapterNames);*/
		
		let trChapterDropdowns = _tr_.cloneNode(false);
		for(i=0;i<listOfChapters.length;i++)
		{
			let td = _td_.cloneNode(false);
			let select = _select_.cloneNode(false);
			select.setAttribute('id',"selectChapter"+i)
			select.setAttribute('onchange','onChapterSelected(value);');
			
			//Generate chapter name first..
			let optChName = _option_.cloneNode(false);
			optChName.setAttribute("selected","");
			optChName.setAttribute("disabled","");
			optChName.innerText=listOfChapters[i]['name'];
			select.appendChild(optChName);
			
			//Now let's do the episodes
			let curChapter = listOfChapters[i]['episodes'];
			for(j=0;j<curChapter.length;j++)
			{
				let option = _option_.cloneNode(false);
				option.value=i+'-'+j;
				option.innerText=curChapter[j]['name'];
				select.appendChild(option);
			}
			td.appendChild(select);
			trChapterDropdowns.appendChild(td);
		}
		tbody.appendChild(trChapterDropdowns);
		
		//table.appendChild(thead);
		table.appendChild(tbody);
		
		console.log(listOfChapters);
		return listOfChapters;
	}
</script>
<body onload="generateTables()">
	<h1>GFL Cutscene Intrepeter (very alpha)</h1>
	<div id="scrollableTable">
		<table id="table">
		</table>
	</div>
	<!--<h2><a href="#Textboxes">Mobile devices are stupid and the canvas absorbs touch, so click here to jump to the part without the canvas</a></h2>-->
	<!---->

        <button id="startButton" onclick="initPhaser()" disabled>Start interactive interpreter (It's like playing the game!)</button>
		<p id="curIndexDebug"></p>
		<div id="phaser"></div>
		<br><br><button onclick='showOpcodes()'>Show converted opcodes (For debugging)</button><br>
		<div id='myDIV' style="display: none;">
			<textarea rows='6' cols='50' id="DebugTextArea"></textarea>
		</div>
		<!--<canvas id="myCanvas" width="1280" height="720"></canvas>--><br><br>
        <!--<h1 id="title">This is a header!</h1>-->
		<!--<img src="textbox.png"></img>-->
		<h2><a href="#verySimpleText">Click HERE to jump to the text without any textboxes which is probably what you want anyways</a></h2>
		<h2>Static Textboxes</h2>
		<div id="Textboxes"></div>
		<h2>Very simple text</h2>
		<div id="verySimpleText"></div>
		<a href="#phaser">Back to top</a>
		
		<p>Dandelai is my wife, greets to /gfg/, <a href="https://github.com/RhythmLunatic">harass me on github</a></p>
		<br>
		<!--<a href="https://github.com/RhythmLunatic/Girls-Frontline-Discord-Search">Try out my Girls' Frontline discord bot. T-Doll info, quotes, costumes, and more!</a>-->
</body>
