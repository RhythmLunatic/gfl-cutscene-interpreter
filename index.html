<!doctype html>
<head>
	<meta charset="utf-8"/>
	<title>GFL cutscene interpreter</title>
	
	<!--For discord description -->
	<meta property="og:title" content="Girls' Frontline Cutscene Interpreter" />
	<meta property="og:type" content="website" />
	<meta property="og:url" content="http://gfl.amaryllisworks.pw" />
	<!--<meta property="og:image" content="http://my.site.com/images/thumb.png" />-->
	<meta property="og:description" content="Play back cutscenes in the browser" />
    <!--Let browser know website is optimized for mobile-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
	
	<!--Resources -->
	<link rel="preconnect" href="https://fonts.gstatic.com">
	 <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500&display=swap" rel="stylesheet">  
	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
	<!--<link type="text/css" rel="stylesheet" href="materialize.css"  media="screen,projection"/>-->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
</head>
<style type="text/css">
body
{
	/*background-color: black;
	color: white*/
	text-align:center;
}

/*button
{
	background-color: black;
	color:white;
}*/

table, th, td {
   border: 1px solid #222222;
   border-collapse: collapse;
}
th {
	background-color: purple;
}

/*#head, #foot {
	height: 6%;
	min-height: 25px;
	width: 100%;
	background-color: #151515;
	overflow: hidden;
}

#head a {
  float: left;
  color: #f2f2f2;
  text-align: center;
  padding: 14px 16px;
  text-decoration: none;
  font-size: 17px;
}


#head a:hover {
  background-color: #ddd;
  color: black;
}

#head a.active {
  background-color: #4CAF50;
  color: white;
}*/

.tabs {
    display:-webkit-flex;
    display: -ms-flexbox;
    display: flex
}

.tabs .tab a {
  color: rgba(38, 166, 154, 0.7);
  /*Custom Text Color*/
}

.tabs .tab a:hover {
  color:#26a69a;
  /*Custom Color On Hover*/
}
.tabs .tab a.active {
	color:#2196f3;
}

.tabs .tab a:focus.active {
  color:#26a69a;
  /*Custom Text Color While Active*/
  background-color: rgba(38, 166, 154, 0.2);
  /*Custom Background Color While Active*/
}

.tabs .indicator {
  background-color:#26a69a;
  /*Custom Color Of Indicator*/
}


.flex-container {
  display: flex;
  flex-wrap: wrap;
  background-color: DodgerBlue;
  justify-content: center;
  align-items: center;
}

.flex-container > div {
  background-color: #f1f1f1;
  margin: 5px;
  /*padding: 20px;
  font-size: 30px;*/
}

tr:nth-child(odd) {
    background-color: #000000CC;
}
tr:nth-child(even) {
    background-color: #111111CC;
}

#verySimpleText{
	text-align: left;
	width: 700px;
	margin: 0 auto;
	font-family: 'Noto Sans KR', sans-serif;
}

/*.container {
  position: relative;
  text-align: center;
  color: white;
}

.charName {
  font-family: 'Noto Sans KR', sans-serif;
  position: absolute;
  top: 5px;
  left: 16px;
  font-size: 2vw;
}

.absText {
      font-family: 'Noto Sans KR', sans-serif;
  position: absolute;
  top: 45px;
  left: 16px;
  font-size: 2.2vw;
}*/


/*.speakerName{
	font-weight: bold;
}*/

.storyText {
	margin-top: 0.5ex;
	margin-bottom: 0.5ex;
}

.storyText.speakerName {
	margin-top: 0;
	font-weight: bold;
}

/*
Blatantly stolen from gfl.zzzzz.kr 
I have no idea how it works
*/
.storyImg{
	position:relative;
	overflow:hidden; /*Keep portraits within div */
	width:700px;
	padding-top:1rem;
}
.storydoll{
	width:500px; /*Why is width 500px? */
	position: absolute;
	bottom: -30%;
}
.storydoll.one{
	left:15%; /*???*/
}
.storydoll.saying{
	filter: brightness(100%);
	z-index: 100;
}

</style>
<script type="text/javascript"></script>
<!-- tfw no bandwidth -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
<!--<script type="text/javascript" src="materialize.js"></script>-->
<!--<script src="phaser.min.js"></script>-->
<script src="https://cdn.jsdelivr.net/npm/phaser@3.24.1/dist/phaser.min.js"></script>
<script>
	/*
	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU Affero General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU Affero General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.

	This program is written by Rhythm Lunatic.
	*/
	
	/*
		Just gonna say it right now, I don't know an ounce of JavaScript or phaser.
		I interpreted lua and my game engine knowledge until this worked.
		
		So that's the answer as to why the chapter select looks like dogshit. Make a PR if you want it to be fixed.
	*/

	/* opcode dictionary
		Seriously who designed this, can't you use normal fucking opcodes?
		XXX() - Set portrait. XXX is character sprite. Can have multiple of these. Actually does not need to be the first OPCODES
		; - Unknown purpose. Could be used for switching highlights? Seems to separate two portrait opcodes.
		<BGM> - Set BGM
		<BIN> - Set background
		<Speaker> - Set the speaker name
		|| - Separator. Things after this separator will be run later, maybe? Usually transition commands, shake effects, etc are after these
		<黑点X> - Black dot screen transition. X=1 for in, 2 for out.
		<黑屏X> - Black screen fade in and out
		<通讯框> - "Communication box". Display character portrait inside a communication box.
		<震屏> - Screen shake effect
		: - End of opcodes, text goes here (Other than +)
		+ - End text. Text will continue in a new box (no close/open animation) when clicked.
		
	*/
	//I kept accidentally typing print ok
	window.print = function(param)
	{
		console.log(param);
	}
	
	const OPCODES = {
		BGM : 1,
		BG : 2,
		SPEAKER : 3,
		MSG : 4,
		PORTRAIT : 5,
		NOPORTRAIT : 6,
		MSGBOXTRANSITION : 7,
		SETMASKEDPORTRAIT : 8
	}
	
	//For JSON structured or making your own
	//Pro tip: use opcode2string.indexOf(s) to get the opcode number
	const opcode2string = [
		'none',
		'bgm',
		'bg',
		'speaker',
		'msg',
		'portrait',
		'noPortrait',
		'msgboxTransition',
		'setMaskedPortrait'
	]
	
	const tag2opcode = {
		"Speaker":OPCODES.SPEAKER,
		"BIN":OPCODES.BG,
		"BGM":OPCODES.BGM,
		"通讯框":OPCODES.SETMASKEDPORTRAIT,
	}
	
	const backgrounds = {
		2: "机场",
		4: "主界面背景",
		6: "冰湖",
		8: "作战室avg",
		9: "black",
		10: "PlaybackBG1",
		15: "室内战斗",
	}
	
	const PORTRAITS = {
		"NPC-Kalin":[
			"special/版娘",
			"special/版娘-1",
			"special/版娘-2",
			"special/版娘-3",
			"special/版娘-4",
			"special/版娘-5",
			"special/版娘-6",
			"special/版娘-7",
			"special/版娘-8"
		]
	}
	
	//For CSS
	var int2str = ['zero','one',  'two',   'three','four',  'five', 'six',  'seven',  'eight', 'nine']
	var int2strPos = ['N','first','second','third','fourth','fifth','sixth','seventh','eighth','ninth']
	
	//I moved everything to gfl subdomain so it's fine now
	//const portraitWebserver = "http://gfl.amaryllisworks.pw/pic/"
	
	function portraitStructToString(p)
	{
		return "idx: "+p[1]+" | name: "+p[2]+" | type: "+p[3]
	}
	
	//Don't care if it's all over the place. Fix it yourself. If this was SM I'd be using broadcasts anyways
	var nameActor;
	var bgActor;
	
	function loadBG(runtime, num)
	{
		console.log("Loading "+num+" | "+backgrounds[num])
		runtime.load.once('complete',function() { bgActor.setTexture(num);bgActor.displayWidth = 1280;bgActor.displayHeight= 720; },runtime)
		runtime.load.image(num,'avgtexture/'+backgrounds[num]+'.png');
		runtime.load.start();
	}
	
	//A pool of portraits since there's gonna be more than one
	var portraitCollection = []
	function loadPortrait(runtime,idx,name,type)
	{
		if (PORTRAITS[name] != undefined && PORTRAITS[name][type] != undefined)
		{
			let keyedPortrait=name+'-'+type;
			let fileName = PORTRAITS[name][type]+'.png'
			console.log("Loading "+fileName);
			if (idx > portraitCollection.length-1)
			{
				runtime.load.once('complete',function() { portraitCollection.push( runtime.add.image(game.config.width/2,game.config.height-100,keyedPortrait) ) } );
			
			}
			else
			{
				runtime.load.once('complete',function() { portraitCollection[idx].setTexture(keyedPortrait) } );
			}
			runtime.load.image(keyedPortrait,'pic/'+fileName);
			runtime.load.start();
		}
	}
	
	//var interval;
	//Yes, I did translate it from lua. Lmao.
	class VNText4 {
		constructor(phaserRuntime,font,maxwidth,spd,msgTable)
		{
			this.phaserRuntime = phaserRuntime; //lol
			this.cur_len = 0;
			this.spd = spd;
			this.curIndex = 0;
			this.msgTable = msgTable;
			
			this.textActor = phaserRuntime.add.text(0,0,'Static Text Object', { fontFamily: 'Noto Sans KR', fontSize: 27, color: '#ffffff', wordWrap: {width:maxwidth,useAdvancedWrap:true} });
		}
		is_finished()
		{
			return this.cur_len == this.text.length;
		}
		
		//In StepMania you can just chain a command (within an actor) with sleep over and over, but in phaser you have to attach it to the game engine?
		//Attaching tweens to the game engine instead of actors is kind of a weird decision by the way, why wouldn't you attach them to the actor?
		//I'm using setInterval anyways
		play()
		{
			
			let f = function(self){
				self.cur_len = self.textActor.text.length;
				//console.log(self.cur_len+"/"+self.text.length);
				if (self.cur_len < self.text.length)
				{
					let txt = self.text.slice(0,self.cur_len+1)
					//console.log(txt);
					self.textActor.setText(txt);
				}
				else
				{
					clearInterval(f);
				}
			}
			
			f(this);
			
			//console.log(1/this.spd*1000);
			let interval = setInterval(f,1/this.spd*1000,this);
			//This can't possibly be high performance...
			
			/*phaserRuntime.tweens.add({
				targets:this.textActor,
				ease:'Linear',
				duration:1/this.spd,
				onComplete:this.play
			)}*/
				
			
		}
		Text()
		{
			this.cur_len = this.textActor.text;
			if (this.cur_len < this.text.length)
				this.textActor.setText(this.text.slice(0,this.cur_len));
		}
		advance()
		{
			if (this.no_more_text())
				return;
			//this.curIndex++;
			var noMsgYet = true;
			while (noMsgYet)
			{
				console.assert(this.msgTable[this.curIndex],"There is no opcode located at "+this.curIndex+". How did you even get this far?")
				let curMsg = this.msgTable[this.curIndex]
				let MsgOpcode = curMsg[0]
				//console.log(opcode)
				//console.log(this.curIndex);
				//console.log(MsgOpcode == OPCODES.MSG);
				switch(MsgOpcode) {
					case OPCODES.MSG:
						this.cur_len= 0
						this.text = curMsg[1]
						//this.text_actor:queuecommand("Check")
						noMsgYet = false;
						break;
					case OPCODES.SPEAKER:
						nameActor.setText(curMsg[1]);
						break;
					case OPCODES.BG:
						loadBG(this.phaserRuntime,curMsg[1]);
						break;
					case OPCODES.PORTRAIT:
						console.log(portraitStructToString(curMsg))
						loadPortrait(this.phaserRuntime,curMsg[1],curMsg[2],curMsg[3])
						break;
					//lua junk from my message system. Just ignore it.
					/*case OPCODESFMSG:
						this.cur_len= 0
						this.text = this.msgTable[this.curIndex][2]()
						//this.text_actor:queuecommand("Check")
						break outLoop;
					elseif opcode == "func" then
						this.msgTable[this.curIndex][2]()
					elseif opcode == "choice" then
						ChoiceTable = {Result=1,Finished=false}
						assert(this.msgTable[this.curIndex][2],"Choice table is invalid.")
						ChoiceTable.Choices = this.msgTable[this.curIndex][2]
						assert(ChoiceTable.Choices)
					elseif opcode == "exit" then
						return false;
					elseif opcode == "condJumpSS" then
						Trace(table_print(this.selfSwitches))
						Trace(table_print(this.msgTable[this.curIndex]))
						if this.selfSwitches[this.msgTable[this.curIndex][2]] == true then
							//Subtract 1 to account for advance advancing one step, since we want to start on whatever it jumps to
							this.curIndex = this.msgTable[this.curIndex][3]-1
							Trace("Jumped to index "..this.curIndex)
						end
					elseif opcode == "condJump" then
						if this.msgTable[this.curIndex][2]() == true then
							//Subtract 1 to account for advance advancing one step, since we want to start on whatever it jumps to
							this.curIndex = this.msgTable[this.curIndex][3]-1
							Trace("Jumped to index "..this.curIndex)
						end
					elseif opcode == "selfSwitch" then
						this.selfSwitches[this.msgTable[this.curIndex][2]] = this.msgTable[this.curIndex][3]
					end;*/
				}
				this.curIndex++;
				//console.log(noMsgYet);
			}
			//Trace(this.text)
			//lua.Flush();
			//this.text_actor:settext(""):playcommand("Check");
			//console.log(this.text)
			document.getElementById('curIndexDebug').innerText="idx: "+(this.curIndex-1)+" | msg: "+this.msgTable[(this.curIndex-1)].toString()
			this.textActor.setText('');
			this.play();
		}
		no_more_text()
		{
			return this.curIndex >= this.msgTable.length-1;
		}
		skip()
		{
			this.textActor.setText(this.text);
			this.cur_len = this.text.length;
		}
	}
	
	/*class SpriteActor() {
		constructor()
		{
			//this.
		}
	}*/
	
	function sliceAndRemove(str, begin, end)
	{
		return str.slice(0,begin)+str.slice(end)
	}
	
	function getFromTag(str,tag)
	{
		const beginTag = "<"+tag+">"
		const endTag = "</"+tag+">"
		var n = str.indexOf(beginTag)
		if (n != -1){
			return str.slice(n+beginTag.length, str.indexOf(endTag))
		}
		return null
	}
	function removeTag(str,tag)
	{
		const beginTag = "<"+tag+">"
		const endTag = "</"+tag+">"
		return sliceAndRemove(str,str.indexOf(beginTag),str.indexOf(endTag)+endTag.length)
	}
	
	
	
	let curEpisodePart = 0
	class GirlsFrontlineScene extends Phaser.Scene {
		constructor()
		{
			//I don't know what this does but the tutorial had it
			super('GirlsFrontlineScene');
		}
		
		 preload()
		{
			//this.load.image('test','test.png');
			this.load.image('textbox','textbox.png');
		}
		
		create()
		{
			//input.touch only works on mobile devices. So it will break on desktop. reeeee
			//game.input.touch.capture = false;
			
			//GFL, in all of it's genius, uses 1024x1024 images. With black borders.
			/*bgActor = this.make.image({ x:game.config.width/2, y:game.config.height/2, add:true });
			bgActor.displayWidth = 1024
			bgActor.displayHeight= 1024*/
			bgActor = this.add.image(game.config.width/2,game.config.height/2);
			bgActor.texture = Phaser.Cache.DEFAULT;
			bgActor.setDepth(0);
			
			/*var img = this.make.image({ x:game.config.width/2, y:game.config.height/2, key:'test',add:true })
			img.displayWidth = game.config.width
			img.displayHeight= game.config.height
			img.setDepth(1);*/
			
			//Depth 2 is reserved for character portraits!
			
			imageActor = this.make.image({
				x:game.config.width /2,
				y:game.config.height-125,
				//scale:1,
				key:'textbox',
				add:true
			})
			imageActor.scaleY = 1
			imageActor.setDepth(3);
			
			//var blocks = this.add.group({ key: 'block', repeat: 139, setScale: { x: 0, y: 0 } });
			
			nameActor = this.add.text(240,500,'', { fontFamily: 'Noto Sans KR', fontSize: 30, color: '#ffffff' });
			nameActor.setDepth(4);
			
			//TODO
			document.getElementById("DebugTextArea").value = structuredLinesToString(currentEpisodeAsOpcodes[curEpisodePart]);
			
			vntext = new VNText4(this,'',800,13,currentEpisodeAsOpcodes[curEpisodePart]);
			vntext.textActor.x = 242;
			vntext.textActor.y = game.config.height-160
			vntext.textActor.setDepth(4);
			vntext.advance();
			
			this.input.on('pointerdown',function(){
				if (vntext.no_more_text())
				{
					console.log("Already hit the end!!!!");
					//'this' isn't passed in... No idea what I'm gonna do
					//If you spam click it will crash because you're removing and trying to add multiple scenes at the same time
					//this.input.onInputDown.removeAll();
					if (curEpisodePart < currentEpisodeAsOpcodes.length)
					{
						curEpisodePart++;
						game.scene.remove('GirlsFrontlineScene');
						game.scene.add('GirlsFrontlineScene',GirlsFrontlineScene,true);
					}
					else
					{
						//Oh no
						goToNextEpisode()
					}
					
				}
				else
				{
					if (vntext.is_finished())
					{
						vntext.advance();
					}
					else
					{
						vntext.skip();
					}
				}
			},vntext)
			//Hey look it's just like StepMania
			/*this.make.text({
				x: 100,
				y: 100,
				text: 'Phaser III',
				style: {
					fontSize: '48px',
					fontFamily: 'Arial',
					color: '#ffffff',
					metrics: {
						ascent: 45,
						descent: 10,
						fontSize: 55
					}
				}
			})*/
		}
		
		//I'm not even using this lmao
		 update()
		{
			
		}
	}
	
	let config = {
		type: Phaser.WEBGL,
		width: 1280,
		height: 720,
		parent: 'phaser',
		/*scene: {
			preload: preload,
			create: create,
		}*/
		scene: [GirlsFrontlineScene]
	};
	
	//phaser
	var game;
	
	var imageActor;
	var vntext;
	

	
	function convertGFLTextToOpcodes(out)
	{
		//console.log(out);
		var lines = out.split(/\r?\n/);
		//The GFL text system is stupid as fuck and I just spent a whole week writing my own VN system
		//So obviously I'm going to convert it to my own. fuck you
		//console.log(lines)
		//Fuck your opcodes
		let structuredLines = [];
		for(i=0;i<lines.length;i++)
		{
			if (!lines[i])
				continue;
			//print(lines[i]);
			let [cmds,text] = lines[i].replace("：",':').split(':')
			console.assert(cmds,lines[i])
			//console.assert(text,lines[i])
			
			//Yeah I know tags are supposed to be in order, No I don't really care sorry
			const tags = ["Speaker","BGM","BIN"]
			tags.forEach(tag => {
				//console.log(tag);
				let tagRes = getFromTag(cmds,tag);
				//console.log(tagRes)
				if (tagRes != null)
				{
					structuredLines.push([tag2opcode[tag],tagRes])
					removeTag(cmds,tag)
				}
			})
			//const tags = [
			if (cmds.includes("<通讯框>"))
			{
				structuredLines.push([OPCODES.SETMASKEDPORTRAIT])
				cmds.replace("<通讯框>","");
			}
			
			
			//So portraits are set in any order... But how the fuck are you supposed to tell when a name is if there's <> tags
			//I'm just going to search portraits after removing <> tags, it probably won't matter
			let numPortraits = 0;
			//Limit it to 5 because I don't want a dumb infinite loop that crashes the browser
			for(j=0;j<5;j++)
			{
				//console.log(cmds)
				let charTagEnd = cmds.indexOf(")");
				if (charTagEnd != -1)
				{
					let charTagStart = Math.max(cmds.lastIndexOf(";",charTagEnd),0)
					let [charID,charSpr] = cmds.slice(charTagStart,charTagEnd).split("(")
					//console.log(charID)
					//console.log(charSpr)
					//Ignore empty sprite IDs, they do nothing.
					if (charSpr != "")
					{
						structuredLines.push([OPCODES.PORTRAIT,numPortraits,charID,charSpr])
						numPortraits++;
					}
					//I think speaker name gets cleared if it's ()? Not sure
					//Portrait gets cleared
					else
					{
						structuredLines.push([OPCODES.NOPORTRAIT])
						structuredLines.push([OPCODES.SPEAKER,""])
						//numPortraits=0;
					}
					cmds = sliceAndRemove(cmds,charTagStart,charTagEnd+1);
				}
				else
				{
					//console.log("Done... Let's exit");
					break;
				}
			}
			
			//Now do text... But first check if there is any text (some lines are only commands)
			if (text)
			{
				text.split("+").forEach(msg => {
					structuredLines.push([OPCODES.MSG,msg])
				})
			}
			//open/close msgbox
			structuredLines.push([OPCODES.MSGBOXTRANSITION])
		}
		return structuredLines;
	}
	
	var curEpKey;
	var currentEpisodeAsOpcodes;
	
	//WHY DOES IT HAVE TO BE A SEPARATE FUNCTION
	/*async function fetchTextFile(fileName)
	{
		console.log("fetching "+fileName);
		const response = await fetch("avgtxt/"+fileName);
		console.log("got "+fileName);
		return await response.text();
		//const out = await response.text();
		//return out;
	}*/
	
	function structuredLinesToString(structuredLines)
	{
		let s = "";
		structuredLines.forEach(line => {
			s+=opcode2string[line[0]]+';'
			/*for(var i=1;i<line.length;i++)
				s+=line[i]*/
			s+=line.slice(1).join([separator = ';'])
			s+='\r\n'
			//s+=line.toString()+"\r\n";
		})
		return s;
	}
	function stringToStructuredLines(s)
	{
		var lines = s.split(/\r?\n/);
		let structuredLines = [];
		for(i=0;i<lines.length;i++)
		{
			let newMsg = lines[i].split(';')
			newMsg[0] = opcode2string.indexOf(newMsg[0])
			structuredLines.push(newMsg)
		}
		return structuredLines;
	}
	
	async function run(episode,curEpKey_)
	{
		currentEpisodeAsOpcodes = [];
		curEpisodePart = 0;
		curEpKey = curEpKey_;
		
		document.getElementById('chapterName').innerText = episode['name'];
		
		//Instead of just one part, put all of them in the verySimpleText div.
		let NewSimpleTextDiv = document.createElement('div');
		NewSimpleTextDiv.id="verySimpleText";
		
		//let partNum = 0;
		for(var p = 0; p < episode.parts.length;p++)
		{
			let fileName = episode.parts[p];
			
			//We have to await so it doesn't load the parts in the wrong order. Which is an actual thing that has happened.
			console.log("fetching "+fileName);
			const response = await fetch("avgtxt/"+fileName);
			const out = await response.text();
			console.log("got "+fileName);
			
			//console.log(fetchTextFile("avgtxt/"+fileName));
			
			//fetch("avgtxt/"+fileName)
			//.then(response => response.text())
			//.then((out) => {
			//fetchTextFile(fileName).then(out => {
				//console.log('got '+fileName);
				let structuredLines = convertGFLTextToOpcodes(out);
				
				//console.log(structuredLines)

				//document.getElementById("DebugTextArea").value = structuredLinesToString(s)
				
				
				
				//It has underscores because it's going to be cloned
				/*let _div_ = document.createElement('div');
				_div_.className="container";
				
				let _img_ = document.createElement("img");
				_img_.src="textbox.png";
				_img_.style.width="100%";
				_div_.appendChild(_img_);
				
				let charName = document.createElement("div");
				charName.className="charName";
				_div_.appendChild(charName);
				
				let text = document.createElement("div");
				text.className="absText";
				text.id="text";
				_div_.appendChild(text);
				
				//let textboxDiv = document.getElementById("Textboxes");
				let newTextboxDiv = document.createElement('div');
				newTextboxDiv.id="Textboxes";*/
				
				let thisPartDiv = document.createElement('div');
				let h3 = document.createElement('h3');
				//console.log(partNum);
				h3.innerText="Part "+(p+1);
				//partNum++;
				thisPartDiv.appendChild(h3);
				
				let lastSpeakerName = "";
				let lastBGUsed = ""; //'avgtexture/'+backgrounds[num]+'.png'
				let didBGOrPortraitOrNameChange = false;
				let shownPortraits = []
				
				let fancyDisplayType = true;
				
				for(var i=0;i<structuredLines.length;i++)
				{
					let opcode = structuredLines[i][0]
					console.log(structuredLines[i]);
					switch (opcode)
					{
						case OPCODES.SPEAKER:
							lastSpeakerName=structuredLines[i][1];
							didBGOrPortraitOrNameChange = true
							break;
						case OPCODES.PORTRAIT:
							console.log(portraitStructToString(structuredLines[i]))
							let idx = structuredLines[i][1]
							let name = structuredLines[i][2]
							let type = structuredLines[i][3]
							if (PORTRAITS[name] && PORTRAITS[name][type])
							{
								//console.log(shownPortraits.length);
								if (structuredLines[i][1] > shownPortraits.length-1)
								{
									console.log("Pushed new portrait with idx "+idx);
									shownPortraits.push('pic/'+PORTRAITS[name][type]+'.png');
									didBGOrPortraitOrNameChange = true;
								}
								else
								{
									let newPortrait = 'pic/'+PORTRAITS[name][type]+'.png';
									if (newPortrait == shownPortraits[idx])
										console.log("New portrait set is identical to old one, ignoring change. (TODO: This should be left to the opcode interpreter to filter out!)");
									else
									{
										console.log("Portrait replaced "+shownPortraits[idx] +" -> "+newPortrait)
										shownPortraits[idx]=newPortrait;
										didBGOrPortraitOrNameChange = true;
									}
								}
							}
							break;
						case OPCODES.NOPORTRAIT:
							shownPortraits = [];
							didBGOrPortraitOrNameChange = true;
							break;
						case OPCODES.BG:
							let newBG = 'avgtexture/'+backgrounds[structuredLines[i][1]]+'.png'
							if (newBG == lastBGUsed)
							{
								console.log("New BG set is identical to old one, ignoring change. (TODO: This should be left to the opcode interpreter to filter out!)");
							}
							else
							{
								console.log(lastBGUsed + " -> "+newBG)
								lastBGUsed = newBG
								didBGOrPortraitOrNameChange = true;
							}
							break;
						case OPCODES.MSG:
							//Spawn new BG with speaker and portrait here.
							if (true)
							{
								//console.log("aaa");
								if (didBGOrPortraitOrNameChange)
								{
									let storyBox = document.createElement('div');
									storyBox.classList.add('storyImg');
									let bgImage = document.createElement('img');
									bgImage.style = "width:100%;position:relative;z-index:";
									bgImage.src = lastBGUsed;
									storyBox.appendChild(bgImage);
									for(var j=0;j<shownPortraits.length;j++)
									{
										console.assert(shownPortraits[j]);
										let portraitImg = document.createElement('img');
										portraitImg.src = shownPortraits[j];
										portraitImg.classList.add("storydoll");
										portraitImg.classList.add(int2strPos[j+1]);
										portraitImg.classList.add(int2str[shownPortraits.length]);
										storyBox.appendChild(portraitImg);
									}
									thisPartDiv.appendChild(storyBox);
									
									if (lastSpeakerName != "")
									{
										let p = document.createElement('p');
										p.innerHTML = lastSpeakerName;
										//p.innerHTML = "<b>"+lastSpeakerName+"</b>";
										p.classList.add("storyText");
										p.classList.add("speakerName");
										thisPartDiv.appendChild(p);
									}
									
									didBGOrPortraitOrNameChange = false;
								}
								let p = document.createElement('p');
								p.classList.add('storyText')
								p.innerText = structuredLines[i][1];
								thisPartDiv.appendChild(p);
							}
							else
							{
								let p = document.createElement('p');
								if (lastSpeakerName == "")
									p.innerText = structuredLines[i][1];
								else
									p.innerText = lastSpeakerName + ": "+structuredLines[i][1];
								thisPartDiv.appendChild(p);
							}
							break;
						default:
							//console.log("unknown OPCODES..");
					}
				}
				NewSimpleTextDiv.appendChild(thisPartDiv);
				//Now replace the old div...
				/*let textboxDiv = document.getElementById("Textboxes");
				textboxDiv.parentNode.replaceChild(newTextboxDiv,textboxDiv);*/
				
				currentEpisodeAsOpcodes.push(structuredLines);
				
				//If phaser is already init, go ahead and set the new scene
				//...By destroying the old one and recreating it.
				if (game != undefined)
				{
					game.scene.remove('GirlsFrontlineScene');
					game.scene.add('GirlsFrontlineScene',GirlsFrontlineScene,true);
				}
				
			//})
		//})
		}
		let simpleTextDiv = document.getElementById("verySimpleText")
		simpleTextDiv.parentNode.replaceChild(NewSimpleTextDiv,simpleTextDiv);
	}
	
	function reRunWithNewOpcodes()
	{
		let lines = document.getElementById("DebugTextArea").value;
		//console.log(lines);
		let newStructuredLines = stringToStructuredLines(lines);
		console.log(newStructuredLines)
		currentEpisodeAsOpcodes[curEpisodePart] = newStructuredLines;
		if (game != undefined)
		{
			game.scene.remove('GirlsFrontlineScene');
			game.scene.add('GirlsFrontlineScene',GirlsFrontlineScene,true);
		}
	}
	
	function initPhaser()
	{
		game = new Phaser.Game(config);
		let button = document.getElementById("startButton")
		button.classList.add("disabled");
		button.innerText = "started!"
		
	}
	/*function reset()
	{
		game.restart()
	}*/
	
	function showOpcodes() {
		let x = document.getElementById("myDIV");
		if (x.style.display === "none") {
			x.style.display = "block";
		} else {
			x.style.display = "none";
		}
	}
	
	
	function getRoutableKeyString(type,chapter,episode)
	{
		return type+'-'+chapter+'-'+episode
	}
	function getKeysFromRoutableString(s)
	{
		return s.split('-');
	}
	
	function onChapterSelected(value)
	{
		console.log(value);
		let [type,chapter,episode] = getKeysFromRoutableString(value)
		run(listOfChapters[type][chapter]['episodes'][episode],value)
		if (game == undefined)
			document.getElementById("startButton").classList.remove('disabled');
	}
	function goToNextEpisode()
	{
		let value = curEpKey;
		console.log(value);
		let [type,chapter,episode] = getKeysFromRoutableString(value)
		episode++;
		if (listOfChapters[type][chapter]['episodes'][episode])
		{
			run(listOfChapters[type][chapter]['episodes'][episode],getRoutableKeyString(type,chapter,episode))
			return true;
		}
		else
		{
			chapter++;
			episode = 0;
		}
		
		if (listOfChapters[type][chapter]['episodes'][episode])
		{
			run(listOfChapters[type][chapter]['episodes'][episode],getRoutableKeyString(type,chapter,episode))
			return true;
		}
		
		return false;
	}
	
	function appendFromij(i,j,name,letter)
	{
		return {
			name:  name+' '+i+'-'+j,
			parts: [i+'-'+j+'-1'+letter+'.txt',
					i+'-'+j+'-2'+letter+'.txt'],
		}
	}
	
	//name field is structured like type-chapter-episode
	listOfChapters={
		'main':[],
		'event':[],
		'side':[], //also skin
		'crossover':[]
	}
	function generateTables() {
		
		//Special for chapter 0
		{
			let chapterZero = []
			for(j=1;j<5;j++)
			{
				chapterZero.push(appendFromij(0,j,"Normal",''))
			}
			listOfChapters['main'].push({name:"Chapter 0",episodes:chapterZero});
		}
		//Normal chapters
		for(i=1;i<13;i++)
		{
			let curChapter = []
			for(j=1;j<=6;j++)
			{
				curChapter.push(appendFromij(i,j,"Normal",''))
			}
			for(j=1;j<=4;j++)
			{
				curChapter.push(appendFromij(i,j,"Emergency",'E'))
			}
			for(j=1;j<=4;j++)
			{
				curChapter.push(appendFromij(i,j,"Midnight",'N'))
			}
			listOfChapters['main'].push({name:'Chapter '+i,episodes:curChapter});
			
			//What am I supposed to do?
			/*if (i==5)
			{
				listOfChapters.push({
					name:"Operation Cube",
					episodes:[
						{name:"Seven Step Puzzle",begin:,mid:end:},
					]
				})
			}*/
		}
		
		//Events
		let prologue = []
		for(i=0;i<12;i++)
		{
			prologue.push({name:"Start"+i,parts:['startavg/Start'+i+".txt"]});
		}
		listOfChapters['event'].push({name:"Prologue",episodes:prologue});
		/*
		0|Chapter|EP.|00
		1|Chapter|EP.|01
		2|Chapter|EP.|02
		3|Chapter|EP.|03
		4|Chapter|EP.|04
		5|Chapter|EP.|05
		-1|Operation Cube|EP.|5.5
		6|Chapter|EP.|06
		7|Chapter|EP.|07
		-2,-3,-4,-5|Arctic Warfare|EP.|7.5
		-7|Operation Cube+|EP.|7.75
		8|Chapter|EP.|08
		-10,-11,-12,-13|Deep Dive|EP.|8.5
		9|Chapter|EP.|09
		10|Chapter|EP.|10
		-16,-17,-18|Singularity|EP.|10.5
		-24,-25,-26,-28|Continuum Turbulence|EP.|10.75
		11|Chapter|EP.|11
		*/
		
		let tDollEpisodes = []
		let knownFiles = ["1.txt", "11.txt", "1501.txt", "1502.txt", "1503.txt",
		"1504.txt", "1505.txt", "1506.txt", "1507.txt", "1801.txt", "1802.txt",
		"1803.txt", "1804.txt", "1805.txt", "1806.txt", "1807.txt", "1808.txt",
		"1901.txt", "1902.txt", "1904.txt", "1905.txt", "1906.txt", "2.txt",
		"2101.txt", "2102.txt", "2103.txt", "2104.txt", "2105.txt", "2106.txt",
		"2107.txt", "2108.txt", "2109.txt", "2301.txt", "2302.txt", "2303.txt",
		"2304.txt", "2305.txt", "2401.txt", "2403.txt", "2404.txt", "2405.txt",
		"2406.txt", "2407.txt", "2408.txt", "2409.txt", "2410.txt", "2601.txt",
		"2602.txt", "2603.txt", "2604.txt", "2605.txt", "2606.txt", "2801.txt",
		"2802.txt", "2803.txt", "2804.txt", "2805.txt", "2807.txt", "3.txt",
		"3001.txt", "3002.txt", "3003.txt", "3004.txt", "3005.txt", "3006.txt", 
		"3007.txt", "301.txt", "302.txt", "303.txt", "304.txt", "305.txt", 
		"306.txt", "307.txt", "308.txt", "309.txt", "310.txt", "3102.txt", 
		"3103.txt", "3105.txt", "3106.txt", "3107.txt", "3301.txt", "3302.txt", 
		"3303.txt", "3304.txt", "3305.txt", "3306.txt", "3307.txt", "3308.txt", 
		"3309.txt", "3501.txt", "3502.txt", "3503.txt", "3504.txt", "3505.txt", 
		"1903.txt", "2402.txt", "2806.txt", "3101.txt", "3506.txt", "4203.txt", 
		"3507.txt", "3801.txt", "3802.txt", "3803.txt", "3805.txt", "3806.txt", 
		"3807.txt", "3808.txt", "3809.txt", "4.txt", "4001.txt", "4002.txt", 
		"4003.txt", "4004.txt", "4005.txt", "4006.txt", "4007.txt", "4201.txt",
		 "4202.txt", "4204.txt", "4205.txt", "4206.txt", "4207.txt", "4209.txt", 
		 "4210.txt", "4301.txt", "4302.txt", "4303.txt", "4304.txt", "4305.txt",
		  "4306.txt", "4308.txt", "4309.txt", "4310.txt", "5.txt", "6.txt", "7.txt",
		   "8.txt", "801.txt", "802.txt", "803.txt", "804.txt", "805.txt", "806.txt", 
		   "807.txt", "808.txt", "9.txt"]
		for (i=0;i<knownFiles.length;i++)
			tDollEpisodes.push({name:knownFiles[i],parts:['skin/'+knownFiles[i]]});
		listOfChapters['side'].push({name:"Skin Stories",episodes:tDollEpisodes});
		
		
		/*var _table_ = document.createElement('table'),
			_tr_ = document.createElement('tr'),
			_th_ = document.createElement('th'),
			_td_ = document.createElement('td'),
			_select_ = document.createElement('select'),
			_option_ = document.createElement('option');*/
		
		//var table = document.getElementById("table");
		//let thead = document.createElement("thead");
		//thead.innerHTML = "<tr><th colspan='"+listOfChapters.length+"'>Pick a chapter</th></tr>"
		//table.appendChild(thead);
		
		//Behold, the most god awful code ever written
		//let tbody = document.createElement('tbody');
		
		/*let trChapterNames = _tr_.cloneNode(false);
		for(i=0;i<listOfChapters.length;i++)
		{
			let td = _td_.cloneNode(false);
			td.appendChild(document.createTextNode(listOfChapters[i]['name']));
			trChapterNames.appendChild(td);
		}
		tbody.appendChild(trChapterNames);*/
		
		var _dropDownTrigger_ = document.createElement('a');
		_dropDownTrigger_.href = "#";
		_dropDownTrigger_.classList.add('dropdown-trigger');
		_dropDownTrigger_.classList.add('btn');
		
		var _dropDown_ = document.createElement('ul');
		_dropDown_.classList.add('dropdown-content');
		
		var _li_ = document.createElement('li'),
			_a_ = document.createElement('a');
		
		//No idea what this is supposed to do.
		_a_.href="#!";
		
		for (const key in listOfChapters)
		{
			let episodeContainer = document.getElementById(key+'Episodes')
			//let trChapterDropdowns = _tr_.cloneNode(false);
			//let trChapterDropdowns = 
			for(i=0;i<listOfChapters[key].length;i++)
			{
				//let td = _td_.cloneNode(false);
				let flexBoxDiv = document.createElement('div');
				/*let select = _select_.cloneNode(false);
				select.setAttribute('id',"selectChapter"+i)
				select.setAttribute('onchange','onChapterSelected(value);');*/
				let dropDownTrigger = _dropDownTrigger_.cloneNode(true)
				dropDownTrigger.setAttribute('data-target','dropdown-'+key+'-'+i)
				dropDownTrigger.innerText=listOfChapters[key][i]['name']
				
				let dropdown = _dropDown_.cloneNode(true);
				dropdown.id = 'dropdown-'+key+'-'+i;
				
				//Generate chapter name first..
				/*let optChName = _option_.cloneNode(false);
				optChName.setAttribute("selected","");
				optChName.setAttribute("disabled","");
				optChName.innerText=listOfChapters[key][i]['name'];
				select.appendChild(optChName);*/
				
				//Now let's do the episodes
				let curChapter = listOfChapters[key][i]['episodes'];
				for(j=0;j<curChapter.length;j++)
				{
					
					let ep = _li_.cloneNode(true);
					ep.innerHTML = "<a href='#!' onclick=\"onChapterSelected('"+getRoutableKeyString(key,i,j)+"')\">"+curChapter[j]['name']+"</a>"
					dropdown.appendChild(ep);
					/*let option = _option_.cloneNode(false);
					option.value=getRoutableKeyString(key,i,j)
					option.innerText=curChapter[j]['name'];
					select.appendChild(option);*/
				}
				//flexBoxDiv.appendChild(select);
				flexBoxDiv.appendChild(dropDownTrigger);
				flexBoxDiv.appendChild(dropdown);
				
				episodeContainer.appendChild(flexBoxDiv);
				//td.appendChild(select);
				//trChapterDropdowns.appendChild(td);
			}
		}

		//tbody.appendChild(trChapterDropdowns);
		
		//table.appendChild(thead);
		//table.appendChild(tbody);
		
		console.log(listOfChapters);
		return listOfChapters;
	}
	
	//materialize.js makes it irrelevant
	/*function showSelectedEpisodes(id)
	{
		let episodesDivs = document.getElementById("Episodes").children;
		for (var i = 0; i < episodesDivs.length;i++){
			if (episodesDivs[i].id == id)
				episodesDivs[i].style="";
			else
				episodesDivs[i].style="display: none;"
		}
		//console.log(episodesDiv.children);
	}*/
	
	window.onload=function()
	{
		generateTables();
		
		document.querySelectorAll('.tabs').forEach(el => {
			var instance = M.Tabs.init(el, null);
			//instance.updateTabIndicator();
		});
		
		document.querySelectorAll('.dropdown-trigger').forEach(elems => {
			var instances = M.Dropdown.init(elems, {constrainWidth:false});
		});
		//showSelectedEpisodes('mainEpisodes');
	}
</script>
<body>
	<h1 id="theTop">GFL Cutscene Intrepeter (very alpha)</h1>
	<!--<h2>...And a way to read the game dialogue.</h2>-->
	<div id='chapterSelect'>
		<div class='row'>
			<div class="col s12">
				<ul class="tabs">
					<li class="tab col s3"><a href="#mainEpisodesWrapper">Main Story Chapters</a></li>
					<li class="tab col s3"><a href="#eventEpisodesWrapper">Story Events</a></li>
					<li class="tab col s3"><a href="#sideEpisodesWrapper">Side Stories</a></li>
					<li class="tab col s3"><a href="#crossoverEpisodesWrapper">Crossover Stories</a></li>
					<li class="tab col s3"><a href="#" onclick="return false;">T-Doll Dialogue (coming eventually)</a></li>
					<li class="tab col s3"><a href="#customCutsceneWrapper">Write your own cutscene</a></li>
				</ul>
			</div>
			<!--<a href=#modal1" class="modal-trigger" >Settings</a>-->

			<!--Because materialize.js is stupid -->
			<div class="col s12" id="mainEpisodesWrapper">
				<div class="flex-container col s12" id="mainEpisodes"></div>
			</div>
			
			<div class="col s12" id="eventEpisodesWrapper">
				<div class="flex-container col s12" id="eventEpisodes"></div>
			</div>
			<div class="col s12" id="sideEpisodesWrapper">
				<div class="flex-container col s12" id="sideEpisodes"></div>
			</div>
			<div class="col s12" id="crossoverEpisodesWrapper">
				<div class="flex-container col s12" id="crossoverEpisodes"></div>
			</div>
			<div class="col s12" id="customCutsceneWrapper">
				<div id="customCutscene">
					<p>WORK IN PROGRESS</p>
					<p>Opcode structure isn't finalized, check back later...</p>
				</div>
			</div>
				
		</div>
		
	</div>
	
	  <!-- Modal Structure -->
  <div id="modal1" class="modal">
    <div class="modal-content">
      <h4>Modal Header</h4>
      <p>A bunch of text</p>
    </div>
    <div class="modal-footer">
      <a href="#!" class="modal-close waves-effect waves-green btn-flat">Agree</a>
    </div>
  </div>
	<!--<h2><a href="#Textboxes">Mobile devices are stupid and the canvas absorbs touch, so click here to jump to the part without the canvas</a></h2>-->
	<!---->

	<h2 id="chapterName">Chapter Name Here</h2>
    <a id="startButton" onclick="initPhaser()" class="waves-effect waves-light btn disabled">Start interactive interpreter (It's like playing the game!)</a>
	<p id="curIndexDebug"></p>
	<div id="phaser"></div>
	<br><br><button onclick='showOpcodes()'>Show converted opcodes (For debugging)</button><br>
	<div id='myDIV' style="display: none;">
		<textarea rows='6' cols='50' id="DebugTextArea"></textarea><br>
		<button onclick="reRunWithNewOpcodes()">Re-run scene with these opcodes</button>
	</div>
	<!--<canvas id="myCanvas" width="1280" height="720"></canvas>--><br><br>
    <!--<h1 id="title">This is a header!</h1>-->
	<!--<img src="textbox.png"></img>-->
	<!--<h2><a href="#verySimpleText">Click HERE to jump to the text without any textboxes which is probably what you want anyways</a></h2>
	<h2>Static Textboxes</h2>
	<div id="Textboxes"></div>-->
	<hr>
	<!--<h2></h2>-->
	<!--<form>
	Display Style
	<input type="radio" id="fancy" name="displayStyle" value="male">
	<label for="fancy">Fancy</label>
	<input type="radio" id="simple" name="displayStyle" value="female">
	<label for="simple">Simple</label>
	</form>-->
	  <div class="switch">
    <label>
      Text Only
      <input type="checkbox">
      <span class="lever"></span>
      Fancy
    </label>
  </div>
	<div id="verySimpleText"></div>
	<a class="waves-effect waves-light btn" href="#theTop"><i class="material-icons left">vertical_align_top</i>Back to top</a> <a class="waves-effect waves-light btn" href="#theTop" onclick="goToNextEpisode();"><i class="material-icons left">chevron_right</i>Go to the next cutscene</a>
	<hr>
	<p>Dandelai is my wife, greets to /gfg/, <a href="https://github.com/RhythmLunatic/gfl-cutscene-interpreter">harass me on github (bug reports, check the source code, fork it)</a></p>
	<p>Can someone please fix the horrible UI? I'm a programmer, not a designer. Please fork the source code and make a pull request.</p>
	<p>If you want a feature or something is broken, <b><a href="https://github.com/RhythmLunatic/gfl-cutscene-interpreter/issues">file a bug report</a></b></p>
	<br>
	<!--<a href="https://github.com/RhythmLunatic/Girls-Frontline-Discord-Search">Try out my Girls' Frontline discord bot. T-Doll info, quotes, costumes, and more!</a>-->
</body>
