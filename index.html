<!doctype html>
<head>
	<meta charset="utf-8"/>
	<title>GFL cutscene interpreter</title>
	
	<!--For discord description -->
	<meta property="og:title" content="Girls' Frontline Cutscene Interpreter" />
	<meta property="og:type" content="website" />
	<meta property="og:url" content="http://gfl.amaryllisworks.pw" />
	<!--<meta property="og:image" content="http://my.site.com/images/thumb.png" />-->
	<meta property="og:description" content="Play back cutscenes in the browser" />
    <!--Let browser know website is optimized for mobile-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
	
	<!--Resources -->
<!--#ifdef LOCAL_ONLY
	<link rel="stylesheet" href="materialize.css">
#else-->
	<link rel="preconnect" href="https://fonts.gstatic.com">
	<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500&display=swap" rel="stylesheet">  
	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
	<!--<link type="text/css" rel="stylesheet" href="materialize.css"  media="screen,projection"/>-->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
<!--#endif-->
	<link rel="stylesheet" type="text/css" href="./tln.css"/>
	<script type="text/javascript" src="./tln.js"></script>
</head>
<!--#literal ON-->
<style type="text/css">
body
{
	/*background-color: black;
	color: white*/
	text-align:center;
	--bg-color: white;
	--text-color: black;
	--nav-color: #ee6e73;
	--btn-color: #26a69a;
	--card-color: #fff;
	--collection-item-color:#fff;
	--dropdown-text-color:#26a69a;
	--dropdown-hover-color:#eee;
	--settings-row-border-color: rgba(0, 0, 0, 0.12);
	--colored-dialogue: brightness(0.6);
	
	background-color: var(--bg-color);
	color: var(--text-color);
}

body.dark-theme{
	--bg-color: #333333;
	--text-color: white;
	--nav-color:#1a237e;
	--btn-color: #26a69a;
	--card-color: #455a64;
	--collection-item-color:#2b2b2b;
	--dropdown-text-color: white;
	--dropdown-hover-color: black;
	
	--settings-row-border-color: rgba(255, 255, 255, 0.5);
	--colored-dialogue: brightness(1.0);
}
body.black-theme{
	--bg-color: black;
	--text-color: white;
	--nav-color: #212121;
	--btn-color: #455a64;
	--card-color: #2e3436;
	--collection-item-color: black;
	--dropdown-text-color: white;
	--dropdown-hover-color: black;
	
	--settings-row-border-color: rgba(255, 255, 255, 0.8);
	--colored-dialogue: brightness(1.0);
}

nav {
	background-color: var(--nav-color);
}
textarea{
	color:var(--text-color);
}
input{
	color:var(--text-color);
}
h2 {
	margin: 1.424rem 0 1.424rem 0;
}

.textarea-wrapper{
	/*border:1px solid red;*/
	position:relative;
	height:500px;
	width:700px;
	margin:15px auto
}
/*.textarea-wrapper::before {
	content:"wrapper";
	text-transform: uppercase;
	left:0px;
	position:absolute;
	top:-18px;
	font-size:16px;
	color:red;
}*/

/*table, th, td {
   border: 1px solid #222222;
   border-collapse: collapse;
}
th {
	background-color: purple;
}*/

.header-desktop{
	display: inline-block;
}
.header-desktop-shorter{
	display: none;
}
.header-mobile{
	display: none;
}

@media screen and (max-width: 900px) {
    .header-desktop{
       display:none;
    }
    
    .header-desktop-shorter{
       display:inline-block;
    }
    .navbarButton{
    	padding: 0 5px; /*Since text is hidden, remove the padding between buttons*/
    }
    
    .modal {
    	width:100%;
    	max-height:100%;
    	height:100%;
    	top:0 !important;
    }
    .modal.modal-fixed-footer{
    	height:100%;
    }
}
@media screen and (max-width: 500px) {
    .header-desktop{
       display:none;
    }
    .header-desktop-shorter{
       display:none;
    }
    
    .header-mobile{
       display:inline-block;
    }
}

.btn {
	background-color: var(--btn-color);
}
.card {
	background-color: var(--card-color);
}
.modal {
	background-color: var(--bg-color);
	/* sadly animating 'top' breaks the modal showing */
	transition: width 0.2s ease-out, height 0.2s ease-out;
}
.collection .collection-item{
	background-color: var(--collection-item-color)
}
.dropdown-content{
	background-color: var(--card-color);
}
.dropdown-content li > a {
	color: var(--dropdown-text-color);
}
.dropdown-content li:hover, .dropdown-content li.active {
  background-color: var(--dropdown-hover-color);
}

.collapsible-header {
	background-color: var(--collection-item-color);
}


/*Something I actually wrote myself*/
.material-settings-table {
	padding: 0px;
}
.material-settings-table td {
	padding: 0px;
}
.material-settings-table p {
	margin: 0px;
}
.material-settings-table tr {
	border-bottom-color: var(--settings-row-border-color);
}

.material-settings-table .title {
	font-weight: bold;
	font-size:120%
}
#settingsModal .modal-footer {
	background-color: rgba(128,128,128,0.3);
}
#settingsModal .modal-footer > a {
	color: var(--text-color);
}

/*#head, #foot {
	height: 6%;
	min-height: 25px;
	width: 100%;
	background-color: #151515;
	overflow: hidden;
}

#head a {
  float: left;
  color: #f2f2f2;
  text-align: center;
  padding: 14px 16px;
  text-decoration: none;
  font-size: 17px;
}


#head a:hover {
  background-color: #ddd;
  color: black;
}

#head a.active {
  background-color: #4CAF50;
  color: white;
}*/

.tabs {
    display:-webkit-flex;
    display: -ms-flexbox;
    display: flex
}




.flex-container {
  display: flex;
  flex-wrap: wrap;
  /*background-color: DodgerBlue;*/
  justify-content: center;
  align-items: center;
}

.flex-container > div {
  background-color: #f1f1f1;
  margin: 5px;
  /*padding: 20px;
  font-size: 30px;*/
}

/*tr:nth-child(odd) {
    background-color: #000000CC;
}
tr:nth-child(even) {
    background-color: #111111CC;
}*/



#verySimpleText{
	text-align: left;
	font-family: 'Noto Sans KR', sans-serif;
	margin-left: 10px;
	margin-right: 10px;
}
.coloredDialogue{
	filter: var(--colored-dialogue);
}

/*To make everything nice and centered on desktop.*/
@media screen and (min-width:701px) {

	#verySimpleText{
		margin-left: 0px;
		margin-right: 0px;
		width: 700px; 
		margin: 0 auto;
	}
}

/*.container {
  position: relative;
  text-align: center;
  color: white;
}

.charName {
  font-family: 'Noto Sans KR', sans-serif;
  position: absolute;
  top: 5px;
  left: 16px;
  font-size: 2vw;
}

.absText {
      font-family: 'Noto Sans KR', sans-serif;
  position: absolute;
  top: 45px;
  left: 16px;
  font-size: 2.2vw;
}*/


/*.speakerName{
	font-weight: bold;
}*/



.snow{
	background-image:
        url(snow1.png),
           url(snow2.png),
           url(snow3.png);
	animation: snow 30s linear infinite;
}

@keyframes snow {
    0% {background-position: 0px 0px, 0px 0px, 0px 0px;}
    100% {background-position: 500px 1000px, 400px 400px, 300px 300px}
}


.storyText {
	margin-top: 0.5ex;
	margin-bottom: 0.5ex;
}

.storyText.speakerName {
	/*margin-top: 0;*/
	font-weight: bold;
}

/*
Blatantly stolen from gfl.zzzzz.kr 
I have no idea how it works
*/
.storyImg{
	position:relative;
	overflow:hidden; /*Keep portraits within div */
	width:100%;
	margin-top:1.5rem;
}
.storydoll{
	width:71%;
	position: absolute;
	bottom: -30%;
	z-index: 5;
}
.storydoll.one{
	left:15%; /*???*/
}
.storydoll.first.two{
	right:35%
}
.storydoll.second.two{
	left:35%
}

.storydoll.dim{
	filter: brightness(50%);
	z-index:4;
}
.storydoll.mask {
	mask-position: center;
	mask-size: 100%; /* I don't know why 100% works but it does */
	filter: brightness(300%) opacity(75%);
}

/*.storydoll.saying{
	filter: brightness(100%);
	z-index: 100;
}*/

#SearchResults {
	cursor: pointer;
	display: block;
	text-align: left;
}
/*lol */
.collection-item.waves-effect {
	display: inherit;
}

</style>
<!--#literal OFF
<script type="text/javascript"></script>-->

<!--#ifdef LOCAL_ONLY
<script src='materialize.js'></script>
<script src='phaser.js'></script>
<script src='fuse.js'></script>
#else-->
<!-- tfw no bandwidth -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
<!--<script type="text/javascript" src="materialize.js"></script>-->
<!--<script src="phaser.min.js"></script>-->
<script src="https://cdn.jsdelivr.net/npm/phaser@3.24.1/dist/phaser.min.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.js"></script>

<!--#endif-->

<!--Helper functions-->
<script>
	//https://stackoverflow.com/a/57401891
	/*function adjustColor(color, amount) {
		return '#' + color.replace(/^#/, '').replace(/../g, color => ('0'+Math.min(255, Math.max(0, parseInt(color, 16) + amount)).toString(16)).substr(-2));
	}*/
	
	//https://www.w3schools.com/js/js_cookies.asp
	function setCookie(cname, cvalue, exdays) {
		var d = new Date();
		d.setTime(d.getTime() + (exdays*24*60*60*1000));
		var expires = "expires="+ d.toUTCString();
		document.cookie = cname + "=" + cvalue + ";SameSite=Lax;" + expires + ";path=/";
	}
	function getCookie(cname) {
		var name = cname + "=";
		var decodedCookie = decodeURIComponent(document.cookie);
		var ca = decodedCookie.split(';');
		for(var i = 0; i <ca.length; i++) {
			var c = ca[i];
			while (c.charAt(0) == ' ') {
				c = c.substring(1);
			}
			if (c.indexOf(name) == 0) {
				return c.substring(name.length, c.length);
			}
		}
		return "";
	}
	
	//https://stackoverflow.com/a/29998400
	function JavaSplit(string,separator,n) {
		var split = string.split(separator);
		if (split.length <= n)
			return split;
		var out = split.slice(0,n-1);
		out.push(split.slice(n-1).join(separator));
		return out;
	}

</script>
<!--The main program-->
<script>
	/*
	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU Affero General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU Affero General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.

	This program is written by Rhythm Lunatic.
	*/
	
	/*
	Just gonna say it right now, I don't know an ounce of JavaScript or phaser.
	I interpreted lua and my game engine knowledge until this worked. Also lots of 'pythonic' logic in the JavaScript.
	
	So that's the answer as to why the chapter select looks horrible. Make a PR if you want it to be fixed.
	*/


	//I kept accidentally typing print ok
	window.print = function(param)
	{
		console.log(param);
	}
	function consoleWarn(param)
	{
		console.log("%c "+param,'background: black; color: yellow')
	}
	
	
	//FOR T-DOLL DISPLAY
	gfcolors = [
		"#000000", //NPCs & SF - Black?
		"0",        //Nothing has 1 stars.
		"#adadad", //2 stars   - Grey
		"#6bdfce", //3 stars   - Turquoise
		"#d6e35a", //4 stars   - Green
		"#ffb600", //5 stars   - Orange
		"#ff6a00", //6 stars   - Orange
		"#dfb6ff"  //EXTRAstar - Purple
	]
	
	function num2stars(div, numStars)
	{
		var _star_ = document.createElement("i");
		_star_.className = "material-icons";
		
		if (numStars < 1)
		{
		
		}
		else if (numStars == 7)
		{
			var star = _star_.cloneNode(false);
			star.innerHTML = "stars"
			star.style.color = gfcolors[7];
			div.appendChild(star);
		}
		else if (numStars > 5)
		{
			for (var j=0;j<numStars;j++)
			{
				var star = _star_.cloneNode(false);
				star.innerHTML = "star";
				star.style.color = gfcolors[numStars];
				div.appendChild(star);
			}
		}
		else
		{
			for (var j=0;j<5;j++)
			{
				var star = _star_.cloneNode(false);
				if (j < numStars)
					star.innerHTML = "star";
				else
					star.innerHTML = "star_border";
				star.style.color = gfcolors[numStars];
				div.appendChild(star);
			}
		}
	}
	
	
	//Night mode
	isDarkMode=false;
	function NightMode()
	{
		let theme = "dark-theme"
		if (document.body.classList.contains("dark-theme"))
		{
			theme='black-theme';
			document.body.classList.replace("dark-theme",theme);
			isDarkMode=true
		}
		else if (document.body.classList.contains("black-theme"))
		{
			theme='light-theme';
			document.body.classList.replace("black-theme",theme);
			isDarkMode=false;
		}
		else
		{
			document.body.classList.replace('light-theme',theme);
			isDarkMode=true;
		}
		setCookie('theme',theme,180);
	}
	
	//interpreter related
	
	const OPCODES = {
		STOPBGM : 0,
		BGM : 1,
		BG : 2,
		SPEAKER : 3,
		MSG : 4,
		PORTRAIT : 5,
		NOPORTRAIT : 6,
		MSGBOXTRANSITION : 7,
		SNOWEFFECT : 8,
		STOPEFFECTS : 9
		//SETMASKEDPORTRAIT : 8
	}
	
	//For JSON structured or making your own
	//Pro tip: use opcode2string.indexOf(s) to get the opcode number
	const opcode2string = [
		'stopBGM',
		'bgm',
		'bg',
		'speaker',
		'msg',
		'portrait',
		'noPortrait',
		'msgboxTransition',
		'snowEffect',
		'stopEffect'
		//'setMaskedPortrait'
	]
	
	const tag2opcode = {
		"Speaker":OPCODES.SPEAKER,
		"BIN":OPCODES.BG,
		"BGM":OPCODES.BGM,
		"下雪":OPCODES.SNOWEFFECT,
		"火焰销毁":OPCODES.STOPEFFECTS
		//"通讯框":OPCODES.SETMASKEDPORTRAIT,
	}
	

	//To be loaded later.
	let PORTRAITS = undefined;
	let BACKGROUNDS = undefined;
	let MUSIC = undefined;
	
	//For CSS
	var int2str = ['zero','one',  'two',   'three','four',  'five', 'six',  'seven',  'eight', 'nine']
	var int2strPos = ['N','first','second','third','fourth','fifth','sixth','seventh','eighth','ninth']
	
	//I moved everything to gfl subdomain so it's fine now
	//const portraitWebserver = "http://gfl.amaryllisworks.pw/pic/"
	
	function portraitStructToString(p)
	{
		return "idx: "+p[1]+" | name: "+p[2]+" | type: "+p[3]+" | dim: "+p[4]+" | isMasked: "+p[5]
	}
	
	//Don't care if it's all over the place. Fix it yourself. If this was SM I'd be using broadcasts anyways
	var nameActor;
	var bgActor;
	
	function loadBG(runtime, num)
	{
		console.log("Loading "+num+" | "+BACKGROUNDS[num])
		runtime.load.once('complete',function() { bgActor.setTexture(num);bgActor.displayWidth = 1280;bgActor.displayHeight= 720; },runtime)
		runtime.load.image(num,'avgtexture/'+BACKGROUNDS[num]+'.png');
		runtime.load.start();
	}
	
	//A pool of portraits since there's gonna be more than one
	var portraitCollection = []
	function loadPortrait(runtime,idx,name,type)
	{
		if (PORTRAITS[name] != undefined && PORTRAITS[name][type] != undefined)
		{
			let keyedPortrait=name+'-'+type;
			let fileName = PORTRAITS[name][type]
			console.log("Loading "+fileName);
			if (idx > portraitCollection.length-1)
			{
				runtime.load.once('complete',function() { portraitCollection.push( runtime.add.image(game.config.width/2,game.config.height-100,keyedPortrait) ) } );
			}
			else
			{
				runtime.load.once('complete',function() { portraitCollection[idx].setTexture(keyedPortrait) } );
			}
			runtime.load.image(keyedPortrait,'pic/'+fileName);
			runtime.load.start();
		}
		else
		{
			console.log("Portrait "+name+" missing from database.")
		}
	}
	
	//var interval;
	//Yes, I did translate it from lua. Lmao.
	class VNText4 {
		constructor(phaserRuntime,font,maxwidth,spd,msgTable)
		{
			this.phaserRuntime = phaserRuntime; //lol
			this.cur_len = 0;
			this.spd = spd;
			this.curIndex = 0;
			this.msgTable = msgTable;
			
			this.textActor = phaserRuntime.add.text(0,0,'Static Text Object', { fontFamily: 'Noto Sans KR', fontSize: 27, color: '#ffffff', wordWrap: {width:maxwidth,useAdvancedWrap:true} });
		}
		is_finished()
		{
			return this.cur_len == this.text.length;
		}
		
		//In StepMania you can just chain a command (within an actor) with sleep over and over, but in phaser you have to attach it to the game engine?
		//Attaching tweens to the game engine instead of actors is kind of a weird decision by the way, why wouldn't you attach them to the actor?
		//I'm using setInterval anyways
		play()
		{
			
			let f = function(self){
				self.cur_len = self.textActor.text.length;
				//console.log(self.cur_len+"/"+self.text.length);
				if (self.cur_len < self.text.length)
				{
					let txt = self.text.slice(0,self.cur_len+1)
					//console.log(txt);
					self.textActor.setText(txt);
				}
				else
				{
					clearInterval(f);
				}
			}
			
			f(this);
			
			//console.log(1/this.spd*1000);
			let interval = setInterval(f,1/this.spd*1000,this);
			//This can't possibly be high performance...
			
			/*phaserRuntime.tweens.add({
				targets:this.textActor,
				ease:'Linear',
				duration:1/this.spd,
				onComplete:this.play
			)}*/
				
			
		}
		Text()
		{
			this.cur_len = this.textActor.text;
			if (this.cur_len < this.text.length)
				this.textActor.setText(this.text.slice(0,this.cur_len));
		}
		advance()
		{
			if (this.no_more_text())
				return;
			//this.curIndex++;
			var noMsgYet = true;
			while (noMsgYet)
			{
				console.assert(this.msgTable[this.curIndex],"There is no opcode located at "+this.curIndex+". How did you even get this far?")
				let curMsg = this.msgTable[this.curIndex]
				let MsgOpcode = curMsg[0]
				//console.log(opcode)
				//console.log(this.curIndex);
				//console.log(MsgOpcode == OPCODES.MSG);
				switch(MsgOpcode) {
					case OPCODES.MSG:
						this.cur_len= 0
						this.text = curMsg[1]
						//this.text_actor:queuecommand("Check")
						noMsgYet = false;
						break;
					case OPCODES.SPEAKER:
						nameActor.setText(curMsg[1]);
						break;
					case OPCODES.BG:
						loadBG(this.phaserRuntime,curMsg[1]);
						break;
					case OPCODES.PORTRAIT:
						console.log(portraitStructToString(curMsg))
						loadPortrait(this.phaserRuntime,curMsg[1],curMsg[2],curMsg[3])
						break;
					//lua junk from my message system. Just ignore it.
					/*case OPCODESFMSG:
						this.cur_len= 0
						this.text = this.msgTable[this.curIndex][2]()
						//this.text_actor:queuecommand("Check")
						break outLoop;
					elseif opcode == "func" then
						this.msgTable[this.curIndex][2]()
					elseif opcode == "choice" then
						ChoiceTable = {Result=1,Finished=false}
						assert(this.msgTable[this.curIndex][2],"Choice table is invalid.")
						ChoiceTable.Choices = this.msgTable[this.curIndex][2]
						assert(ChoiceTable.Choices)
					elseif opcode == "exit" then
						return false;
					elseif opcode == "condJumpSS" then
						Trace(table_print(this.selfSwitches))
						Trace(table_print(this.msgTable[this.curIndex]))
						if this.selfSwitches[this.msgTable[this.curIndex][2]] == true then
							//Subtract 1 to account for advance advancing one step, since we want to start on whatever it jumps to
							this.curIndex = this.msgTable[this.curIndex][3]-1
							Trace("Jumped to index "..this.curIndex)
						end
					elseif opcode == "condJump" then
						if this.msgTable[this.curIndex][2]() == true then
							//Subtract 1 to account for advance advancing one step, since we want to start on whatever it jumps to
							this.curIndex = this.msgTable[this.curIndex][3]-1
							Trace("Jumped to index "..this.curIndex)
						end
					elseif opcode == "selfSwitch" then
						this.selfSwitches[this.msgTable[this.curIndex][2]] = this.msgTable[this.curIndex][3]
					end;*/
				}
				this.curIndex++;
				//console.log(noMsgYet);
			}
			//Trace(this.text)
			//lua.Flush();
			//this.text_actor:settext(""):playcommand("Check");
			//console.log(this.text)
			document.getElementById('curIndexDebug').innerText="idx: "+(this.curIndex-1)+" | msg: "+this.msgTable[(this.curIndex-1)].toString()
			this.textActor.setText('');
			this.play();
		}
		no_more_text()
		{
			return this.curIndex >= this.msgTable.length-1;
		}
		skip()
		{
			this.textActor.setText(this.text);
			this.cur_len = this.text.length;
		}
	}
	
	/*class SpriteActor() {
		constructor()
		{
			//this.
		}
	}*/
	
	function sliceAndRemove(str, begin, end)
	{
		return str.slice(0,begin)+str.slice(end)
	}
	
	function getFromTag(str,tag)
	{
		const beginTag = "<"+tag+">"
		const endTag = "</"+tag+">"
		var n = str.indexOf(beginTag)
		if (n != -1){
			return str.slice(n+beginTag.length, str.indexOf(endTag))
		}
		return null
	}
	function removeTag(str,tag)
	{
		const beginTag = "<"+tag+">"
		const endTag = "</"+tag+">"
		return sliceAndRemove(str,str.indexOf(beginTag),str.indexOf(endTag)+endTag.length)
	}
	
	function playNewAudio(fileName)
	{
		let audioPlayer = document.getElementById('audioPlayer');
		audioPlayer.firstElementChild.src = fileName
		audioPlayer.load();
		audioPlayer.play();
	}
	
	
	let curEpisodePart = 0
	class GirlsFrontlineScene extends Phaser.Scene {
		constructor()
		{
			//I don't know what this does but the tutorial had it
			super('GirlsFrontlineScene');
		}
		
		 preload()
		{
			//this.load.image('test','test.png');
			this.load.image('textbox','textbox.png');
		}
		
		create()
		{
			//input.touch only works on mobile devices. So it will break on desktop. reeeee
			//game.input.touch.capture = false;
			
			//GFL, in all of it's genius, uses 1024x1024 images. With black borders.
			/*bgActor = this.make.image({ x:game.config.width/2, y:game.config.height/2, add:true });
			bgActor.displayWidth = 1024
			bgActor.displayHeight= 1024*/
			bgActor = this.add.image(game.config.width/2,game.config.height/2);
			bgActor.texture = Phaser.Cache.DEFAULT;
			bgActor.setDepth(0);
			
			/*var img = this.make.image({ x:game.config.width/2, y:game.config.height/2, key:'test',add:true })
			img.displayWidth = game.config.width
			img.displayHeight= game.config.height
			img.setDepth(1);*/
			
			//Depth 2 is reserved for character portraits!
			
			imageActor = this.make.image({
				x:game.config.width /2,
				y:game.config.height-125,
				//scale:1,
				key:'textbox',
				add:true
			})
			imageActor.scaleY = 1
			imageActor.setDepth(3);
			
			//var blocks = this.add.group({ key: 'block', repeat: 139, setScale: { x: 0, y: 0 } });
			
			nameActor = this.add.text(240,500,'', { fontFamily: 'Noto Sans KR', fontSize: 30, color: '#ffffff' });
			nameActor.setDepth(4);
			
			//TODO
			document.getElementById("DebugTextArea").value = structuredLinesToString(currentEpisodeAsOpcodes[curEpisodePart]);
			
			vntext = new VNText4(this,'',800,13,currentEpisodeAsOpcodes[curEpisodePart]);
			vntext.textActor.x = 242;
			vntext.textActor.y = game.config.height-160
			vntext.textActor.setDepth(4);
			vntext.advance();
			
			this.input.on('pointerdown',function(){
				if (vntext.no_more_text())
				{
					console.log("Already hit the end!!!!");
					//'this' isn't passed in... No idea what I'm gonna do
					//If you spam click it will crash because you're removing and trying to add multiple scenes at the same time
					//this.input.onInputDown.removeAll();
					if (curEpisodePart < currentEpisodeAsOpcodes.length)
					{
						curEpisodePart++;
						game.scene.remove('GirlsFrontlineScene');
						game.scene.add('GirlsFrontlineScene',GirlsFrontlineScene,true);
					}
					else
					{
						//Oh no
						goToNextEpisode()
					}
					
				}
				else
				{
					if (vntext.is_finished())
					{
						vntext.advance();
					}
					else
					{
						vntext.skip();
					}
				}
			},vntext)
			//Hey look it's just like StepMania
			/*this.make.text({
				x: 100,
				y: 100,
				text: 'Phaser III',
				style: {
					fontSize: '48px',
					fontFamily: 'Arial',
					color: '#ffffff',
					metrics: {
						ascent: 45,
						descent: 10,
						fontSize: 55
					}
				}
			})*/
		}
		
		//I'm not even using this lmao
		 update()
		{
			
		}
	}
	
	let config = {
		type: Phaser.WEBGL,
		width: 1280,
		height: 720,
		parent: 'phaser',
		/*scene: {
			preload: preload,
			create: create,
		}*/
		scene: [GirlsFrontlineScene]
	};
	
	//phaser
	var game;
	
	var imageActor;
	var vntext;
	
	
	function convertGFLTextToOpcodes(out)
	{
		//console.log(out);
		var lines = out.split(/\r?\n/);
		//The GFL text system is stupid as fuck and I just spent a whole week writing my own VN system
		//So obviously I'm going to convert it to my own. fuck you
		//console.log(lines)
		//Fuck your opcodes
		let structuredLines = [];
		
		
		//It's really stupid but dimRightSide has to know the state of the previous dimmed portraits because normally the GFL engine only supports two portraits and I wanted more
		let prevLineHadAtLeastTwoPortraits = false;
		let dimRightSide = false;
		for(i=0;i<lines.length;i++)
		{
			if (!lines[i])
				continue;
			//print(lines[i]);
			let [cmds,text] = JavaSplit(lines[i].replace("：",':').replace("；",";"),":",2)
			console.assert(cmds,lines[i])
			//There can be lines without any text so asserting is pointless
			//console.assert(text,lines[i])
			//console.log(text)
			//
			
			//Yeah I know tags are supposed to be in order, No I don't really care sorry
			
			//So portraits are set in any order... But how the fuck are you supposed to tell when a name is if there's <> tags
			//I'm just going to search portraits after removing <> tags, it probably won't matter
			let numPortraits = 0;
			let thisLineHadAtLeastTwoPortraits = (cmds.indexOf(";") != -1)
			//This doesn't work correctly... If a new portrait gets pushed and the previous line had two portraits then the dimmed one is the existing portrait from the previous line
			if (thisLineHadAtLeastTwoPortraits && prevLineHadAtLeastTwoPortraits)
					dimRightSide = !dimRightSide;
				
			//Add portrait removal command
			if (prevLineHadAtLeastTwoPortraits && !thisLineHadAtLeastTwoPortraits)
			{
				let [charID,charSpr] = cmds.slice(0,cmds.indexOf(")")).split("(")
				//let newPortrait = 
				//It's -2 because the last line is always MSGBOXTRANSITION
				for(var lll=structuredLines.length-2; lll>=0; lll--)
				{
					let m = structuredLines[lll];
					if (m[0]==OPCODES.MSGBOXTRANSITION)
						break;
					else if (m[0]==OPCODES.PORTRAIT && m[2]!=charID)
					{
						structuredLines.push([OPCODES.NOPORTRAIT,m[1]])
						break;
					}
				}
			}
			//console.log(thisLineHadAtLeastTwoPortraits);
			//Limit it to 5 because I don't want a dumb infinite loop that crashes the browser
			for(j=0;j<5;j++)
			{
				//console.log(cmds)
				let charTagEnd = cmds.indexOf(")");
				if (charTagEnd != -1)
				{
					//It's +1 to get rid of the ;
					let charTagStart = Math.max(cmds.lastIndexOf(";",charTagEnd)+1,0)
					let [charID,charSpr] = cmds.slice(charTagStart,charTagEnd).split("(")
					//console.log(charID)
					//console.log(charSpr)
					//Ignore empty sprite IDs, they do nothing.
					if (charSpr != undefined && charSpr != "")
					{
						let shouldDim = false;
						if (thisLineHadAtLeastTwoPortraits)
						{
							if (!prevLineHadAtLeastTwoPortraits)
							{
								//debugger;
								//If this is the second portrait being added, we can just check the state of the previous portrait.
								if (numPortraits>0)
								{
									let m = structuredLines[structuredLines.length-1]
									if (m[0]==OPCODES.PORTRAIT)
										{
											shouldDim=!m[4]
											dimRightSide=shouldDim;
										}
									else
										consoleWarn("wtf?")
								}
								else
									//It's -2 because the last line is always MSGBOXTRANSITION.
									for(var lll=structuredLines.length-2; lll>=0; lll--)
									{
										let m = structuredLines[lll];
										if (m[0]==OPCODES.MSGBOXTRANSITION)
											break;
										//Search for single old portrait, if it matches then it shouldn't dim
										else if (m[0]==OPCODES.PORTRAIT)
										{
											//debugger;
											//Insert terrible programmer meme here
											//The new portrait is the one NOT dimmed
											shouldDim = (m[2] == charID)
											//????????????????????????????????????????
											//Maybe dimRightSide=!shouldDim will also work?
											dimRightSide=(shouldDim ? j==0 : j!=0)
											break;
										}
									}
							}
							else
							{
								shouldDim = dimRightSide ? j !=0 : j == 0;
							}
							//debugger;
						}
						
						let shouldMask = false;
						//It's -2 because the last line is always MSGBOXTRANSITION.
						for(var lll=structuredLines.length-2; lll>=0; lll--)
						{
							let m = structuredLines[lll];
							if (m[0]==OPCODES.NOPORTRAIT && m[1]==numPortraits)
							{
								//console.log("Found noportrait at "+lll+", exit");
								//Portrait was cleared previously, so this is probably the first instance of the portrait and there's no need to determine previous masking
								//shouldMask=false;
								break;
							}
							//Search for single old portrait, if it matches then it shouldn't dim
							else if (m[0]==OPCODES.PORTRAIT)
							{
								if (m[2] == charID)
								{
									shouldMask = m[5]
									//console.log("Found previous portrait, previous mask value was "+shouldMask)
									break;
								}
							}
						}
						
						
						structuredLines.push([OPCODES.PORTRAIT,numPortraits,charID,charSpr,shouldDim,shouldMask])
						//nextPortraitIsMasked = false;
						numPortraits++;
					}
					//I think speaker name gets cleared if it's ()? Not sure
					//Portrait gets cleared
					else
					{
						structuredLines.push([OPCODES.NOPORTRAIT,1])
						structuredLines.push([OPCODES.NOPORTRAIT,0])
						structuredLines.push([OPCODES.SPEAKER,""])					
						//numPortraits=0;
					}
					cmds = sliceAndRemove(cmds,charTagStart,charTagEnd+1);
				}
				else
				{
					//console.log("Done... Let's exit");
					break;
				}
			}
			prevLineHadAtLeastTwoPortraits = thisLineHadAtLeastTwoPortraits;
			
			
			let speakerRes = getFromTag(cmds,"Speaker")
			//debugger;
			if (speakerRes != undefined)
			{
				let prevLine = structuredLines[structuredLines.length-1]
				//Optimization: If prevLine was another speaker line, overwrite it instead of writing another
				if (prevLine[0]==OPCODES.SPEAKER)
					structuredLines[structuredLines.length-1]=[OPCODES.SPEAKER,speakerRes]
				else
					structuredLines.push([OPCODES.SPEAKER,speakerRes])
			}
			
			let bgmRes = getFromTag(cmds,"BGM")
			
			if (bgmRes != null)
			{
				if(bgmRes=="BGM_Empty")
					structuredLines.push([OPCODES.STOPBGM])
				else
				{
					//If music exists in db then rename it before pushing
					structuredLines.push([OPCODES.BGM,MUSIC[bgmRes] ? MUSIC[bgmRes] : bgmRes])
				}
				
			}
			
			const tags = ["BIN"]
			tags.forEach(tag => {
				//console.log(tag);
				let tagRes = getFromTag(cmds,tag);
				//console.log(tagRes)
				if (tagRes != null)
				{
					structuredLines.push([tag2opcode[tag],tagRes])
					cmds = removeTag(cmds,tag)
				}
			})
			//const tags = [
			//var nextPortraitIsMasked = false;
			//Since portraits are searched before modifiers...
			if (cmds.includes("<通讯框>"))
			{
				let idxToCheck = 0;
				
				let posOfMaskCmd = cmds.indexOf("<通讯框>");
				let posOfCmdDivider = cmds.indexOf(";")
				//console.log(posOfCmdDivider+" "+posOfMaskCmd+" "+cmds)
				//If this line had more than one portrait AND the ; is before the mask command, we should be masking the portrait at idx 1 instead of 0
				if (posOfCmdDivider > -1 && posOfCmdDivider < posOfMaskCmd)
				{
					//console.log("checking portrait on right side to mask")
					idxToCheck = 1;
				}
				
				for(var lll=structuredLines.length-1; lll>=0; lll--)
				{
					let m = structuredLines[lll];
					console.assert(m)
					if(m[0]==OPCODES.MSG)
					{
						//consoleWarn("Found a message opcode before a portrait opcode... Messages shouldn't exist at this point")
						break;
					}
					else if (m[0]==OPCODES.PORTRAIT && m[1] == idxToCheck)
					{
						//console.log("set mask true for portrait "+portraitStructToString(structuredLines[lll]))
						structuredLines[lll][5]=true
						break;
					}
				}
				//nextPortraitIsMasked = true;
				//structuredLines.push([OPCODES.SETMASKEDPORTRAIT])
				cmds=cmds.replace("<通讯框>","");
			}
			/**/
			
			//Now do text... But first check if there is any text (some lines are only commands)
			if (text)
			{
				//Snow effect is on the right hand side for some reason
				["火焰销毁",'下雪'].forEach(tag => {
					let tagRes = getFromTag(text,tag);
					if (tagRes != null)
					{
						structuredLines.push([tag2opcode[tag],tagRes])
						text = removeTag(text,tag)
					}
				})
				
				
				text.split("+").forEach(msg => {
					structuredLines.push([OPCODES.MSG,msg])
				})
			}
			//open/close msgbox
			structuredLines.push([OPCODES.MSGBOXTRANSITION])
		}
		return structuredLines;
	}
	
	var curEpKey;
	var currentEpisodeAsOpcodes;
	
	//WHY DOES IT HAVE TO BE A SEPARATE FUNCTION
	/*async function fetchTextFile(fileName)
	{
		console.log("fetching "+fileName);
		const response = await fetch("avgtxt/"+fileName);
		console.log("got "+fileName);
		return await response.text();
		//const out = await response.text();
		//return out;
	}*/
	
	function structuredLinesToString(structuredLines)
	{
		let s = "";
		structuredLines.forEach(line => {
			s+=opcode2string[line[0]]+';'
			/*for(var i=1;i<line.length;i++)
				s+=line[i]*/
			s+=line.slice(1).join([separator = ';'])
			s+='\r\n'
			//s+=line.toString()+"\r\n";
		})
		return s;
	}
	function stringToStructuredLines(s)
	{
		var lines = s.split(/\r?\n/);
		let structuredLines = [];
		for(i=0;i<lines.length;i++)
		{
			let newMsg = lines[i].split(';')
			newMsg[0] = opcode2string.indexOf(newMsg[0])
			if (newMsg[0] == OPCODES.PORTRAIT)
			{
				//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining
				//Someone said the site stopped working because I used the operators so I had to change it back :V
				//It also doesn't work on the old version of Firefox for Android and I want Tampermonkey
				//newMsg[4] = (newMsg[4]?.toLowerCase() == "true")
				//newMsg[5] = (newMsg[5]?.toLowerCase() == "true")
				
				newMsg[4] = (newMsg[4] != undefined ? newMsg[4].toLowerCase() == "true" : false)
				newMsg[5] = (newMsg[5] != undefined ? newMsg[5].toLowerCase() == "true" : false)
			}
			structuredLines.push(newMsg)
		}
		return structuredLines;
	}
	
	//Anti-XSS
	function sanitize(string) {
		const map = {
			'&': '&amp;',
			'<': '&lt;',
			'>': '&gt;',
			'"': '&quot;',
			"'": '&#x27;',
			"/": '&#x2F;',
			"`": '&grave;'
		};
		const reg = /[&<>"'/]/ig;
		return string.replace(reg, (match)=>(map[match]));
	}
	
	//input: structuredLines (string), part (int starting at 0), partName (string. Optional, if present replaces the "Part X" header
	//output: a div with the elements rendered
	//This function does not cause side effects.
	function renderStructuredLinesToDiv(structuredLines,part,partName)
	{
		
		let thisPartDiv = document.createElement('div');
		let h3 = document.createElement('h3');
		//console.log(partNum);
		if (partName != undefined)
			h3.innerText="Part "+(part+1)+": "+partName
		else
			h3.innerText="Part "+(part+1);
		//partNum++;
		thisPartDiv.appendChild(h3);
		
		if (document.getElementById('showDebugOpcodeButton').checked)
		{
			let button = document.createElement('a');
			//fuck your javascript
			button.setAttribute("class","waves-effect waves-light btn");
			button.setAttribute("onclick","showOpcodes('div_cutscene_iop_"+part+"')")
			button.innerText="Show opcodes for this section (For debugging)"
			thisPartDiv.appendChild(button);
			thisPartDiv.appendChild(document.createElement('br'));
		
			let opcodesDiv = document.createElement('div');
			opcodesDiv.id= "div_cutscene_iop_"+part
			opcodesDiv.style="display: none;"
			opcodesDiv.classList.add("textarea-wrapper");
			opcodesDiv.innerHTML = "<textarea rows='6' cols='50' id='textarea_cutscene_"+part+"' readonly>"+structuredLinesToString(structuredLines)+"</textarea><br>"
			//debugger;
			TLN.append_line_numbers_obj(opcodesDiv.firstElementChild,"textarea_cutscene_"+part)
			thisPartDiv.appendChild(opcodesDiv)
		}
		
		let playBGMbutton = document.createElement('a');
		playBGMbutton.setAttribute("class","waves-effect waves-light btn");
		playBGMbutton.innerHTML='<i class="material-icons left">music_note</i>Play audio for this cutscene'
		

		
		//<img src="avgtexture/夜间蒙版.png" class="storydoll first one mask" style="mask-image: url(pic/pic_NPC-Helian.png);">
		let maskThing = document.createElement('img');
		maskThing.src= "avgtexture/夜间蒙版.png";
		maskThing.classList.add("storydoll");
		maskThing.classList.add("mask");
		maskThing.style="z-index: 10";
		
		
		let lastSpeakerName = "";
		let lastBGUsed = ""; //'avgtexture/'+BACKGROUNDS[num]+'.png'
		let didBGOrPortraitOrNameChange = false;
		let shownPortraits = []
		
		let fancyDisplayType = document.getElementById('fancyOrNot').checked;
		//let inlineText = document.getElementById('inlineText').checked
		let advancedCSS = document.getElementById('advancedCSS').checked;
		var snowDiv;
		if (advancedCSS)
		{
			snowDiv = document.createElement('div');
			snowDiv.classList.add('snow');
			snowDiv.style='position: absolute; width:100%; height:100%;bottom: 0;'
		}
		
		let snowEffect = false
		
		for(var i=0;i<structuredLines.length;i++)
		{
			let opcode = structuredLines[i][0]
			//console.log(structuredLines[i]);
			switch (opcode)
			{
				case OPCODES.BGM:
					let newPlayBGMButton = playBGMbutton.cloneNode(true);
					newPlayBGMButton.setAttribute("onclick","playNewAudio('audio/"+structuredLines[i][1]+".ogg')")
					thisPartDiv.appendChild(newPlayBGMButton);
					break;
				case OPCODES.SPEAKER:
					if (lastSpeakerName != structuredLines[i][1])
					{
						lastSpeakerName=structuredLines[i][1];
						didBGOrPortraitOrNameChange = true
						
						//TODO: Make it so changing the speaker doesn't render a new box..
						/*if (lastSpeakerName != "")
						{
							let p = document.createElement('p');
							p.innerText = lastSpeakerName;
							//p.innerHTML = "<b>"+lastSpeakerName+"</b>";
							p.classList.add("storyText");
							p.classList.add("speakerName");
							thisPartDiv.appendChild(p);
						}*/
					}
					else
					{
						//console.log("speaker command was called but already matches previous speaker...");
					}
					break;
				case OPCODES.PORTRAIT:
					if (!fancyDisplayType)
						break;
					//console.log(portraitStructToString(structuredLines[i]))
					let idx = structuredLines[i][1]
					let name = structuredLines[i][2]
					let type = structuredLines[i][3]
					if (PORTRAITS[name] && PORTRAITS[name][type])
					{
						//console.log(shownPortraits.length);
						if (structuredLines[i][1] > shownPortraits.length-1)
						{
							//console.log("Pushed new portrait with idx "+idx);
							shownPortraits.push(structuredLines[i]);
							didBGOrPortraitOrNameChange = true;
						}
						else
						{
							let newPortrait = structuredLines[i]
							//newPortrait[2].replace('
							let oldPortrait = shownPortraits[idx]
							if (newPortrait[1] == oldPortrait[1] && newPortrait[2] == oldPortrait[2] && newPortrait[3] == oldPortrait[3] && newPortrait[4] == oldPortrait[4])
								console.log("New portrait set is identical to old one, ignoring change. (TODO: This should be left to the opcode interpreter to filter out!)");
							else
							{
								//console.log("Portrait replaced "+portraitStructToString(oldPortrait) +" -> "+portraitStructToString(newPortrait))
								shownPortraits[idx]=newPortrait;
								didBGOrPortraitOrNameChange = true;
							}
						}
						//console.log("NumPortraits: "+shownPortraits.length);
					}
					else if (PORTRAITS[name])
					{
						if (document.getElementById('showDebugOpcodeButton').checked)
						{
							let p = document.createElement('p');
							p.innerHTML = "<span class='coloredDialogue' style='color:red'>PORTRAIT TYPE MISSING BELOW "+portraitStructToString(structuredLines[i])+"</span>";
							p.classList.add("storyText");
							thisPartDiv.appendChild(p);
						}
					
						consoleWarn("Portrait type missing. Falling back to default.")
						consoleWarn(portraitStructToString(structuredLines[i]))
						shownPortraits[idx]=structuredLines[i];
						shownPortraits[idx][3]=0
						

						
					}
					else
					{
						if (document.getElementById('showDebugOpcodeButton').checked)
						{
							let p = document.createElement('p');
							p.innerHTML = "<span class='coloredDialogue' style='color:red'>PORTRAIT MISSING BELOW: "+structuredLines[i][2]+"</span>";
							p.classList.add("storyText");
							thisPartDiv.appendChild(p);
						}
						consoleWarn(portraitStructToString(structuredLines[i]))
						consoleWarn("Portrait missing from database.")
						shownPortraits[idx]=structuredLines[i];
						shownPortraits[idx][2]='missing'
						shownPortraits[idx][3]=0
					}
					break;
				case OPCODES.NOPORTRAIT:
					if (shownPortraits.length > 0)
					{
						shownPortraits = [];
						didBGOrPortraitOrNameChange = true;
					}
					else
					{
						//console.log("noportrait command was called but there are already no portraits...")
					}
					break;
				case OPCODES.BG:
					if (!fancyDisplayType)
						break;
					let newBG;
					if (BACKGROUNDS[structuredLines[i][1]] == undefined)
					{
						consoleWarn("Background "+structuredLines[i][1]+" is not indexed.")
						newBG = "avgtexture/missing.png"
					}
					else
						newBG = 'avgtexture/'+BACKGROUNDS[structuredLines[i][1]]+'.png'
					
					if (newBG == lastBGUsed)
					{
						//console.log("New BG set is identical to old one, ignoring change. (TODO: This should be left to the opcode interpreter to filter out!)");
					}
					else
					{
						console.log(lastBGUsed + " -> "+newBG)
						lastBGUsed = newBG
						didBGOrPortraitOrNameChange = true;
					}
					break;
				case OPCODES.SNOWEFFECT:
					snowEffect = true;
					break;
				case OPCODES.STOPEFFECTS:
					snowEffect = false;
					break;
				case OPCODES.MSG:
					//Spawn new BG with speaker and portrait here.
					let message = structuredLines[i][1]
					//TODO: Ignore ALL unknown/illegal codes, not just <script>
					message = message.replaceAll("<script>","&lt;script&gt;").replaceAll("<\/script>","&lt;&#x2F;script&gt;")
					for(var ccc = 0; ccc < 10; ccc++)
					{
						if(ccc > 5)
						{
							consoleWarn("Encountered more than 5 color codes in a message... This is very unusual, so bailing out");
							break;
						}
						//If you haven't already guessed, I don't know regex
						let idx = message.indexOf("<color=");
						if (idx != -1)
						{
							//print('parsing colors: '+message);
							let end = message.indexOf('>',idx)
							let color = message.slice(idx+7,end)
							//console.log(color)
							let spanTagStart = "<span class='coloredDialogue' style='color:"+color+"'>"
							//First sanitize the part outside the <color> tag, then insert the new <span> tag, then sanitize the section inside the span tag, then insert the end tag
							//Then finally insert the rest of the unsanitized message.
							//debugger;
							message = message.slice(0,idx)+spanTagStart+sanitize(message.slice(end+1,message.indexOf("</color>")))+"</span>"+message.slice(message.indexOf("</color>")+8)
							//console.log("new msg: "+message);
						}
						else
						{
							break;
						}
					}
					for(var ccc = 0; ccc < 10; ccc++)
					{
						if(ccc > 5)
						{
							consoleWarn("Encountered more than 5 size codes in a message... This is very unusual, so bailing out");
							break;
						}
						//If you haven't already guessed, I don't know regex
						let idx = message.indexOf("<size=");
						if (idx != -1)
						{
							//console.log(message);
							let end = message.indexOf('>',idx)
							let size = message.slice(idx+6,end)/45*100 //Assume default is 45px
							let spanTagStart = "<span class='sizedDialogue' style='font-size:"+size+"%'>"
							//First sanitize the part outside the <color> tag, then insert the new <span> tag, then sanitize the section inside the span tag, then insert the end tag
							//Then finally insert the rest of the unsanitized message.
							//debugger;
							message = sanitize(message.slice(0,idx))+spanTagStart+sanitize(message.slice(end+1,message.indexOf("</size>")))+"</span>"+message.slice(message.indexOf("</size>")+7)
						}
						else
						{
							break;
						}
					}
					
					if (fancyDisplayType)
					{
						//console.log("aaa");
						if (didBGOrPortraitOrNameChange)
						{
							let storyBox = document.createElement('div');
							storyBox.classList.add('storyImg');
							let bgImage = document.createElement('img');
							bgImage.style = "width:100%; position:relative; display:block;";
							bgImage.src = lastBGUsed;
							storyBox.appendChild(bgImage);
							for(var j=0;j<shownPortraits.length;j++)
							{
								console.assert(shownPortraits[j]);
								let portraitImg = document.createElement('img');
								portraitImg.src = 'pic/'+PORTRAITS[shownPortraits[j][2]][shownPortraits[j][3]];
								//console.log(portraitImg.src);
								
								portraitImg.classList.add("storydoll");
								if (shownPortraits[j][4]==true)
									portraitImg.classList.add('dim')
								portraitImg.classList.add(int2strPos[j+1]);
								portraitImg.classList.add(int2str[shownPortraits.length]);
								storyBox.appendChild(portraitImg);
								
								//If mask (new)
								//<img src="avgtexture/夜间蒙版.png" class="storydoll first one mask" style="mask-image: url(pic/pic_NPC-Helian.png);">
								//Mask is a transparent masked blue image, so we overlay on top of the other img
								if (shownPortraits[j][5]==true)
								{
									let m = maskThing.cloneNode(true);
									m.classList.add(int2strPos[j+1])
									m.classList.add(int2str[shownPortraits.length]);
									m.style = "mask-image: url('"+portraitImg.src+"');"
									storyBox.appendChild(m);
								}
							}
							
							if (snowEffect && advancedCSS)
								storyBox.appendChild(snowDiv.cloneNode(false));
							
							/*if (inlineText)
							{
								let textboxDiv = document.createElement('div');
								if (inlineText)
									textboxDiv.style="color:white; position: absolute; bottom: 0%; width:100%; z-index: 100; padding-top: 30px; padding-bottom:10px; background: linear-gradient(rgba(0, 0, 0, 0) 0%, rgb(0, 0, 0) 100%)"
								if (lastSpeakerName != "")
								{
									let p = document.createElement('p');
									p.innerText = lastSpeakerName;
									if (inlineText)
										p.style="margin-left: 10px; margin-right:10px;"
									//p.innerHTML = "<b>"+lastSpeakerName+"</b>";
									p.classList.add("storyText");
									p.classList.add("speakerName");
									textboxDiv.appendChild(p);
								}
								storyBox.appendChild(textboxDiv)
								
								
								thisPartDiv.appendChild(storyBox);
							}
							else
							{*/
								thisPartDiv.appendChild(storyBox);
								
								if (lastSpeakerName != "")
								{
									let p = document.createElement('p');
									p.innerText = lastSpeakerName;
									//p.innerHTML = "<b>"+lastSpeakerName+"</b>";
									p.classList.add("storyText");
									p.classList.add("speakerName");
									thisPartDiv.appendChild(p);
								}
							//}
							
							didBGOrPortraitOrNameChange = false;
						}
						
						//No, it's not well written. No, I don't know how to fix it.
						/*if (inlineText)
						{
							let p = document.createElement('p');
							p.classList.add('storyText')
							p.style="color:white; margin-left: 10px; margin-right:10px; margin-bottom:5px; margin-top: 5px;"
							p.innerHTML = message;
							let d = thisPartDiv.lastChild.getElementsByTagName('div')[0].appendChild(p);
						}
						else
						{*/
							
							let p = document.createElement('p');
							p.classList.add('storyText')
							p.innerHTML = message;
							thisPartDiv.appendChild(p);
						//}
					}
					else
					{
						let p = document.createElement('p');
						if (lastSpeakerName == "")
							p.innerHTML = message;
						else
							p.innerHTML = lastSpeakerName + ": "+message;
						thisPartDiv.appendChild(p);
					}
					break;
				default:
					//console.log("unknown OPCODES..");
			}
		}
		return thisPartDiv;
	}
	
	//You're probably wondering why the fuck there's two of these functions when a routableKeyString is always passed in
	//That's because I want to support running from an episode object without the keyString (for user stuff)
	function runFromRoutableKeyString(value)
	{
		if (value == undefined)
			value = curEpKey;
		let [type,chapter,episode] = getKeysFromRoutableString(value)
		run(listOfChapters[type][chapter]['episodes'][episode],value)
	}
	
	function runFromUserInput()
	{
		let out = document.getElementById('textarea1').value;
		let structuredLines = stringToStructuredLines(out);
		currentEpisodeAsOpcodes = [structuredLines];
		curEpKey = "";
		let simpleTextDiv = document.getElementById("verySimpleText");
		let NewSimpleTextDiv = document.createElement('div');
		NewSimpleTextDiv.id="verySimpleText";
		NewSimpleTextDiv.appendChild(renderStructuredLinesToDiv(structuredLines,0))
		
		simpleTextDiv.parentNode.replaceChild(NewSimpleTextDiv,simpleTextDiv);
		if (game == undefined)
			document.getElementById("startButton").classList.remove('disabled');
	}
	
	async function run(episode, routableKeyString)
	{
		currentEpisodeAsOpcodes = [];
		curEpisodePart = 0;
		curEpKey = routableKeyString;
		
		document.getElementById('chapterName').innerText = episode['name'];
		
		//Instead of just one part, put all of them in the verySimpleText div.
		let NewSimpleTextDiv = document.createElement('div');
		NewSimpleTextDiv.id="verySimpleText";
		
		//Don't keep audio running
		document.getElementById('audioPlayer').pause();
		
		//let partNum = 0;
		for(var p = 0; p < episode.parts.length;p++)
		{
			let fileName = episode.parts[p];
			let partName = null
			if (episode['part_names'] != undefined)
				partName=episode['part_names'][p]
			
			//We have to await so it doesn't load the parts in the wrong order. Which is an actual thing that has happened.
			console.log("fetching "+fileName);
			const response = await fetch("avgtxt/"+fileName);
			const out = await response.text();
			console.log("got "+fileName);
			
			//console.log(fetchTextFile("avgtxt/"+fileName));
			
			//fetch("avgtxt/"+fileName)
			//.then(response => response.text())
			//.then((out) => {
			//fetchTextFile(fileName).then(out => {
			//console.log('got '+fileName);
			//TODO: Add check if it's JSON (iop format) and then use a JSON parser if it is
			let structuredLines = convertGFLTextToOpcodes(out);
			
			if (document.getElementById('showDebugOpcodeButton').checked)
			{
				let button2 = document.createElement('a');
				//fuck your javascript
				button2.setAttribute("class","waves-effect waves-light btn");
				button2.setAttribute("href","avgtxt/"+fileName);
				button2.innerText="original text file for this section (For debugging)"
				NewSimpleTextDiv.appendChild(button2);
				NewSimpleTextDiv.appendChild(document.createElement('br'));
				
			}
			NewSimpleTextDiv.appendChild(renderStructuredLinesToDiv(structuredLines,p,partName));
			//Now replace the old div...
			/*let textboxDiv = document.getElementById("Textboxes");
			textboxDiv.parentNode.replaceChild(newTextboxDiv,textboxDiv);*/
			
			currentEpisodeAsOpcodes.push(structuredLines);
			
		}
		
		//If phaser is already init, go ahead and set the new scene
		//...By destroying the old one and recreating it.
		if (game != undefined)
		{
			game.scene.remove('GirlsFrontlineScene');
			game.scene.add('GirlsFrontlineScene',GirlsFrontlineScene,true);
		}
		let simpleTextDiv = document.getElementById("verySimpleText")
		simpleTextDiv.parentNode.replaceChild(NewSimpleTextDiv,simpleTextDiv);
		
		if (document.getElementById('chapterHistoryRouting').checked && routableKeyString != undefined)
		{
			setCookie('lastViewedScene',routableKeyString,180);
		}
		//window.location.assign("#"+getRoutableKeyString(type,chapter,episode))
	}
	
	function reRunWithNewOpcodes()
	{
		let lines = document.getElementById("DebugTextArea").value;
		//console.log(lines);
		let newStructuredLines = stringToStructuredLines(lines);
		console.log(newStructuredLines)
		currentEpisodeAsOpcodes[curEpisodePart] = newStructuredLines;
		if (game != undefined)
		{
			game.scene.remove('GirlsFrontlineScene');
			game.scene.add('GirlsFrontlineScene',GirlsFrontlineScene,true);
		}
	}
	
	function initPhaser()
	{
		game = new Phaser.Game(config);
		let button = document.getElementById("startButton")
		button.style.display = "none";
		document.getElementById("interactiveInterpreterSection").style.display="";
		//button.classList.add("disabled");
		//button.innerText = "started!"
		
	}
	
	/*function fancyDisplayThing()
	{
	
	}*/
	/*function reset()
	{
		game.restart()
	}*/
	
	function showOpcodes(divId) {
		let x = document.getElementById(divId);
		if (x.style.display === "none") {
			x.style.display = "block";
		} else {
			x.style.display = "none";
		}
	}
	
	
	function getRoutableKeyString(type,chapter,episode)
	{
		return type+'-'+chapter+'-'+episode
	}
	function getKeysFromRoutableString(s)
	{
		return s.split('-');
	}
	
	function onChapterSelected(value)
	{
		console.log(value);
		//let [type,chapter,episode] = getKeysFromRoutableString(value)
		runFromRoutableKeyString(value)
		if (game == undefined)
			document.getElementById("startButton").classList.remove('disabled');
	}
	function goToNextEpisode()
	{
		//To make it jump to the top
		window.location.assign("#theTop");
		
		let value = curEpKey;
		console.log(value);
		let [type,chapter,episode] = getKeysFromRoutableString(value)
		episode++;
		if (listOfChapters[type][chapter]['episodes'][episode])
		{
			runFromRoutableKeyString(getRoutableKeyString(type,chapter,episode))
			return true;
		}
		else
		{
			chapter++;
			episode = 0;
		}
		
		if (listOfChapters[type][chapter]['episodes'][episode])
		{
			runFromRoutableKeyString(getRoutableKeyString(type,chapter,episode))
			return true;
		}
		
		return false;
	}
	

	
	//I finally used a class, aren't you happy? 
	class FilterableList {
		constructor(data,keyToSearch,idToBind) {
			console.assert(data,"FilterableList: Data undefined!")
			this.data = data;
			this.fuse = new Fuse(data, {
				keys: [keyToSearch]
			})
			this.elementId = idToBind
			
			let el = document.getElementById(idToBind);
			el.innerHTML = "" //You shouldn't have anything in here in the first place
			
			
			let div = document.createElement('div');
			div.id = idToBind+'SearchDiv';
				let form = document.createElement('form');
				form.action = "?";
					let inputField = document.createElement('div');
					inputField.classList.add('input-field');
					inputField.style="text-align: left;";
						let i = document.createElement('i');
						i.classList.add("material-icons");
						i.classList.add('prefix');
						i.innerText="search";
						
						
						let input = document.createElement('input');
						input
						//input.onchange = function(ev) { console.log(ev); this.search(this) }
						input.setAttribute('onkeydown',"if (event.key == 'Enter') blur(); return;");
						input.addEventListener('change',this.search.bind(this) );
						input.id=idToBind+'search'
						input.type='search';
						input.onsubmit="blur()"
						input.required=true
						
					inputField.appendChild(i);
					inputField.appendChild(input);
					
				form.appendChild(inputField);
			div.appendChild(form);
			
			
			//Don't bother, none of it works anyways
			/*let inputFromDOM = document.getElementById(idToBind+'search');
			input.addEventListener('onkeyup',function() { console.log("aa") } );
			input.addEventListener('onkeydown',function() {if (event.key == 'Enter') blur(); return;})*/
			/*<form action="?">
				<div class="input-field" style="text-align: left;">
					<i class="material-icons prefix">search</i>
					<!--<label class="label-icon" for="search">
					</label>-->
					<input id="search" type="search" oninput="searchDolls(document.getElementById('search').value)" onkeydown="if (event.key == 'Enter') blur(); return;" onsubmit="blur()" required>
					
					<i class="material-icons" onclick="clearSearch()">close</i>
				</div>
			</form>*/
			
			el.appendChild(div);
			
			this.collection = document.createElement('div');
			this.collection.classList.add('collection');
			//this._li_=document.createElement('li');
			this._li_=document.createElement('a');
			this._li_.href="#theTop";
			this._li_.classList.add('collection-item');
			/*this._li_.classList.add('waves-effect');
			this._li_.classList.add('waves-light');
			this._li_.style="cursor:pointer;";*/
			
			el.appendChild(this.collection);
			
			this.generateResults(this.data);
		}
		
		//It's just like lua Kappa
		search()
		{
			console.assert(this)
			let query = document.getElementById(this.elementId+'search').value
			console.log(query);
			clearTimeout(this.delayTimer);
			this.delayTimer = setTimeout(function() {
				
				if (query == "" || query == undefined)
				{
					this.generateResults(this.data);
				}
				else
				{
					
					/*query = query.toLowerCase();
					console.log("Searching for "+query);*/
					
					var results = this.fuse.search(query);
					console.log("Got "+results.length + " results");
					//I don't care if it's slow
					this.generateResults(Array.from(results, r => r['item']));
				}
			}.bind(this), 300);
		}
		
		generateResults(results)
		{
			console.log(results);
			this.collection.innerHTML="";
			for (var i = 0; i < results.length; i++)
			{
				let li = this._li_.cloneNode(true);
				li.innerText=results[i]['name'];
				this.collection.appendChild(li);
			}
		}
		
	}
	
	//name field is structured like type-chapter-episode
	listOfChapters=false;
	
	function generateTables() {
		
		console.log(listOfChapters);
		//return listOfChapters;
		/*var _table_ = document.createElement('table'),
			_tr_ = document.createElement('tr'),
			_th_ = document.createElement('th'),
			_td_ = document.createElement('td'),
			_select_ = document.createElement('select'),
			_option_ = document.createElement('option');*/
		
		//var table = document.getElementById("table");
		//let thead = document.createElement("thead");
		//thead.innerHTML = "<tr><th colspan='"+listOfChapters.length+"'>Pick a chapter</th></tr>"
		//table.appendChild(thead);
		
		//Behold, the most god awful code ever written
		//let tbody = document.createElement('tbody');
		
		/*let trChapterNames = _tr_.cloneNode(false);
		for(i=0;i<listOfChapters.length;i++)
		{
			let td = _td_.cloneNode(false);
			td.appendChild(document.createTextNode(listOfChapters[i]['name']));
			trChapterNames.appendChild(td);
		}
		tbody.appendChild(trChapterNames);*/
		
		var _dropDownTrigger_ = document.createElement('a');
		_dropDownTrigger_.href = "#";
		_dropDownTrigger_.classList.add('dropdown-trigger');
		_dropDownTrigger_.classList.add('btn');
		
		var _dropDown_ = document.createElement('ul');
		_dropDown_.classList.add('dropdown-content');
		
		var _li_ = document.createElement('li'),
			_a_ = document.createElement('a');
		
		//No idea what this is supposed to do.
		_a_.href="#!";
		
		for (const key in listOfChapters)
		{
			//console.log(key)
			let episodeContainer = document.getElementById(key+'Episodes')
			//let trChapterDropdowns = _tr_.cloneNode(false);
			//let trChapterDropdowns = 
			for(i=0;i<listOfChapters[key].length;i++)
			{
				//let td = _td_.cloneNode(false);
				let flexBoxDiv = document.createElement('div');
				/*let select = _select_.cloneNode(false);
				select.setAttribute('id',"selectChapter"+i)
				select.setAttribute('onchange','onChapterSelected(value);');*/
				let dropDownTrigger = _dropDownTrigger_.cloneNode(true)
				dropDownTrigger.setAttribute('data-target','dropdown-'+key+'-'+i)
				dropDownTrigger.innerText=listOfChapters[key][i]['name']
				
				let dropdown = _dropDown_.cloneNode(true);
				dropdown.id = 'dropdown-'+key+'-'+i;
				
				//Generate chapter name first..
				/*let optChName = _option_.cloneNode(false);
				optChName.setAttribute("selected","");
				optChName.setAttribute("disabled","");
				optChName.innerText=listOfChapters[key][i]['name'];
				select.appendChild(optChName);*/
				
				//Now let's do the episodes
				let curChapter = listOfChapters[key][i]['episodes'];
				for(j=0;j<curChapter.length;j++)
				{
					
					let ep = _li_.cloneNode(true);
					ep.innerHTML = "<a href='#"+getRoutableKeyString(key,i,j)+"' onclick=\"onChapterSelected('"+getRoutableKeyString(key,i,j)+"')\">"+curChapter[j]['name']+"</a>"
					dropdown.appendChild(ep);
					/*let option = _option_.cloneNode(false);
					option.value=getRoutableKeyString(key,i,j)
					option.innerText=curChapter[j]['name'];
					select.appendChild(option);*/
				}
				//flexBoxDiv.appendChild(select);
				flexBoxDiv.appendChild(dropDownTrigger);
				flexBoxDiv.appendChild(dropdown);
				
				episodeContainer.appendChild(flexBoxDiv);
				//td.appendChild(select);
				//trChapterDropdowns.appendChild(td);
			}
		}
		
		//test = new FilterableList(listOfChapters['side'][0]['episodes'],'name',"sideEpisodesWrapper")

		//tbody.appendChild(trChapterDropdowns);
		
		//table.appendChild(thead);
		//table.appendChild(tbody);
		
	}
	
	//materialize.js makes it irrelevant
	/*function showSelectedEpisodes(id)
	{
		let episodesDivs = document.getElementById("Episodes").children;
		for (var i = 0; i < episodesDivs.length;i++){
			if (episodesDivs[i].id == id)
				episodesDivs[i].style="";
			else
				episodesDivs[i].style="display: none;"
		}
		//console.log(episodesDiv.children);
	}*/
	
	//T-Doll search shit
	let frontlinedex = null;
	let CharacterVoice = null;
	
	let dialogueKeysToEnglish = {
		'dialogue1':"Adjutant 1",
		'dialogue2':"Adjutant 2",
		'dialogue3':"Adjutant 3",
		'soulcontract':"Marriage Line",
		'introduce':"Introduction (In the index, but usually identical to obtain)",
		'gain':'When Obtained',
		'allhallows':"During Halloween",
		'christmas':"During Christmas",
		'valentine':"During Valentine's",
		'dialoguewedding':"Adjutant 4 (After Marriage)"
	}
	
	function TDollInfo(dollName)
	{
		/*console.log(dollName);
		console.assert(CharacterVoice)
		console.log(CharacterVoice);*/
		//Destroy everything in here
		let tDollDialogue = document.getElementById('tDollDialogue')
		tDollDialogue.innerHTML = "";
		/*let ul = document.createElement("ul");
		ul.className = 'collapsible'*/
		let _div_ = document.createElement('div');
		_div_.classList.add("card");
		let _cardContent = document.createElement('div');
		_cardContent.classList.add("card-content");
		let dialogue = CharacterVoice[dollName];
		if (dialogue)
		{
			Object.keys(dialogue).forEach(key => {
				let card = _div_.cloneNode(true);
				let cardContent = _cardContent.cloneNode(true);
				let cardTitle = document.createElement('span');
				cardTitle.classList.add('card-title');
				if (dialogueKeysToEnglish[key])
					cardTitle.innerText = dialogueKeysToEnglish[key];
				else
					cardTitle.innerText = key;
				let p = document.createElement('p');
				//console.log(typeof dialogue[key]);
				p.innerHTML= dialogue[key].join([separator = '<br>'])
				cardContent.appendChild(cardTitle);
				cardContent.appendChild(p);
				card.appendChild(cardContent);
				tDollDialogue.appendChild(card);
			});
			
			
			document.getElementById('tDollDialogueName').firstChild.textContent=dollName;
			//document.getElementById('tDollDialogueName').setAttribute('href',"#tDollSearch"+dollName)
			M.Modal.getInstance(document.getElementById('tDollDialogueActivity')).open()
			//jump to top of page
			//window.location.href="#tDollDialogueActivity"
		}
		else
		{
			//console.log("aa");
			M.toast({html: "T-Doll "+dollName+" not present in json..."})
		}
		//document.getElementById('tDollDialogue').appendChild(_div_);
	}
	
	function listResults(results)
	{
		//console.log(results);
			/*<li class="collection-item avatar">
		  <img src="images/yuna.jpg" alt="" class="circle">
		  <span class="title">Title</span>
		  <p>First Line <br>
		     Second Line
		  </p>
		  <a href="#!" class="secondary-content"><i class="material-icons">grade</i></a>
		</li>*/
		//Destroy everything inside the div.
		document.getElementById("SearchResultsDiv").innerHTML = "";
		var ul = document.createElement("ul");
		ul.className= "collection";
		ul.id = "SearchResults";
		for (var i=0, n=results.length; i<n; ++i)
		{
			//let result = frontlinedex[results]
			var li = document.createElement("li");
			li.className = "collection-item avatar waves-effect"; //waves-effect waves-light
			li.style.display = '';
			
			
			var icon = document.createElement("i");
			icon.className = "material-icons circle red";
			li.appendChild(icon);
			
			var span = document.createElement("span");
			span.className = "title";
			span.innerText = results[i].name;
			li.appendChild(span);
			
			var p = document.createElement("p");
			p.innerHTML = results[i].type + " <br> No." + (results[i].num>0 ? results[i].num : "?");
			li.appendChild(p);
			
			//You're probably gonna say this is terrible and blah blah but T-Doll names are unique anyways
			/*for (var j =0; j < frontlinedex.length;j++)
			{
				
			}*/
			if (results[i].internalName)
			{
				li.setAttribute("onclick","TDollInfo(\""+results[i].internalName+"\")")
				li.id = "tDollSearch"+results[i].internalName
			}
			
			
			//Handle stars
			var secondaryContent = document.createElement("div");
			secondaryContent.className = "secondary-content";
			num2stars(secondaryContent,results[i].rating)
			li.appendChild(secondaryContent);
			
			ul.appendChild(li);
		}
		
		document.getElementById("SearchResultsDiv").appendChild(ul);
	}
	
	var delayTimer;
	function searchDolls(query)
	{
		clearTimeout(delayTimer);
		delayTimer = setTimeout(function() {
			
			if (query == "" || query == undefined)
			{
				listResults(frontlinedex);
			}
			else
			{
				
				query = query.toLowerCase();
				/*for (var i=0, n=frontlinedex.length; i<n; ++i)
				{
					if ('alias' in frontlinedex[i] && query == frontlinedex[i]['alias'].toLowerCase())
					{
						console.log("Found alias for "+frontlinedex[i]['name']);
						//console.log(frontlinedex[i]);
						listResults([frontlinedex[i]]);
						return true;
					}
				}*/
				console.log("Searching for "+query);
				
				var results = fuse.search(query);
				console.log("Got "+results.length + " results");
				//I don't care if it's slow
				listResults(Array.from(results, r => r['item']));
			}
		}, 300);
	}
	
	function FetchTDollInfo()
	{
		if (frontlinedex != null && CharacterVoice != null)
			return;
		fetch("girlsfrontline-min.json")
		.then(response => response.json())
		.then(json => {
			console.log("girlsfrontline-min loaded!");
			console.log(json);
			
			frontlinedex = json;
			
			/*fetch("gf_flavortext.json").then(response => response.json()).then(json2 => {
				console.log("Bonus information loaded.");
				console.log("Injecting aliases and quotes...");
				bonusdex = json2;
				frontlinedex.forEach(doll => {
					if (doll['name'] in bonusdex)
					{
						if ('alias' in bonusdex[doll['name']])
							doll['alias'] = bonusdex[doll['name']]['alias']
					}
				})
				console.log("Done.");
			});*/
			
			fuse = new Fuse(frontlinedex, {
				keys: ['name']
			})
			//fuse = new Fuse(Object.keys(frontlinedex));
			

			
			listResults(frontlinedex);
		});
		
		fetch('CharacterVoicePlus.json')
		.then(response => response.json())
		.then(json => {
			console.log("NewCharacterVoice.json loaded!");
			CharacterVoice = json;
		});
	}
	
	MissingPortraits = null;
	function FetchMissingPortraitDB()
	{
		if (MissingPortraits != undefined)
			return
		fetch('missingPortraits.json')
		.then(response => response.json())
		.then(json => {
			console.log("missingPortraits.json loaded!");
			console.log(json);
			MissingPortraits = json;
			let stuff = document.getElementById("helpInterpreterChapters");
			
			let ul = document.createElement('ul');
			ul.classList.add('collapsible')
			let li = document.createElement('li');
			li.style="text-align:left"
			let collapsible_header = document.createElement("div");
			collapsible_header.classList.add('collapsible-header');
			let collapsible_body = document.createElement('div');
			collapsible_body.classList.add('collapsible-body');
			collapsible_body.classList.add('collection');
			
			let collectionItem = document.createElement('a');
			collectionItem.classList.add('collection-item');
			for (const key in MissingPortraits)
			{
				let thisSection = li.cloneNode(true);
				let sectionTitle = collapsible_header.cloneNode(true)
				sectionTitle.innerHTML='<i class="material-icons">expand_more</i>'+key;
				thisSection.appendChild(sectionTitle)
				
				let sectionData = collapsible_body.cloneNode(true)
				for (const epName in MissingPortraits[key])
				{
					let item = collectionItem.cloneNode(true)
					item.innerText = epName
					item.href="#"+MissingPortraits[key][epName];
					item.setAttribute("onclick","onChapterSelected('"+MissingPortraits[key][epName]+"'); document.getElementById('chapterName').scrollIntoView()")
					sectionData.appendChild(item)
				}
				thisSection.appendChild(sectionData)
				ul.appendChild(thisSection);
			}
			stuff.innerHTML = ""
			stuff.appendChild(ul)
			
			//I'm lazy, so deal with it
			document.querySelectorAll('.collapsible').forEach(el => {
				var instance = M.Collapsible.init(el, null);
			});

			//
			
		});
	}
	
	
	//Keep this at the bottom
	window.onload=function()
	{
		setCheckboxFromCookie('fancyOrNot',true);
		//setCheckboxFromCookie('inlineText',false);
		setCheckboxFromCookie('advancedCSS',true);
		setCheckboxFromCookie('showInteractiveInterpreter',false);
		hideInterpreterButton();
		setCheckboxFromCookie('showDebugOpcodeButton',false);
		setCheckboxFromCookie('chapterHistoryRouting',true);
	
		fetch('chapterDatabase.json')
		.then(response => response.json())
		.then(json => {
			console.log("cutscene information loaded!");

			listOfChapters = json['story'];
			MUSIC = json['music'];
			BACKGROUNDS = json['bg'];
			
			generateTables();
			document.querySelectorAll('.dropdown-trigger').forEach(elems => {
				var instances = M.Dropdown.init(elems, {constrainWidth:false});
			});
			
			//Can't run until chapters are loaded
			if (document.getElementById('chapterHistoryRouting').checked)
			{
				let [type,chapter,episode] = getKeysFromRoutableString(window.location.hash.slice(1))
				if (type && chapter && episode && listOfChapters[type][chapter]['episodes'][episode])
					runFromRoutableKeyString(window.location.hash.slice(1));
				else
					runFromRoutableKeyString(getCookie('lastViewedScene'));
			}
		});
		
		document.querySelectorAll('.tabs').forEach(el => {
			var instance = M.Tabs.init(el, null);
			//instance.updateTabIndicator();
		});
		
		/*document.querySelectorAll('.dropdown-trigger').forEach(elems => {
			var instances = M.Dropdown.init(elems, {constrainWidth:false});
		});*/
		
		 
		document.querySelectorAll('.collapsible').forEach(elems => {
			var instances = M.Collapsible.init(elems, null);
		});
		
		document.querySelectorAll('.modal').forEach(el => {
			var instance = M.Modal.init(el, null);
			//instance.updateTabIndicator();
		});
		
		fetch('portraitInformation.json')
			.then(response => response.json())
			.then(json => {
				console.log("portraitinformation.json loaded!");
				PORTRAITS = json;
			});
		
		// Select the button
		//const btn = document.querySelector(".nightMode-toggle");
		// Check for dark mode preference at the OS level
		const prefersDarkScheme = window.matchMedia("(prefers-color-scheme: dark)");
		// Get the user's theme preference from local storage, if it's available
		//const currentTheme = localStorage.getItem("theme");
		const currentTheme = getCookie('theme');
		//print(currentTheme);


		// If the user's preference in localStorage is dark...
		if (currentTheme == "")
		{
			document.body.classList.toggle(prefersDarkScheme ? "dark-theme" : "light-theme")
			setCookie('theme',prefersDarkScheme ? "dark-theme" : "light-theme",180);
		}
		else if (currentTheme == "black-theme") {
			document.body.classList.toggle("black-theme");
			isDarkMode=true
		}
		else if (currentTheme == "dark-theme") {
		  // ...let's toggle the .dark-theme class on the body
		  document.body.classList.toggle("dark-theme");
		  isDarkMode=true
		// Otherwise, if the user's preference in localStorage is light...
		} else {
		  // ...let's toggle the .light-theme class on the body
		  document.body.classList.toggle("light-theme");
		  isDarkMode=false;
		}
		
		document.getElementById("textarea1").value = `portrait;0;FAIL;0;false;false;
speaker;El Fail
bgm;intro_number_61
bg;140
msg;Hello world!
msg;<color=#00CCFF>This is</color> <color=#FF00AA>colored text.</color>
msg;<size=50>This is sized text.</size>
msg;<size=60>This is even bigger text.</size>
msg;As you can see, this section is still a work in progress. So you should probably check back later.
portrait;0;FAIL;0;true;false;
portrait;1;NytoIsomer;4;false;false;
speaker;Dandelai;
msg;<color=#1aff1a>Make sure you save your work in a text file, as it will not be saved here.</color>`
	}
	
	function setCheckboxFromCookie(idOfCheckbox,defaultValueIfNotSet)
	{
		let c = getCookie(idOfCheckbox);
		if (c==undefined || c=="")
		{
			//Cookies can only be strings
			c=defaultValueIfNotSet.toString();
			setCookie(idOfCheckbox,defaultValueIfNotSet,180);
		}
		//console.assert(c);
		console.assert(document.getElementById(idOfCheckbox),"no element named "+idOfCheckbox)
		console.log("Setting "+idOfCheckbox+" to "+c);
		document.getElementById(idOfCheckbox).checked = (c=='true');
	}
	function setCookieFromCheckbox(idOfCheckbox)
	{
		setCookie(idOfCheckbox,document.getElementById(idOfCheckbox).checked,180);
	}
	
	function hideInterpreterButton()
	{
		if (!document.getElementById('showInteractiveInterpreter').checked)
		{
			document.getElementById("startButton").style="display:none"
		}
		else
		{
			document.getElementById("startButton").style=""
		}
	}


	
</script>
<body>
  <nav class='nav-extended'>
    <div class="nav-wrapper" id='theTop' style="overflow:hidden;">
      <a href="#" class="brand-logo center" style="text-overflow: ellipsis; white-space: nowrap;">
      	<span class='header-desktop'>GFL Cutscene Interpreter (beta)</span>
      	<span class='header-desktop-shorter'>GFL Cutscene Interpreter</span>
      	<span class='header-mobile'>GFL C.I.</span>
      	
	</a>
	
      <ul id="nav-mobile" class="right">
        <li><a onclick="NightMode()" class="waves-effect waves-light navbarButton"><i class="material-icons left">brightness_2</i><span class='header-desktop'>Night Mode</span></a></li>
        <li><a href="#settingsModal" class="waves-effect waves-light modal-trigger navbarButton"><i class="material-icons left">settings</i><span class='header-desktop'>Settings</span></a></li>
      </ul>
    </div>
			<div class="col s12 nav-content">
				<ul class="tabs tabs-transparent">
					<li class="tab col s3"><a href="#mainEpisodesWrapper">Main Story Chapters</a></li>
					<li class="tab col s3"><a href="#eventEpisodesWrapper">Story Events</a></li>
					<li class="tab col s3"><a href="#sideEpisodesWrapper">Side Stories</a></li>
					<li class="tab col s3"><a href="#crossoverEpisodesWrapper">Crossover Stories</a></li>
					<li class="tab col s3"><a href="#helpInterpreter" onclick="FetchMissingPortraitDB()">Help the interpreter</a></li>
					<li class="tab col s3"><a href="#TDollStuff" onclick="FetchTDollInfo()">T-Doll Dialogue (WIP)</a></li>
					<li class="tab col s3"><a href="#customCutsceneWrapper">Write your own cutscene (WIP)</a></li>
				</ul>
			</div>
  </nav>

	<!-- Modal Structure -->
	<div id="settingsModal" class="modal">
		<div class="modal-content">
		<h4>Settings</h4>

		<table class="material-settings-table">
			<tr>
				<td style="width:100%">
					<span class="title">Display images and portraits in cutscenes</span>
					<p>Turn it off if you want to save your mobile data.</p>
				</td>
				<td>
					<div class="switch">
						<label>
						  <input type="checkbox" onclick="setCookieFromCheckbox('fancyOrNot'); runFromRoutableKeyString()" id="fancyOrNot">
						  <span class="lever"></span>
						</label>
					</div>
				</td>
			</tr>
			<!--<tr>
				<td style="width:100%">
					<span class="title">Inline Text</span>
					<p>Make the text display on top of the image.</p>
				</td>
				<td>
					<div class="switch">
						<label>
						  <input type="checkbox" onclick="setCookieFromCheckbox('inlineText'); runFromRoutableKeyString()" id="inlineText">
						  <span class="lever"></span>
						</label>
					</div>
				</td>
			</tr>-->
			<tr>
				<td style="width:100%">
					<span class="title">Advanced CSS Effects</span>
					<p>Enable more demanding effects like snow animations. It might lag on mobile devices.</p>
				</td>
				<td>
					<div class="switch">
						<label>
						  <input type="checkbox" onclick="setCookieFromCheckbox('advancedCSS'); runFromRoutableKeyString()" id="advancedCSS">
						  <span class="lever"></span>
						</label>
					</div>
				</td>
			</tr>
			<tr>
				<td style="width:100%">
					<span class="title">Show interactive interpreter button</span>
					<p>It doesn't work well and not every browser supports it. You probably want to keep this disabled.<br>(Interpreter v2 coming eventually I swear)</p>
				</td>
				<td>
					<div class="switch">
						<label>
						  <input type="checkbox" id="showInteractiveInterpreter" onclick="setCookieFromCheckbox('showInteractiveInterpreter'); hideInterpreterButton()">
						  <span class="lever"></span>
						</label>
					</div>
				</td>
			</tr>
			<tr>
    			<td style="width:100%">
    				<span class="title">Last chapter history</span>
    				<p>Upon reloading the page, returns you to the last viewed cutscene by using cookies. Having a routing string in your url bar (ex. #crossover-4-1) will override this. </p>
    			</td>
    			<td>
					<div class="switch">
						<label>
						  <input type="checkbox" id="chapterHistoryRouting" onclick="setCookieFromCheckbox('chapterHistoryRouting')">
						  <span class="lever"></span>
						</label>
					</div>
				</td>
			</tr>
			<tr>
				<td style="width:100%">
					<span class="title">Debug Mode</span>
					<p>Displays buttons for showing debug opcodes in cutscenes and warns if a portrait is missing. You probably don't want this enabled.</p>
				</td>
				<td>
					<div class="switch">
						<label>
						  <input type="checkbox" id="showDebugOpcodeButton" onclick="setCookieFromCheckbox('showDebugOpcodeButton')">
						  <span class="lever"></span>
						</label>
					</div>
				</td>
			</tr>
		</table>
		</div>
		<div class="modal-footer">
		  <a class="modal-close waves-effect waves-green btn-flat">Close</a>
		</div>
	</div>
	<!-- Needs to be here so the modal for T-Doll search will be fullscreen on mobile devices. Otherwise it will be below the navbar.-->
	<div id="tDollDialogueActivity" class="modal modal-fixed-footer" style="overflow:hidden">
		<nav style="position:initial;">
			<div class="nav-wrapper blue" style="text-align: left;">
			  <a href="#!" class="brand-logo modal-close" id='tDollDialogueName'>Insert T-Doll Name Here<i class="material-icons">arrow_back</i></a>
			</div>
		</nav>
		<div id="tDollDialogue" class='modal-content'>
		
		</div>
	</div>
  
	<noscript><h1>Turn on JavaScript. This is not a static webpage, it is literally interpreting the GFL text on the fly using JS and rendering it to HTML elements to display it in your browser.</h1></noscript>
	<noscript><h3>Static HTTP pages are coming never. You'll have to look at the source code and write it yourself.</h3></noscript>
	<div id='chapterSelect' class='navbar-fixed'>
		<div class='row'>
			<!--<a href=#modal1" class="modal-trigger" >Settings</a>-->

			<!--Because materialize.js is stupid -->
			<div class="col s12" id="mainEpisodesWrapper">
				<div class="flex-container col s12" id="mainEpisodes"></div>
			</div>
			
			<div class="col s12" id="eventEpisodesWrapper">
				<div class="flex-container col s12" id="eventEpisodes"></div>
			</div>
			<div class="col s12" id="sideEpisodesWrapper">
				<div class="flex-container col s12" id="sideEpisodes"></div>
			</div>
			<div class="col s12" id="crossoverEpisodesWrapper">
				<div class="flex-container col s12" id="crossoverEpisodes"></div>
			</div>
			<div class="col s12" id="helpInterpreter">
				  <div class="card blue-grey darken-1" style="text-align:left">
					<div class="card-content white-text">
					  <span class="card-title">Help fix missing portraits!</span>
					  <p>Portraits have to be entered into the database manually if they don't follow a standardized naming scheme. (Which is something MICA likes to do a lot.)</p>
					  <p>You can help fix missing portraits faster by checking the cutscenes ingame, comparing it with the interpreter, and emailing me a screenshot along with ID and type of the missing portrait.</p>
					  <p><b>Turn on debug mode</b> in interpreter settings to see the exact ID and type of a missing portrait. It will show <b>above</b> the cutscene box.</p>
					  <p>My email is at the bottom of the page.</p>
					</div>
				  </div>
				<h3>Chapters With Missing Portraits</h3>
				<div id="helpInterpreterChapters">
				
					<div class="progress">
					  <div class="indeterminate"></div>
					</div>
				</div>
				<!--<div class="card blue-grey darken-1" style="text-align:left">
					<div class="card-content white-text">
					  <span class="card-title">Help add size tag!</span>
					  <p>I don't know what the size tag ratio is. So send me screenshots where tag is used.</p>
					  <p>You can help fix missing portraits faster by checking the cutscenes ingame, comparing it with the interpreter, and emailing me a screenshot along with ID and type of the missing portrait.</p>
					  <p><b>Turn on debug mode</b> in interpreter settings to see the exact ID and type of a missing portrait. It will show <b>above</b> the cutscene box.</p>
					  <p>My email is at the bottom of the page.</p>
					</div>
				</div>-->
				<hr>
			</div>
			<div class="col s12" id="TDollStuff">
				<!--I don't know how to do iframes or AJAX, apparently-->
				<!--<iframe src="quoteBrowser.html"></iframe>-->

				<div id="tDollSearchActivity">
					<form action="?">
					<div class="input-field" style="text-align: left;">
						<i class="material-icons prefix">search</i>
						<!--<label class="label-icon" for="search">
						</label>-->
						<input id="search" type="search" oninput="searchDolls(document.getElementById('search').value)" onkeydown="if (event.key == 'Enter') blur(); return;" onsubmit="blur()" required>
						
						<i class="material-icons" onclick="clearSearch()">close</i>
					</div>
					</form>
					
					<div id="SearchResultsDiv"  class="" >
						<p>If you are seeing this it's still loading, please wait 1 second for the JSON to load</p>
						<p>Either that or your browser is broken, please check for an update.</p>
						<div class="progress">
						  <div class="indeterminate"></div>
						</div>
		    
					</div>
				</div>
			</div>
			<div class="col s12" id="customCutsceneWrapper">
				<div id="customCutscene">
					<p>WORK IN PROGRESS - IGNORE THE TERRIBLE UI</p>
					<p>These buttons don't do anything yet, but you can type in the textbox below and run your custom cutscene.</p>
					<a class="waves-effect waves-light btn" onclick="document.getElementById('file-input-txt').click();"><i class="material-icons right">folder_open</i>Load .txt</a>
					<a class="waves-effect waves-light btn" onclick="document.getElementById('file-input-json').click();"><i class="material-icons right">folder_open</i>Load .iop.json</a>
					<input id="file-input-txt" type="file" name="name" style="display: none;" />
					<input id="file-input-json" type="file" name="name" style="display: none;" />
			        <!--<div class="input-field col s12">
						<textarea id="textarea1" class="materialize-textarea"></textarea>
						<label for="textarea1">Textarea</label>
					</div>-->
					<textarea id="textarea1" class="materialize-textarea"></textarea>
					<a class="waves-effect waves-light btn" onclick="runFromUserInput();"><i class="material-icons right">code</i>Run!</a>
				    <div class="card blue-grey darken-1" style="text-align:left">
        				<div class="card-content white-text">
						<span class="card-title">About .txt vs .iop.json</span>
						<p>.txt is the cutscene scripting language GFL uses. The interpreter will always support importing .txt and playing it back.</p>
						<p>.iop.json (<b>I</b>ntermediate <b>Op</b>codes, definitely not a coincidence) is the scripting language designed for the interpreter. It has some advantages compared to the GFL engine:</p>
						<p>- Display more than two characters at a time. Dim multiple charcters. Dim no characters.</p>
						<p>- Dimming doesn't randomly break, because dimming is manually set. </p>
						<p>- The commands are in english. It's also very verbose.</p>
						<p>- You can use + in messages. (GFL's txt script treats + as 'next line')</p>
						<p>- (Coming soon) branch paths, allowing you to use the interpreter like a VN engine of sorts and write interactive stories</p>
						<p>- Load multiple parts, since the only reasonable way to have more than one part would be to use JSON.</p>
						<p>The disadvantages:</p>
						<p>- The verbosity will make you type a lot.</p>
						<p>- Since dimming is manually done, it might get confusing.</p>
						<p>- Good luck memorizing all 5 arguments for a message opcode.</p>
						</div>
					</div>
					<div class="card blue-grey darken-1" style="text-align:left">
        				<div class="card-content white-text">
							<span class="card-title">How to specify a background?</span>
							<p>Backgrounds are stored in the avgtexture folder and indexed in-game with profiles.txt.</p>
							<p>As displaying every single image would be disasterous and I only have about 500GB of bandwidth per month on this webserver, please click the link below to show an image of all the backgrounds with IDs arranged in a neat grid.</p>
						</div>
						<div class="card-action">
							<a href="#">BG picker helper (Jk it doesn't exist yet)</a>
						</div>
					</div>
					<div class="card blue-grey darken-1" style="text-align:left">
        				<div class="card-content white-text">
							<span class="card-title">How to specify a portrait?</span>
							<p>Portraits are in the format of: idx;name;type;dim;isMasked</p>
							<p>Arguments 4 and 5 can be omitted, they will automatically be converted to false.<p>
							<p>idx - Which side. 0 for left, 1 for right. (indexes above 1 are not supported currently)</p>
							<p>name - The internal name of the T-Doll. Hint: Ctrl+F portraitInformation.json</p>
							<p>type - Usually costume, sometimes expression</p>
							<p>dim (optional) - true for dim, false for not dim</p>
							<p>isMasked (optional) - like dim</p>
						</div>
						<div class="card-action">
							<a href="/portraitInformation.json">portraitInformation.json</a>
						</div>
					</div>
					<div class="card blue-grey darken-1" style="text-align:left">
        				<div class="card-content white-text">
							<span class="card-title">How to specify music?</span>
							<p>Music is just the filename.</p>
							<p>The file index is enabled. Click the button to see all the files.</p>
							<p>Alternatively you can use the dropdown and it will paste a bgm command at the end. As it is still WIP and has to be updated manually, you're better off using the index.</p>
						</div>
						<div class="card-action">
							<a href="/audio">Index</a>
							<a href="#" class='dropdown-trigger' data-target='dropdownMusic'>Select by name</a>
						</div>
					</div>
					  <!-- Dropdown Structure -->
					  <ul id='dropdownMusic' class='dropdown-content'>
						<li><a href="#!">one</a></li>
						<li><a href="#!">two</a></li>
					  </ul>
					<!--<ul class="collapsible">
						<li>
						  <div class="collapsible-header">About .txt vs .iop.json</div>
						  <div class="collapsible-body"></div>
						</li>
					</ul>-->
				</div>
			</div>
				
		</div>
		
	</div>
	
	<h2 id="chapterName" style="display:inline">Chapter Name Here</h2>
	<!--<a onclick="copyLink()" class="waves-effect waves-light btn">Copy chapter link</a>-->
    <a id="startButton" onclick="initPhaser()" class="waves-effect waves-light btn disabled">Start interactive interpreter (It's like playing the game!)</a>
	<div id="interactiveInterpreterSection" style="display:none;">
		<a id='stopButton' class="waves-effect waves-light btn"> Stop the interpreter (You'll have to refresh the site to start it up again, sorry)</a>
		<p id="curIndexDebug"></p>
		<div id="phaser"></div>
		<!--This is for phaser only!-->
		<br><br><button onclick="showOpcodes('myDIV')">Show converted opcodes (For debugging)</button><br>
		<div id='myDIV' style="display: none;">
			<textarea rows='6' cols='50' id="DebugTextArea"></textarea><br>
			<button onclick="reRunWithNewOpcodes()">Re-run scene with these opcodes</button>
		</div>
	</div>

	<hr>

	<div id="verySimpleText"></div>
	<a class="waves-effect waves-light btn" onclick="document.getElementById('theTop').scrollIntoView()"><i class="material-icons left">vertical_align_top</i>Back to top</a> <a class="waves-effect waves-light btn" onclick="goToNextEpisode();"><i class="material-icons left">chevron_right</i>Go to the next cutscene</a>
	<hr>
	<audio controls loop id="audioPlayer">
		<source src="" type="audio/ogg"> <!-- Turns out putting something in makes firefox load it when you load the page, wasting bandwidth. But leaving it blank is fine. -->
		Your browser does not support the audio tag.
	</audio>
	<p>Dandelion is my wife, greets to /gfg/, <a href="https://github.com/RhythmLunatic/gfl-cutscene-interpreter">harass me on github (bug reports, check the source code, fork it)</a></p>
	<!--<p>If you would like an improved UI, fix it yourself and submit a pull request. I don't know React/Vue/etc.</p>-->
	<p>If you want a feature or something is broken, <b><a href="https://github.com/RhythmLunatic/gfl-cutscene-interpreter/issues">file a bug report</a></b> or <a onmousemove="(function(self){self.href='mailto:kirbyrulez'+String.fromCharCode(64)+'att.net'})(this)" href="mailto:'hover mouse over the link twice to pass the bot check'"><b>email me</b></a></p>
	<p><a href='/LICENSE.html'>The interpreter is free and open source software and licensed under AGPLv3.</a></p>
	<p><a href='https://github.com/MatheusAvellar/textarea-line-numbers'>Textarea line numbers</a> by MatheusAvellar. Some modifications made for modifying elements directly instead of through ID.</p>
	<br>
	<!--<a href="https://github.com/RhythmLunatic/Girls-Frontline-Discord-Search">Try out my Girls' Frontline discord bot. T-Doll info, quotes, costumes, and more!</a>-->
</body>
