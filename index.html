<!doctype html>
<head>
	<meta charset="utf-8"/>
	<title>GFL cutscene interpreter</title>
	
	<!--For discord description -->
	<meta property="og:title" content="Girls' Frontline Cutscene Interpreter" />
	<meta property="og:type" content="website" />
	<meta property="og:url" content="http://gfl.amaryllisworks.pw" />
	<!--<meta property="og:image" content="http://my.site.com/images/thumb.png" />-->
	<meta property="og:description" content="Play back cutscenes in the browser" />
    <!--Let browser know website is optimized for mobile-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
	
	<!--Resources -->
	<link rel="preconnect" href="https://fonts.gstatic.com">
	 <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500&display=swap" rel="stylesheet">  
	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
	<!--<link type="text/css" rel="stylesheet" href="materialize.css"  media="screen,projection"/>-->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
	
	<link rel="stylesheet" type="text/css" href="./tln.css"/>
	<script type="text/javascript" src="./tln.js"></script>
</head>
<style type="text/css">
body
{
	/*background-color: black;
	color: white*/
	text-align:center;
	--bg-color: white;
	--text-color: black;
	--nav-color: #ee6e73;
	--btn-color: #26a69a;
	--card-color: #fff;
	--collection-item-color:#fff;
	--dropdown-text-color:#26a69a;
	--dropdown-hover-color:#eee;
	--settings-row-border-color: rgba(0, 0, 0, 0.12);
	
	background-color: var(--bg-color);
	color: var(--text-color);
}

body.dark-theme{
	--bg-color: #333333;
	--text-color: white;
	--nav-color:#1a237e;
	--btn-color: #26a69a;
	--card-color: #455a64;
	--collection-item-color:#2b2b2b;
	--dropdown-text-color: white;
	--dropdown-hover-color: black;
	
	--settings-row-border-color: rgba(255, 255, 255, 0.5);
}
body.black-theme{
	--bg-color: black;
	--text-color: white;
	--nav-color: #212121;
	--btn-color: #455a64;
	--card-color: #2e3436;
	--collection-item-color: black;
	--dropdown-text-color: white;
	--dropdown-hover-color: black;
	
	--settings-row-border-color: rgba(255, 255, 255, 0.8);
}

nav {
	background-color: var(--nav-color);
}
textarea{
	color:var(--text-color);
}
input{
	color:var(--text-color);
}
.textarea-wrapper{
	/*border:1px solid red;*/
	position:relative;
	height:500px;
	width:700px;
	margin:15px auto
}
/*.textarea-wrapper::before {
	content:"wrapper";
	text-transform: uppercase;
	left:0px;
	position:absolute;
	top:-18px;
	font-size:16px;
	color:red;
}*/

/*table, th, td {
   border: 1px solid #222222;
   border-collapse: collapse;
}
th {
	background-color: purple;
}*/

.header-desktop{
	display: inline-block;
}
.header-desktop-shorter{
	display: none;
}
.header-mobile{
	display: none;
}

@media screen and (max-width: 900px) {
    .header-desktop{
       display:none;
    }
    
    .header-desktop-shorter{
       display:inline-block;
    }
    .navbarButton{
    	padding: 0 5px; /*Since text is hidden, remove the padding between buttons*/
    }
    
    .modal {
    	width:100%;
    	max-height:100%;
    	height:100%;
    	top:0 !important;
    }
    .modal.modal-fixed-footer{
    	height:100%;
    }
}
@media screen and (max-width: 500px) {
    .header-desktop{
       display:none;
    }
    .header-desktop-shorter{
       display:none;
    }
    
    .header-mobile{
       display:inline-block;
    }
}

.btn {
	background-color: var(--btn-color);
}
.card {
	background-color: var(--card-color);
}
.modal {
	background-color: var(--bg-color);
	/* sadly animating 'top' breaks the modal showing */
	transition: width 0.2s ease-out, height 0.2s ease-out;
}
.collection .collection-item{
	background-color: var(--collection-item-color)
}
.dropdown-content{
	background-color: var(--card-color);
}
.dropdown-content li > a {
	color: var(--dropdown-text-color);
}
.dropdown-content li:hover, .dropdown-content li.active {
  background-color: var(--dropdown-hover-color);
}

/*Something I actually wrote myself*/
.material-settings-table {
	padding: 0px;
}
.material-settings-table td {
	padding: 0px;
}
.material-settings-table p {
	margin: 0px;
}
.material-settings-table tr {
	border-bottom-color: var(--settings-row-border-color);
}

.material-settings-table .title {
	font-weight: bold;
	font-size:120%
}
#settingsModal .modal-footer {
	background-color: rgba(128,128,128,0.3);
}
#settingsModal .modal-footer > a {
	color: var(--text-color);
}

/*#head, #foot {
	height: 6%;
	min-height: 25px;
	width: 100%;
	background-color: #151515;
	overflow: hidden;
}

#head a {
  float: left;
  color: #f2f2f2;
  text-align: center;
  padding: 14px 16px;
  text-decoration: none;
  font-size: 17px;
}


#head a:hover {
  background-color: #ddd;
  color: black;
}

#head a.active {
  background-color: #4CAF50;
  color: white;
}*/

.tabs {
    display:-webkit-flex;
    display: -ms-flexbox;
    display: flex
}




.flex-container {
  display: flex;
  flex-wrap: wrap;
  /*background-color: DodgerBlue;*/
  justify-content: center;
  align-items: center;
}

.flex-container > div {
  background-color: #f1f1f1;
  margin: 5px;
  /*padding: 20px;
  font-size: 30px;*/
}

/*tr:nth-child(odd) {
    background-color: #000000CC;
}
tr:nth-child(even) {
    background-color: #111111CC;
}*/

#verySimpleText{
	text-align: left;
	width: 700px;
	margin: 0 auto;
	font-family: 'Noto Sans KR', sans-serif;
}

/*.container {
  position: relative;
  text-align: center;
  color: white;
}

.charName {
  font-family: 'Noto Sans KR', sans-serif;
  position: absolute;
  top: 5px;
  left: 16px;
  font-size: 2vw;
}

.absText {
      font-family: 'Noto Sans KR', sans-serif;
  position: absolute;
  top: 45px;
  left: 16px;
  font-size: 2.2vw;
}*/


/*.speakerName{
	font-weight: bold;
}*/

.storyText {
	margin-top: 0.5ex;
	margin-bottom: 0.5ex;
}

.storyText.speakerName {
	margin-top: 0;
	font-weight: bold;
}

/*
Blatantly stolen from gfl.zzzzz.kr 
I have no idea how it works
*/
.storyImg{
	position:relative;
	overflow:hidden; /*Keep portraits within div */
	width:700px;
	padding-top:1rem;
}
.storydoll{
	width:500px; /*Why is width 500px? */
	position: absolute;
	bottom: -30%;
	z-index: 5;
}
.storydoll.one{
	left:15%; /*???*/
}
.storydoll.first.two{
	right:35%
}
.storydoll.second.two{
	left:35%
}

.storydoll.dim{
	filter: brightness(50%);
	z-index:4;
}
.storydoll.mask {
	mask-position: center;
	mask-size: 500px;
	filter: brightness(300%) opacity(75%);
}

/*.storydoll.saying{
	filter: brightness(100%);
	z-index: 100;
}*/

#SearchResults {
	cursor: pointer;
	display: block;
	text-align: left;
}
/*lol */
.collection-item.waves-effect {
	display: inherit;
}

</style>
<script type="text/javascript"></script>
<!-- tfw no bandwidth -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
<!--<script type="text/javascript" src="materialize.js"></script>-->
<!--<script src="phaser.min.js"></script>-->
<script src="https://cdn.jsdelivr.net/npm/phaser@3.24.1/dist/phaser.min.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.js"></script>
<!--Helper functions-->
<script>
	//https://stackoverflow.com/a/57401891
	function adjustColor(color, amount) {
		return '#' + color.replace(/^#/, '').replace(/../g, color => ('0'+Math.min(255, Math.max(0, parseInt(color, 16) + amount)).toString(16)).substr(-2));
	}
	
	//https://www.w3schools.com/js/js_cookies.asp
	function setCookie(cname, cvalue, exdays) {
		var d = new Date();
		d.setTime(d.getTime() + (exdays*24*60*60*1000));
		var expires = "expires="+ d.toUTCString();
		document.cookie = cname + "=" + cvalue + ";SameSite=Lax;" + expires + ";path=/";
	}
	function getCookie(cname) {
		var name = cname + "=";
		var decodedCookie = decodeURIComponent(document.cookie);
		var ca = decodedCookie.split(';');
		for(var i = 0; i <ca.length; i++) {
			var c = ca[i];
			while (c.charAt(0) == ' ') {
				c = c.substring(1);
			}
			if (c.indexOf(name) == 0) {
				return c.substring(name.length, c.length);
			}
		}
		return "";
	}
	
	//https://stackoverflow.com/a/29998400
	function JavaSplit(string,separator,n) {
		var split = string.split(separator);
		if (split.length <= n)
			return split;
		var out = split.slice(0,n-1);
		out.push(split.slice(n-1).join(separator));
		return out;
	}

</script>
<!--The main program-->
<script>
	/*
	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU Affero General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU Affero General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.

	This program is written by Rhythm Lunatic.
	*/
	
	/*
	Just gonna say it right now, I don't know an ounce of JavaScript or phaser.
	I interpreted lua and my game engine knowledge until this worked. Also lots of 'pythonic' logic in the JavaScript.
	
	So that's the answer as to why the chapter select looks horrible. Make a PR if you want it to be fixed.
	*/

	/* opcode dictionary
		Seriously who designed this, can't you use normal fucking opcodes?
		XXX() - Set portrait. XXX is character sprite. Can have multiple of these. Actually does not need to be the first OPCODES
		; - Unknown purpose. Could be used for switching highlights? Seems to separate two portrait opcodes.
		<BGM> - Set BGM
		<BIN> - Set background
		<Speaker> - Set the speaker name
		|| - Separator. Things after this separator will be run later, maybe? Usually transition commands, shake effects, etc are after these
		<黑点X> - Black dot screen transition. X=1 for in, 2 for out.
		<黑屏X> - Black screen fade in and out
		<通讯框> - "Communication box". Display character portrait inside a communication box.
		<震屏> - Screen shake effect
		<回忆> - Set orange textbox
		<关闭蒙版> - Possibly related to orange textbox
		: - End of opcodes, text goes here (Other than +)
		+ - End text. Text will continue in a new box (no close/open animation) when clicked.
		
	*/
	//I kept accidentally typing print ok
	window.print = function(param)
	{
		console.log(param);
	}
	function consoleWarn(param)
	{
		console.log("%c "+param,'background: black; color: yellow')
	}
	
	
	//FOR T-DOLL DISPLAY
	gfcolors = [
		"#000000", //NPCs & SF - Black?
		"0",        //Nothing has 1 stars.
		"#adadad", //2 stars   - Grey
		"#6bdfce", //3 stars   - Turquoise
		"#d6e35a", //4 stars   - Green
		"#ffb600", //5 stars   - Orange
		"#ff6a00", //6 stars   - Orange
		"#dfb6ff"  //EXTRAstar - Purple
	]
	
	function num2stars(div, numStars)
	{
		var _star_ = document.createElement("i");
		_star_.className = "material-icons";
		
		if (numStars < 1)
		{
		
		}
		else if (numStars == 7)
		{
			var star = _star_.cloneNode(false);
			star.innerHTML = "stars"
			star.style.color = gfcolors[7];
			div.appendChild(star);
		}
		else if (numStars > 5)
		{
			for (var j=0;j<numStars;j++)
			{
				var star = _star_.cloneNode(false);
				star.innerHTML = "star";
				star.style.color = gfcolors[numStars];
				div.appendChild(star);
			}
		}
		else
		{
			for (var j=0;j<5;j++)
			{
				var star = _star_.cloneNode(false);
				if (j < numStars)
					star.innerHTML = "star";
				else
					star.innerHTML = "star_border";
				star.style.color = gfcolors[numStars];
				div.appendChild(star);
			}
		}
	}
	
	
	//Night mode
	isDarkMode=false;
	function NightMode()
	{
		let theme = "dark-theme"
		if (document.body.classList.contains("dark-theme"))
		{
			theme='black-theme';
			document.body.classList.replace("dark-theme",theme);
			isDarkMode=true
		}
		else if (document.body.classList.contains("black-theme"))
		{
			theme='light-theme';
			document.body.classList.replace("black-theme",theme);
			isDarkMode=false;
		}
		else
		{
			document.body.classList.replace('light-theme',theme);
			isDarkMode=true;
		}
		setCookie('theme',theme,180);
	}
	
	//interpreter related
	
	const OPCODES = {
		STOPBGM : 0,
		BGM : 1,
		BG : 2,
		SPEAKER : 3,
		MSG : 4,
		PORTRAIT : 5,
		NOPORTRAIT : 6,
		MSGBOXTRANSITION : 7,
		//SETMASKEDPORTRAIT : 8
	}
	
	//For JSON structured or making your own
	//Pro tip: use opcode2string.indexOf(s) to get the opcode number
	const opcode2string = [
		'stopBGM',
		'bgm',
		'bg',
		'speaker',
		'msg',
		'portrait',
		'noPortrait',
		'msgboxTransition',
		//'setMaskedPortrait'
	]
	
	const tag2opcode = {
		"Speaker":OPCODES.SPEAKER,
		"BIN":OPCODES.BG,
		"BGM":OPCODES.BGM,
		//"通讯框":OPCODES.SETMASKEDPORTRAIT,
	}
	
	//profiles.txt
	const backgrounds = [
		'Square_A', '树林', '机场', '街道', '主界面背景', '大桥',
		'冰湖', '雪地', '作战室avg', 'black', 'PlaybackBG1', '掐脖子', 
		'打海猫', '打海猫2', 'M16开枪', '室内战斗', 'eliza0', 'ANTIRAIN', 
		'单挑', 'SFs', 'StoryCG5', '作战室avg', '工厂背景avg', 'CG.1-6 无人', 
		'CG.1-6 有人', 'CG.2-6', 'CG.4-2', 'CG.5-6', 'CG.5', '夜间蒙版', '404', 'sp2.2.1', 
		'sp2.2.2', 'sp2.2.3', 'sp2.2.4', '3X', '6CG-M4', '6CG-AR15a', '6CG-AR15b', 
		'PlaybackBG1', 'PlaybackBG2', 'CG4N', 'CG4N1', 'CG4N2', 'CG7-3', 'CG7-6', 'BG7-3', 
		'BG7-4', 'CG-Cannon', 'CG-2017Winter1', 'CG-2017Winter2', 'Ouroboros', 'CG8-1', 'CG8-2', 
		'SFBase', 'Metro', 'CG8-3.1', 'CG8-3.2', 'GGXX1', 'GGXX2', '17xhCG1-0', '17xhCG1-1', '17xhCG2-0', 
		'17xhCG2-1', '17xhCG2-2', '17xhCG2-3', '17xhCG3-0', '17xhCG3-1', '17xhCG4-0', '17xhCG4-1', '17xh-404Room', 
		'17xh-ButterflyFactory', '17xh-Networld', '17xh-ShootingRange', 'CG9-1.1', 'CG9-1.2', 'CG9-1.3', 'CG9-2.1', 
		'CG9-2.2', 'BG9-Dinner', 'BG-Bar', 'BG-BarXmas', 'BG-Dorm', 'BG_Base', 'BG_City', 'BG_Inner', 'BG_Street', 
		'BG-BarHallow', 'BG-WarehouseOFF', 'BG-WarehouseON', 'CG-Houkai2-1-1', 'CG-Houkai2-1-2', 'CG-Houkai2-2-1', 
		'CG-Houkai2-2-2', 'CG-Houkai2-3-1', 'CG-Houkai2-3-2', 'BG-Theatre', 'BG-Corridor', 'BG-BurnCity', 'BG-WildBattle', 
		'CG10-1-1', 'CG10-1-2', 'CG10-1-3', 'CG10-2-1', 'CG10-2-2', 'CG10-2-3', 'CG10-2-4', 'CG10-3-1', 'CG10-3-2', 'CG10-4-1', 
		'CG10-4-2', 'CG10-4-3', 'CG10-5-1', 'CG10-5-2', 'CG10-5-3', 'CG10-6-1', 'CG10-6-2', '2018Winter1-1', '2018Winter1-2', 
		'2018Winter2-1', '2018Winter2-2', '2018Winter2-3', '2018Winter3-1', '2018Winter3-2', '2018Winter4-1', '2018Winter4-2', 
		'2018Winter4-3', '2018Winter5-1', 'BG-BarSpring', 'BG-Kitchen', '2018Winter0-1', '2018Winter0-2', '2018Winter6-1', 
		'2018Winter7-1', '2018Winter8-1', '2018Winter9-1', 'BG-Wedding', 'BG-Grass', 'BG-GrassWedding', 'BG-DinnerNoMan', 
		'BG-DjmaxCity', 'BG-DjmaxGraveyard', 'BG-DjmaxLight', 'BG-DjmaxCemetery', 'CG-DJMAX1', 'CG-DJMAX2', '2018SummerCG1-1', 
		'2018SummerCG1-2', '2018SummerCG2-1', '2018SummerCG2-2', '2018SummerCG3', '2018SummerCG4', '2018SummerCG5', 
		'2018SummerCG6-1', '2018SummerCG6-2', '2018SummerCG7', '2018SummerCG8', 'BG-ContaminatedZone', 'BG-InterrogationRoom', 
		'BG-RuinedCity', 'BG-Sanatorium', 'BG-TemporaryBase', 'BG-Beach', 'BG-BeachNight', 'CG11-1', 'CG11-2', 'BG-Cybercity', 
		'BG-Sewer', 'BG-Slum', 'BG-Wall', '19WinterCG1', '19WinterCG2', '19WinterCG3', '19WinterCG4', '19WinterCG5', 
		'19WinterCG5-1', '19WinterCG6', '19WinterCG7', '19WinterCG7-1', 'BG-Fortress', 'BG-Mullet', 'BG-Monument', 
		'BG-Guildhall', 'fullwhite', 'va11_cg1', 'va11_cg2', 'va11_BAR', 'Desert', 'va11_cg3', 'va11_cg4', 'va11_cg3_1', 
		'va11_cg3_2', 'va11_end', 'va11_end_1', 'va11_cg1', '2019summer_1', '2019summer_2', '2019summer_3', '2019summer_4_1', 
		'2019summer_4_2', '2019summer_5', '2019summer_6', '2019summer_7', '2019summer_8', '2019summer_9', '2019summer_10', 
		'2019summer_11', '2019summer_12', '2019summer_13', '2019summer_14', '2019summer_15', '2019halloween_1', '2019halloween_2', 
		'19christmas_1', '19christmas_2', '19christmas_3', '19winter_ange_1', '19winter_ange_2', '19winter_4516', '19winter_biggun', 
		'19winter_m4_1', '19winter_inbg_1', '19winter_inbg_2', '19winter_door_close', '19winter_door_open', '19winter_doorandtank', 
		'19winter_doorexplode', '19winter_aurora', '19winter_ump45vs', '19winter_lab', '19winter_ finalvs', '19winter_ hole_1', 
		'19winter_ hole_2', '19winter_ hole_3', '19winter_ sea', 'ABYSS_~1', '19winter_finalvs2', 'ABYSS_~1.PNG', 'PK', '2020white-1', 
		'2020white-2', '13CG3', 'Topomap_D', '13CG4', '13CG1', '13CG2', 'RED', 'REDNET', 'REDNET', 'WHITENET', '13CG3v2', 
		'TEAPARTYDAY', 'TEAPARTYNIGHT', 'LAKE', 'RICOCG4', 'TRIELLACG5', 'HenriettaCG6', 'SEAPARTYCG1', 'SEAPARTYCG2', 'gunCGgarden1', 
		'gunCGgarden2', 'gunCGHenrietta', 'gunCGlake', 'gunCGrico', 'gunCGtriella', 'gunCGstreet', 'gunCGend', 'gunCGhdz', 'nakamaCG1', 
		'2020summerFlowerfield', '2020summerOrphanage', '2020summerPaper', '20summerLAB', '2020summerTransport', '2020summerBattle1', 
		'2020summerBattle2', '2020summerOffice', '2020summer94&K', '2020summerA&M1', '2020summerA&M2', '2020summerAnge', '2020summerRefugees'
	]
	
	//To be loaded later.
	let PORTRAITS = undefined;
	
	//For CSS
	var int2str = ['zero','one',  'two',   'three','four',  'five', 'six',  'seven',  'eight', 'nine']
	var int2strPos = ['N','first','second','third','fourth','fifth','sixth','seventh','eighth','ninth']
	
	//I moved everything to gfl subdomain so it's fine now
	//const portraitWebserver = "http://gfl.amaryllisworks.pw/pic/"
	
	function portraitStructToString(p)
	{
		return "idx: "+p[1]+" | name: "+p[2]+" | type: "+p[3]+" | dim: "+p[4]+" | isMasked: "+p[5]
	}
	
	//Don't care if it's all over the place. Fix it yourself. If this was SM I'd be using broadcasts anyways
	var nameActor;
	var bgActor;
	
	function loadBG(runtime, num)
	{
		console.log("Loading "+num+" | "+backgrounds[num])
		runtime.load.once('complete',function() { bgActor.setTexture(num);bgActor.displayWidth = 1280;bgActor.displayHeight= 720; },runtime)
		runtime.load.image(num,'avgtexture/'+backgrounds[num]+'.png');
		runtime.load.start();
	}
	
	//A pool of portraits since there's gonna be more than one
	var portraitCollection = []
	function loadPortrait(runtime,idx,name,type)
	{
		if (PORTRAITS[name] != undefined && PORTRAITS[name][type] != undefined)
		{
			let keyedPortrait=name+'-'+type;
			let fileName = PORTRAITS[name][type]
			console.log("Loading "+fileName);
			if (idx > portraitCollection.length-1)
			{
				runtime.load.once('complete',function() { portraitCollection.push( runtime.add.image(game.config.width/2,game.config.height-100,keyedPortrait) ) } );
			}
			else
			{
				runtime.load.once('complete',function() { portraitCollection[idx].setTexture(keyedPortrait) } );
			}
			runtime.load.image(keyedPortrait,'pic/'+fileName);
			runtime.load.start();
		}
		else
		{
			console.log("Portrait "+name+" missing from database.")
		}
	}
	
	//var interval;
	//Yes, I did translate it from lua. Lmao.
	class VNText4 {
		constructor(phaserRuntime,font,maxwidth,spd,msgTable)
		{
			this.phaserRuntime = phaserRuntime; //lol
			this.cur_len = 0;
			this.spd = spd;
			this.curIndex = 0;
			this.msgTable = msgTable;
			
			this.textActor = phaserRuntime.add.text(0,0,'Static Text Object', { fontFamily: 'Noto Sans KR', fontSize: 27, color: '#ffffff', wordWrap: {width:maxwidth,useAdvancedWrap:true} });
		}
		is_finished()
		{
			return this.cur_len == this.text.length;
		}
		
		//In StepMania you can just chain a command (within an actor) with sleep over and over, but in phaser you have to attach it to the game engine?
		//Attaching tweens to the game engine instead of actors is kind of a weird decision by the way, why wouldn't you attach them to the actor?
		//I'm using setInterval anyways
		play()
		{
			
			let f = function(self){
				self.cur_len = self.textActor.text.length;
				//console.log(self.cur_len+"/"+self.text.length);
				if (self.cur_len < self.text.length)
				{
					let txt = self.text.slice(0,self.cur_len+1)
					//console.log(txt);
					self.textActor.setText(txt);
				}
				else
				{
					clearInterval(f);
				}
			}
			
			f(this);
			
			//console.log(1/this.spd*1000);
			let interval = setInterval(f,1/this.spd*1000,this);
			//This can't possibly be high performance...
			
			/*phaserRuntime.tweens.add({
				targets:this.textActor,
				ease:'Linear',
				duration:1/this.spd,
				onComplete:this.play
			)}*/
				
			
		}
		Text()
		{
			this.cur_len = this.textActor.text;
			if (this.cur_len < this.text.length)
				this.textActor.setText(this.text.slice(0,this.cur_len));
		}
		advance()
		{
			if (this.no_more_text())
				return;
			//this.curIndex++;
			var noMsgYet = true;
			while (noMsgYet)
			{
				console.assert(this.msgTable[this.curIndex],"There is no opcode located at "+this.curIndex+". How did you even get this far?")
				let curMsg = this.msgTable[this.curIndex]
				let MsgOpcode = curMsg[0]
				//console.log(opcode)
				//console.log(this.curIndex);
				//console.log(MsgOpcode == OPCODES.MSG);
				switch(MsgOpcode) {
					case OPCODES.MSG:
						this.cur_len= 0
						this.text = curMsg[1]
						//this.text_actor:queuecommand("Check")
						noMsgYet = false;
						break;
					case OPCODES.SPEAKER:
						nameActor.setText(curMsg[1]);
						break;
					case OPCODES.BG:
						loadBG(this.phaserRuntime,curMsg[1]);
						break;
					case OPCODES.PORTRAIT:
						console.log(portraitStructToString(curMsg))
						loadPortrait(this.phaserRuntime,curMsg[1],curMsg[2],curMsg[3])
						break;
					//lua junk from my message system. Just ignore it.
					/*case OPCODESFMSG:
						this.cur_len= 0
						this.text = this.msgTable[this.curIndex][2]()
						//this.text_actor:queuecommand("Check")
						break outLoop;
					elseif opcode == "func" then
						this.msgTable[this.curIndex][2]()
					elseif opcode == "choice" then
						ChoiceTable = {Result=1,Finished=false}
						assert(this.msgTable[this.curIndex][2],"Choice table is invalid.")
						ChoiceTable.Choices = this.msgTable[this.curIndex][2]
						assert(ChoiceTable.Choices)
					elseif opcode == "exit" then
						return false;
					elseif opcode == "condJumpSS" then
						Trace(table_print(this.selfSwitches))
						Trace(table_print(this.msgTable[this.curIndex]))
						if this.selfSwitches[this.msgTable[this.curIndex][2]] == true then
							//Subtract 1 to account for advance advancing one step, since we want to start on whatever it jumps to
							this.curIndex = this.msgTable[this.curIndex][3]-1
							Trace("Jumped to index "..this.curIndex)
						end
					elseif opcode == "condJump" then
						if this.msgTable[this.curIndex][2]() == true then
							//Subtract 1 to account for advance advancing one step, since we want to start on whatever it jumps to
							this.curIndex = this.msgTable[this.curIndex][3]-1
							Trace("Jumped to index "..this.curIndex)
						end
					elseif opcode == "selfSwitch" then
						this.selfSwitches[this.msgTable[this.curIndex][2]] = this.msgTable[this.curIndex][3]
					end;*/
				}
				this.curIndex++;
				//console.log(noMsgYet);
			}
			//Trace(this.text)
			//lua.Flush();
			//this.text_actor:settext(""):playcommand("Check");
			//console.log(this.text)
			document.getElementById('curIndexDebug').innerText="idx: "+(this.curIndex-1)+" | msg: "+this.msgTable[(this.curIndex-1)].toString()
			this.textActor.setText('');
			this.play();
		}
		no_more_text()
		{
			return this.curIndex >= this.msgTable.length-1;
		}
		skip()
		{
			this.textActor.setText(this.text);
			this.cur_len = this.text.length;
		}
	}
	
	/*class SpriteActor() {
		constructor()
		{
			//this.
		}
	}*/
	
	function sliceAndRemove(str, begin, end)
	{
		return str.slice(0,begin)+str.slice(end)
	}
	
	function getFromTag(str,tag)
	{
		const beginTag = "<"+tag+">"
		const endTag = "</"+tag+">"
		var n = str.indexOf(beginTag)
		if (n != -1){
			return str.slice(n+beginTag.length, str.indexOf(endTag))
		}
		return null
	}
	function removeTag(str,tag)
	{
		const beginTag = "<"+tag+">"
		const endTag = "</"+tag+">"
		return sliceAndRemove(str,str.indexOf(beginTag),str.indexOf(endTag)+endTag.length)
	}
	
	function playNewAudio(fileName)
	{
		let audioPlayer = document.getElementById('audioPlayer');
		audioPlayer.firstElementChild.src = fileName
		audioPlayer.load();
		audioPlayer.play();
	}
	
	
	let curEpisodePart = 0
	class GirlsFrontlineScene extends Phaser.Scene {
		constructor()
		{
			//I don't know what this does but the tutorial had it
			super('GirlsFrontlineScene');
		}
		
		 preload()
		{
			//this.load.image('test','test.png');
			this.load.image('textbox','textbox.png');
		}
		
		create()
		{
			//input.touch only works on mobile devices. So it will break on desktop. reeeee
			//game.input.touch.capture = false;
			
			//GFL, in all of it's genius, uses 1024x1024 images. With black borders.
			/*bgActor = this.make.image({ x:game.config.width/2, y:game.config.height/2, add:true });
			bgActor.displayWidth = 1024
			bgActor.displayHeight= 1024*/
			bgActor = this.add.image(game.config.width/2,game.config.height/2);
			bgActor.texture = Phaser.Cache.DEFAULT;
			bgActor.setDepth(0);
			
			/*var img = this.make.image({ x:game.config.width/2, y:game.config.height/2, key:'test',add:true })
			img.displayWidth = game.config.width
			img.displayHeight= game.config.height
			img.setDepth(1);*/
			
			//Depth 2 is reserved for character portraits!
			
			imageActor = this.make.image({
				x:game.config.width /2,
				y:game.config.height-125,
				//scale:1,
				key:'textbox',
				add:true
			})
			imageActor.scaleY = 1
			imageActor.setDepth(3);
			
			//var blocks = this.add.group({ key: 'block', repeat: 139, setScale: { x: 0, y: 0 } });
			
			nameActor = this.add.text(240,500,'', { fontFamily: 'Noto Sans KR', fontSize: 30, color: '#ffffff' });
			nameActor.setDepth(4);
			
			//TODO
			document.getElementById("DebugTextArea").value = structuredLinesToString(currentEpisodeAsOpcodes[curEpisodePart]);
			
			vntext = new VNText4(this,'',800,13,currentEpisodeAsOpcodes[curEpisodePart]);
			vntext.textActor.x = 242;
			vntext.textActor.y = game.config.height-160
			vntext.textActor.setDepth(4);
			vntext.advance();
			
			this.input.on('pointerdown',function(){
				if (vntext.no_more_text())
				{
					console.log("Already hit the end!!!!");
					//'this' isn't passed in... No idea what I'm gonna do
					//If you spam click it will crash because you're removing and trying to add multiple scenes at the same time
					//this.input.onInputDown.removeAll();
					if (curEpisodePart < currentEpisodeAsOpcodes.length)
					{
						curEpisodePart++;
						game.scene.remove('GirlsFrontlineScene');
						game.scene.add('GirlsFrontlineScene',GirlsFrontlineScene,true);
					}
					else
					{
						//Oh no
						goToNextEpisode()
					}
					
				}
				else
				{
					if (vntext.is_finished())
					{
						vntext.advance();
					}
					else
					{
						vntext.skip();
					}
				}
			},vntext)
			//Hey look it's just like StepMania
			/*this.make.text({
				x: 100,
				y: 100,
				text: 'Phaser III',
				style: {
					fontSize: '48px',
					fontFamily: 'Arial',
					color: '#ffffff',
					metrics: {
						ascent: 45,
						descent: 10,
						fontSize: 55
					}
				}
			})*/
		}
		
		//I'm not even using this lmao
		 update()
		{
			
		}
	}
	
	let config = {
		type: Phaser.WEBGL,
		width: 1280,
		height: 720,
		parent: 'phaser',
		/*scene: {
			preload: preload,
			create: create,
		}*/
		scene: [GirlsFrontlineScene]
	};
	
	//phaser
	var game;
	
	var imageActor;
	var vntext;
	
	
	function convertGFLTextToOpcodes(out)
	{
		//console.log(out);
		var lines = out.split(/\r?\n/);
		//The GFL text system is stupid as fuck and I just spent a whole week writing my own VN system
		//So obviously I'm going to convert it to my own. fuck you
		//console.log(lines)
		//Fuck your opcodes
		let structuredLines = [];
		
		
		//It's really stupid but dimRightSide has to know the state of the previous dimmed portraits because normally the GFL engine only supports two portraits and I wanted more
		let prevLineHadAtLeastTwoPortraits = false;
		let dimRightSide = false;
		for(i=0;i<lines.length;i++)
		{
			if (!lines[i])
				continue;
			//print(lines[i]);
			let [cmds,text] = JavaSplit(lines[i].replace("：",':').replace("；",";"),":",2)
			console.assert(cmds,lines[i])
			//There can be lines without any text so asserting is pointless
			//console.assert(text,lines[i])
			//console.log(text)
			//
			
			//Yeah I know tags are supposed to be in order, No I don't really care sorry
			
			//So portraits are set in any order... But how the fuck are you supposed to tell when a name is if there's <> tags
			//I'm just going to search portraits after removing <> tags, it probably won't matter
			let numPortraits = 0;
			let thisLineHadAtLeastTwoPortraits = (cmds.indexOf(";") != -1)
			//This doesn't work correctly... If a new portrait gets pushed and the previous line had two portraits then the dimmed one is the existing portrait from the previous line
			if (thisLineHadAtLeastTwoPortraits && prevLineHadAtLeastTwoPortraits)
					dimRightSide = !dimRightSide;
				
			//Add portrait removal command
			if (prevLineHadAtLeastTwoPortraits && !thisLineHadAtLeastTwoPortraits)
			{
				let [charID,charSpr] = cmds.slice(0,cmds.indexOf(")")).split("(")
				//let newPortrait = 
				//It's -2 because the last line is always MSGBOXTRANSITION
				for(var lll=structuredLines.length-2; lll>=0; lll--)
				{
					let m = structuredLines[lll];
					if (m[0]==OPCODES.MSGBOXTRANSITION)
						break;
					else if (m[0]==OPCODES.PORTRAIT && m[2]!=charID)
					{
						structuredLines.push([OPCODES.NOPORTRAIT,m[1]])
						break;
					}
				}
			}
			//console.log(thisLineHadAtLeastTwoPortraits);
			//Limit it to 5 because I don't want a dumb infinite loop that crashes the browser
			for(j=0;j<5;j++)
			{
				//console.log(cmds)
				let charTagEnd = cmds.indexOf(")");
				if (charTagEnd != -1)
				{
					//It's +1 to get rid of the ;
					let charTagStart = Math.max(cmds.lastIndexOf(";",charTagEnd)+1,0)
					let [charID,charSpr] = cmds.slice(charTagStart,charTagEnd).split("(")
					//console.log(charID)
					//console.log(charSpr)
					//Ignore empty sprite IDs, they do nothing.
					if (charSpr != undefined && charSpr != "")
					{
						let shouldDim = false;
						if (thisLineHadAtLeastTwoPortraits)
						{
							if (!prevLineHadAtLeastTwoPortraits)
							{
								//debugger;
								//If this is the second portrait being added, we can just check the state of the previous portrait.
								if (numPortraits>0)
								{
									let m = structuredLines[structuredLines.length-1]
									if (m[0]==OPCODES.PORTRAIT)
										{
											shouldDim=!m[4]
											dimRightSide=shouldDim;
										}
									else
										consoleWarn("wtf?")
								}
								else
									//It's -2 because the last line is always MSGBOXTRANSITION.
									for(var lll=structuredLines.length-2; lll>=0; lll--)
									{
										let m = structuredLines[lll];
										if (m[0]==OPCODES.MSGBOXTRANSITION)
											break;
										//Search for single old portrait, if it matches then it shouldn't dim
										else if (m[0]==OPCODES.PORTRAIT)
										{
											//debugger;
											//Insert terrible programmer meme here
											//The new portrait is the one NOT dimmed
											shouldDim = (m[2] == charID)
											//????????????????????????????????????????
											//Maybe dimRightSide=!shouldDim will also work?
											dimRightSide=(shouldDim ? j==0 : j!=0)
											break;
										}
									}
							}
							else
							{
								shouldDim = dimRightSide ? j !=0 : j == 0;
							}
							//debugger;
						}
						
						let shouldMask = false;
						//It's -2 because the last line is always MSGBOXTRANSITION.
						for(var lll=structuredLines.length-2; lll>=0; lll--)
						{
							let m = structuredLines[lll];
							if (m[0]==OPCODES.NOPORTRAIT && m[1]==numPortraits)
							{
								//console.log("Found noportrait at "+lll+", exit");
								//Portrait was cleared previously, so this is probably the first instance of the portrait and there's no need to determine previous masking
								//shouldMask=false;
								break;
							}
							//Search for single old portrait, if it matches then it shouldn't dim
							else if (m[0]==OPCODES.PORTRAIT)
							{
								if (m[2] == charID)
								{
									shouldMask = m[5]
									//console.log("Found previous portrait, previous mask value was "+shouldMask)
									break;
								}
							}
						}
						
						
						structuredLines.push([OPCODES.PORTRAIT,numPortraits,charID,charSpr,shouldDim,shouldMask])
						//nextPortraitIsMasked = false;
						numPortraits++;
					}
					//I think speaker name gets cleared if it's ()? Not sure
					//Portrait gets cleared
					else
					{
						structuredLines.push([OPCODES.NOPORTRAIT,1])
						structuredLines.push([OPCODES.NOPORTRAIT,0])
						structuredLines.push([OPCODES.SPEAKER,""])					
						//numPortraits=0;
					}
					cmds = sliceAndRemove(cmds,charTagStart,charTagEnd+1);
				}
				else
				{
					//console.log("Done... Let's exit");
					break;
				}
			}
			prevLineHadAtLeastTwoPortraits = thisLineHadAtLeastTwoPortraits;
			
			
			let speakerRes = getFromTag(cmds,"Speaker")
			//Optimization: If prevLine was another speaker line, overwrite it instead of writing another
			if (speakerRes)
			{
				let prevLine = structuredLines[structuredLines.length-1]
				if (prevLine[0]==OPCODES.SPEAKER)
					structuredLines[structuredLines.length-1]=[OPCODES.SPEAKER,speakerRes]
				else
					structuredLines.push([OPCODES.SPEAKER,speakerRes])
			}
			
			let bgmRes = getFromTag(cmds,"BGM")
			let bgmRenames = {
				//"BGM_Hello":"",
				"BGM_Sunshine":"home_formation_factory",
				"BGM_NightOPS":"GUN_CineTense_loop"
			}
			if (bgmRes != null)
			{
				if(bgmRes=="BGM_Empty")
					structuredLines.push([OPCODES.STOPBGM])
				else
				{
					structuredLines.push([OPCODES.BGM,bgmRenames[bgmRes] ? bgmRenames[bgmRes] : bgmRes])
				}
				
			}
			
			const tags = ["BIN"]
			tags.forEach(tag => {
				//console.log(tag);
				let tagRes = getFromTag(cmds,tag);
				//console.log(tagRes)
				if (tagRes != null)
				{
					structuredLines.push([tag2opcode[tag],tagRes])
					removeTag(cmds,tag)
				}
			})
			//const tags = [
			//var nextPortraitIsMasked = false;
			//Since portraits are searched before modifiers...
			if (cmds.includes("<通讯框>"))
			{
				let idxToCheck = 0;
				
				let posOfMaskCmd = cmds.indexOf("<通讯框>");
				let posOfCmdDivider = cmds.indexOf(";")
				//If this line had more than one portrait AND the ; is before the mask command, we should be masking the portrait at idx 1 instead of 0
				if (posOfCmdDivider > 0 && posOfCmdDivider < posOfMaskCmd)
				{
					idxToCheck = 1;
				}
				
				for(var lll=structuredLines.length-1; lll>=0; lll--)
				{
					let m = structuredLines[lll];
					console.assert(m)
					if(m[0]==OPCODES.MSG)
					{
						//consoleWarn("Found a message opcode before a portrait opcode... Messages shouldn't exist at this point")
						break;
					}
					else if (m[0]==OPCODES.PORTRAIT && m[1] == idxToCheck)
					{
						structuredLines[lll][5]=true
						break;
					}
				}
				//nextPortraitIsMasked = true;
				//structuredLines.push([OPCODES.SETMASKEDPORTRAIT])
				cmds=cmds.replace("<通讯框>","");
			}
			/**/
			
			//Now do text... But first check if there is any text (some lines are only commands)
			if (text)
			{
				text.split("+").forEach(msg => {
					structuredLines.push([OPCODES.MSG,msg])
				})
			}
			//open/close msgbox
			structuredLines.push([OPCODES.MSGBOXTRANSITION])
		}
		return structuredLines;
	}
	
	var curEpKey;
	var currentEpisodeAsOpcodes;
	
	//WHY DOES IT HAVE TO BE A SEPARATE FUNCTION
	/*async function fetchTextFile(fileName)
	{
		console.log("fetching "+fileName);
		const response = await fetch("avgtxt/"+fileName);
		console.log("got "+fileName);
		return await response.text();
		//const out = await response.text();
		//return out;
	}*/
	
	function structuredLinesToString(structuredLines)
	{
		let s = "";
		structuredLines.forEach(line => {
			s+=opcode2string[line[0]]+';'
			/*for(var i=1;i<line.length;i++)
				s+=line[i]*/
			s+=line.slice(1).join([separator = ';'])
			s+='\r\n'
			//s+=line.toString()+"\r\n";
		})
		return s;
	}
	function stringToStructuredLines(s)
	{
		var lines = s.split(/\r?\n/);
		let structuredLines = [];
		for(i=0;i<lines.length;i++)
		{
			let newMsg = lines[i].split(';')
			newMsg[0] = opcode2string.indexOf(newMsg[0])
			if (newMsg[0] == OPCODES.PORTRAIT)
			{
				//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining
				//Someone said the site stopped working because I used the operators so I had to change it back :V
				//It also doesn't work on the old version of Firefox for Android and I want Tampermonkey
				//newMsg[4] = (newMsg[4]?.toLowerCase() == "true")
				//newMsg[5] = (newMsg[5]?.toLowerCase() == "true")
				
				newMsg[4] = (newMsg[4] != undefined ? newMsg[4].toLowerCase() == "true" : false)
				newMsg[5] = (newMsg[5] != undefined ? newMsg[5].toLowerCase() == "true" : false)
			}
			structuredLines.push(newMsg)
		}
		return structuredLines;
	}
	
	//Anti-XSS
	function sanitize(string) {
		const map = {
			'&': '&amp;',
			'<': '&lt;',
			'>': '&gt;',
			'"': '&quot;',
			"'": '&#x27;',
			"/": '&#x2F;',
			"`": '&grave;'
		};
		const reg = /[&<>"'/]/ig;
		return string.replace(reg, (match)=>(map[match]));
	}

	
	//You're probably wondering why the fuck there's two of these functions when a routableKeyString is always passed in
	//That's because I want to support running from an episode object without the keyString (for user stuff)
	function runFromRoutableKeyString(value)
	{
		if (value == undefined)
			value = curEpKey;
		let [type,chapter,episode] = getKeysFromRoutableString(value)
		run(listOfChapters[type][chapter]['episodes'][episode],value)
	}
	
	function runFromUserInput()
	{
		let out = document.getElementById('textarea1').value;
		let structuredLines = stringToStructuredLines(out);
		currentEpisodeAsOpcodes = [structuredLines];
		curEpKey = "";
		let simpleTextDiv = document.getElementById("verySimpleText");
		let NewSimpleTextDiv = document.createElement('div');
		NewSimpleTextDiv.id="verySimpleText";
		NewSimpleTextDiv.appendChild(renderStructuredLinesToDiv(structuredLines,0))
		
		simpleTextDiv.parentNode.replaceChild(NewSimpleTextDiv,simpleTextDiv);
		if (game == undefined)
			document.getElementById("startButton").classList.remove('disabled');
	}
	
	//input: structuredLines
	//output: a div with the elements rendered
	function renderStructuredLinesToDiv(structuredLines,part)
	{
		//console.log(structuredLines)
		//document.getElementById("DebugTextArea").value = structuredLinesToString(s)
		
		
		
		//It has underscores because it's going to be cloned
		/*let _div_ = document.createElement('div');
		_div_.className="container";
		
		let _img_ = document.createElement("img");
		_img_.src="textbox.png";
		_img_.style.width="100%";
		_div_.appendChild(_img_);
		
		let charName = document.createElement("div");
		charName.className="charName";
		_div_.appendChild(charName);
		
		let text = document.createElement("div");
		text.className="absText";
		text.id="text";
		_div_.appendChild(text);
		
		//let textboxDiv = document.getElementById("Textboxes");
		let newTextboxDiv = document.createElement('div');
		newTextboxDiv.id="Textboxes";*/
		
		let thisPartDiv = document.createElement('div');
		let h3 = document.createElement('h3');
		//console.log(partNum);
		h3.innerText="Part "+(part+1);
		//partNum++;
		thisPartDiv.appendChild(h3);
		
		if (document.getElementById('showDebugOpcodeButton').checked)
		{
			let button = document.createElement('a');
			//fuck your javascript
			button.setAttribute("class","waves-effect waves-light btn");
			button.setAttribute("onclick","showOpcodes('div_cutscene_"+part+"')")
			button.innerText="Show opcodes for this section (For debugging)"
			thisPartDiv.appendChild(button);
			thisPartDiv.appendChild(document.createElement('br'));
		
			let opcodesDiv = document.createElement('div');
			opcodesDiv.id= "div_cutscene_"+part
			opcodesDiv.style="display: none;"
			opcodesDiv.classList.add("textarea-wrapper");
			opcodesDiv.innerHTML = "<textarea rows='6' cols='50' id='textarea_cutscene_"+part+"' readonly>"+structuredLinesToString(structuredLines)+"</textarea><br>"
			//debugger;
			TLN.append_line_numbers_obj(opcodesDiv.firstElementChild,"textarea_cutscene_"+part)
			thisPartDiv.appendChild(opcodesDiv)
		}
		
		let playBGMbutton = document.createElement('a');
		playBGMbutton.setAttribute("class","waves-effect waves-light btn");
		playBGMbutton.innerHTML='<i class="material-icons left">music_note</i>Play audio for this cutscene'
		

		
		//<img src="avgtexture/夜间蒙版.png" class="storydoll first one mask" style="mask-image: url(pic/pic_NPC-Helian.png);">
		let maskThing = document.createElement('img');
		maskThing.src= "avgtexture/夜间蒙版.png";
		maskThing.classList.add("storydoll");
		maskThing.classList.add("mask");
		maskThing.style="z-index: 10";
		
		
		let lastSpeakerName = "";
		let lastBGUsed = ""; //'avgtexture/'+backgrounds[num]+'.png'
		let didBGOrPortraitOrNameChange = false;
		let shownPortraits = []
		
		let fancyDisplayType = document.getElementById('fancyOrNot').checked;
		//I am NOT adding another function just for this
		setCookie('fancyText',fancyDisplayType,180);
		
		for(var i=0;i<structuredLines.length;i++)
		{
			let opcode = structuredLines[i][0]
			//console.log(structuredLines[i]);
			switch (opcode)
			{
				case OPCODES.BGM:
					let newPlayBGMButton = playBGMbutton.cloneNode(true);
					newPlayBGMButton.setAttribute("onclick","playNewAudio('audio/"+structuredLines[i][1]+".ogg')")
					thisPartDiv.appendChild(newPlayBGMButton);
					break;
				case OPCODES.SPEAKER:
					lastSpeakerName=structuredLines[i][1];
					didBGOrPortraitOrNameChange = true
					break;
				case OPCODES.PORTRAIT:
					if (!fancyDisplayType)
						break;
					//console.log(portraitStructToString(structuredLines[i]))
					let idx = structuredLines[i][1]
					let name = structuredLines[i][2]
					let type = structuredLines[i][3]
					if (PORTRAITS[name] && PORTRAITS[name][type])
					{
						//console.log(shownPortraits.length);
						if (structuredLines[i][1] > shownPortraits.length-1)
						{
							//console.log("Pushed new portrait with idx "+idx);
							shownPortraits.push(structuredLines[i]);
							didBGOrPortraitOrNameChange = true;
						}
						else
						{
							let newPortrait = structuredLines[i]
							let oldPortrait = shownPortraits[idx]
							if (newPortrait[1] == oldPortrait[1] && newPortrait[2] == oldPortrait[2] && newPortrait[3] == oldPortrait[3] && newPortrait[4] == oldPortrait[4])
								console.log("New portrait set is identical to old one, ignoring change. (TODO: This should be left to the opcode interpreter to filter out!)");
							else
							{
								//console.log("Portrait replaced "+portraitStructToString(oldPortrait) +" -> "+portraitStructToString(newPortrait))
								shownPortraits[idx]=newPortrait;
								didBGOrPortraitOrNameChange = true;
							}
						}
						//console.log("NumPortraits: "+shownPortraits.length);
					}
					else
					{
						consoleWarn(portraitStructToString(structuredLines[i]))
						consoleWarn("Portrait missing from database.")
						shownPortraits[idx]=structuredLines[i];
						shownPortraits[idx][2]='missing'
						shownPortraits[idx][3]=0
					}
					break;
				case OPCODES.NOPORTRAIT:
					shownPortraits = [];
					didBGOrPortraitOrNameChange = true;
					break;
				case OPCODES.BG:
					if (!fancyDisplayType)
						break;
					let newBG = 'avgtexture/'+backgrounds[structuredLines[i][1]]+'.png'
					if (newBG == lastBGUsed)
					{
						console.log("New BG set is identical to old one, ignoring change. (TODO: This should be left to the opcode interpreter to filter out!)");
					}
					else
					{
						console.log(lastBGUsed + " -> "+newBG)
						lastBGUsed = newBG
						didBGOrPortraitOrNameChange = true;
					}
					break;
				case OPCODES.MSG:
					//Spawn new BG with speaker and portrait here.
					let message = structuredLines[i][1]
					for(var ccc = 0; ccc < 10; ccc++)
					{
						if(ccc > 5)
						{
							consoleWarn("Encountered more than 5 color codes in a message... This is very unusal, so bailing out");
							break;
						}
						//If you haven't already guessed, I don't know regex
						let idx = message.indexOf("<color=");
						if (idx != -1)
						{
							//console.log(message);
							let end = message.indexOf('>',idx)
							let color = message.slice(idx+7,end)
							//console.log(color)
							if (!isDarkMode)
								color = adjustColor(color,-80);
							let spanTagStart = "<span style='color:"+color+"'>"
							//First sanitize the part outside the <color> tag, then insert the new <span> tag, then sanitize the section inside the span tag, then insert the end tag
							//Then finally insert the rest of the unsanitized message.
							//debugger;
							message = sanitize(message.slice(0,idx))+spanTagStart+sanitize(message.slice(end+1,message.indexOf("</color>")))+"</span>"+message.slice(message.indexOf("</color>")+8)
						}
						else
						{
							//Sanitize the rest of the message.
							//I added a CSP to my website so there's no need to sanitize anything else (I think). Sanitizing the message is so you can see the tags. I guess.
							let sanitizedUpTo = message.lastIndexOf("</span>")
							//debugger;
							if (sanitizedUpTo != -1)
								message = message.slice(0,sanitizedUpTo+7)+sanitize(message.slice(sanitizedUpTo+7))
							else
								message = sanitize(message)
							//console.log(message)
							break;
						}
					}
					//<size=20>A beer.</size>
					
					if (fancyDisplayType)
					{
						//console.log("aaa");
						if (didBGOrPortraitOrNameChange)
						{
							let storyBox = document.createElement('div');
							storyBox.classList.add('storyImg');
							let bgImage = document.createElement('img');
							bgImage.style = "width:100%;position:relative;z-index:";
							bgImage.src = lastBGUsed;
							storyBox.appendChild(bgImage);
							for(var j=0;j<shownPortraits.length;j++)
							{
								console.assert(shownPortraits[j]);
								let portraitImg = document.createElement('img');
								portraitImg.src = 'pic/'+PORTRAITS[shownPortraits[j][2]][shownPortraits[j][3]];
								//console.log(portraitImg.src);
								
								portraitImg.classList.add("storydoll");
								if (shownPortraits[j][4]==true)
									portraitImg.classList.add('dim')
								portraitImg.classList.add(int2strPos[j+1]);
								portraitImg.classList.add(int2str[shownPortraits.length]);
								storyBox.appendChild(portraitImg);
								
								//If mask (new)
								//<img src="avgtexture/夜间蒙版.png" class="storydoll first one mask" style="mask-image: url(pic/pic_NPC-Helian.png);">
								//Mask is a transparent masked blue image, so we overlay on top of the other img
								if (shownPortraits[j][5]==true)
								{
									let m = maskThing.cloneNode(true);
									m.classList.add(int2strPos[j+1])
									m.classList.add(int2str[shownPortraits.length]);
									m.style = "mask-image: url("+portraitImg.src+");"
									storyBox.appendChild(m);
								}
							}
							thisPartDiv.appendChild(storyBox);
							
							if (lastSpeakerName != "")
							{
								let p = document.createElement('p');
								p.innerText = lastSpeakerName;
								//p.innerHTML = "<b>"+lastSpeakerName+"</b>";
								p.classList.add("storyText");
								p.classList.add("speakerName");
								thisPartDiv.appendChild(p);
							}
							
							didBGOrPortraitOrNameChange = false;
						}
						let p = document.createElement('p');
						p.classList.add('storyText')
						//TODO: This is a great way to get hacked if someone ever decides to insert a <script> tag
						p.innerHTML = message;
						thisPartDiv.appendChild(p);
					}
					else
					{
						let p = document.createElement('p');
						if (lastSpeakerName == "")
							p.innerHTML = message;
						else
							p.innerHTML = lastSpeakerName + ": "+message;
						thisPartDiv.appendChild(p);
					}
					break;
				default:
					//console.log("unknown OPCODES..");
			}
		}
		return thisPartDiv;
		
	//})
	//})
	}
	
	async function run(episode, routableKeyString)
	{
		currentEpisodeAsOpcodes = [];
		curEpisodePart = 0;
		curEpKey = routableKeyString;
		
		
		document.getElementById('chapterName').innerText = episode['name'];
		
		//Instead of just one part, put all of them in the verySimpleText div.
		let NewSimpleTextDiv = document.createElement('div');
		NewSimpleTextDiv.id="verySimpleText";
		
		//Don't keep audio running
		document.getElementById('audioPlayer').pause();
		
		//let partNum = 0;
		for(var p = 0; p < episode.parts.length;p++)
		{
			let fileName = episode.parts[p];
			
			//We have to await so it doesn't load the parts in the wrong order. Which is an actual thing that has happened.
			console.log("fetching "+fileName);
			const response = await fetch("avgtxt/"+fileName);
			const out = await response.text();
			console.log("got "+fileName);
			
			//console.log(fetchTextFile("avgtxt/"+fileName));
			
			//fetch("avgtxt/"+fileName)
			//.then(response => response.text())
			//.then((out) => {
			//fetchTextFile(fileName).then(out => {
			//console.log('got '+fileName);
			//TODO: Add check if it's JSON (iop format) and then use a JSON parser if it is
			let structuredLines = convertGFLTextToOpcodes(out);
			NewSimpleTextDiv.appendChild(renderStructuredLinesToDiv(structuredLines,p));
			//Now replace the old div...
			/*let textboxDiv = document.getElementById("Textboxes");
			textboxDiv.parentNode.replaceChild(newTextboxDiv,textboxDiv);*/
			
			currentEpisodeAsOpcodes.push(structuredLines);
			
		}
		
		//If phaser is already init, go ahead and set the new scene
		//...By destroying the old one and recreating it.
		if (game != undefined)
		{
			game.scene.remove('GirlsFrontlineScene');
			game.scene.add('GirlsFrontlineScene',GirlsFrontlineScene,true);
		}
		let simpleTextDiv = document.getElementById("verySimpleText")
		simpleTextDiv.parentNode.replaceChild(NewSimpleTextDiv,simpleTextDiv);
	}
	
	function reRunWithNewOpcodes()
	{
		let lines = document.getElementById("DebugTextArea").value;
		//console.log(lines);
		let newStructuredLines = stringToStructuredLines(lines);
		console.log(newStructuredLines)
		currentEpisodeAsOpcodes[curEpisodePart] = newStructuredLines;
		if (game != undefined)
		{
			game.scene.remove('GirlsFrontlineScene');
			game.scene.add('GirlsFrontlineScene',GirlsFrontlineScene,true);
		}
	}
	
	function initPhaser()
	{
		game = new Phaser.Game(config);
		let button = document.getElementById("startButton")
		button.style.display = "none";
		document.getElementById("interactiveInterpreterSection").style.display="";
		//button.classList.add("disabled");
		//button.innerText = "started!"
		
	}
	
	/*function fancyDisplayThing()
	{
	
	}*/
	/*function reset()
	{
		game.restart()
	}*/
	
	function showOpcodes(divId) {
		let x = document.getElementById(divId);
		if (x.style.display === "none") {
			x.style.display = "block";
		} else {
			x.style.display = "none";
		}
	}
	
	
	function getRoutableKeyString(type,chapter,episode)
	{
		return type+'-'+chapter+'-'+episode
	}
	function getKeysFromRoutableString(s)
	{
		return s.split('-');
	}
	
	function onChapterSelected(value)
	{
		console.log(value);
		let [type,chapter,episode] = getKeysFromRoutableString(value)
		runFromRoutableKeyString(value)
		if (game == undefined)
			document.getElementById("startButton").classList.remove('disabled');
	}
	function goToNextEpisode()
	{
		let value = curEpKey;
		console.log(value);
		let [type,chapter,episode] = getKeysFromRoutableString(value)
		episode++;
		if (listOfChapters[type][chapter]['episodes'][episode])
		{
			runFromRoutableKeyString(getRoutableKeyString(type,chapter,episode))
			return true;
		}
		else
		{
			chapter++;
			episode = 0;
		}
		
		if (listOfChapters[type][chapter]['episodes'][episode])
		{
			runFromRoutableKeyString(getRoutableKeyString(type,chapter,episode))
			return true;
		}
		
		return false;
	}
	

	
	//I finally used a class, aren't you happy? 
	class FilterableList {
		constructor(data,keyToSearch,idToBind) {
			console.assert(data,"FilterableList: Data undefined!")
			this.data = data;
			this.fuse = new Fuse(data, {
				keys: [keyToSearch]
			})
			this.elementId = idToBind
			
			let el = document.getElementById(idToBind);
			el.innerHTML = "" //You shouldn't have anything in here in the first place
			
			
			let div = document.createElement('div');
			div.id = idToBind+'SearchDiv';
				let form = document.createElement('form');
				form.action = "?";
					let inputField = document.createElement('div');
					inputField.classList.add('input-field');
					inputField.style="text-align: left;";
						let i = document.createElement('i');
						i.classList.add("material-icons");
						i.classList.add('prefix');
						i.innerText="search";
						
						
						let input = document.createElement('input');
						input
						//input.onchange = function(ev) { console.log(ev); this.search(this) }
						input.setAttribute('onkeydown',"if (event.key == 'Enter') blur(); return;");
						input.addEventListener('change',this.search.bind(this) );
						input.id=idToBind+'search'
						input.type='search';
						input.onsubmit="blur()"
						input.required=true
						
					inputField.appendChild(i);
					inputField.appendChild(input);
					
				form.appendChild(inputField);
			div.appendChild(form);
			
			
			//Don't bother, none of it works anyways
			/*let inputFromDOM = document.getElementById(idToBind+'search');
			input.addEventListener('onkeyup',function() { console.log("aa") } );
			input.addEventListener('onkeydown',function() {if (event.key == 'Enter') blur(); return;})*/
			/*<form action="?">
				<div class="input-field" style="text-align: left;">
					<i class="material-icons prefix">search</i>
					<!--<label class="label-icon" for="search">
					</label>-->
					<input id="search" type="search" oninput="searchDolls(document.getElementById('search').value)" onkeydown="if (event.key == 'Enter') blur(); return;" onsubmit="blur()" required>
					
					<i class="material-icons" onclick="clearSearch()">close</i>
				</div>
			</form>*/
			
			el.appendChild(div);
			
			this.collection = document.createElement('div');
			this.collection.classList.add('collection');
			//this._li_=document.createElement('li');
			this._li_=document.createElement('a');
			this._li_.href="#theTop";
			this._li_.classList.add('collection-item');
			/*this._li_.classList.add('waves-effect');
			this._li_.classList.add('waves-light');
			this._li_.style="cursor:pointer;";*/
			
			el.appendChild(this.collection);
			
			this.generateResults(this.data);
		}
		
		//It's just like lua Kappa
		search()
		{
			console.assert(this)
			let query = document.getElementById(this.elementId+'search').value
			console.log(query);
			clearTimeout(this.delayTimer);
			this.delayTimer = setTimeout(function() {
				
				if (query == "" || query == undefined)
				{
					this.generateResults(this.data);
				}
				else
				{
					
					/*query = query.toLowerCase();
					console.log("Searching for "+query);*/
					
					var results = this.fuse.search(query);
					console.log("Got "+results.length + " results");
					//I don't care if it's slow
					this.generateResults(Array.from(results, r => r['item']));
				}
			}.bind(this), 300);
		}
		
		generateResults(results)
		{
			console.log(results);
			this.collection.innerHTML="";
			for (var i = 0; i < results.length; i++)
			{
				let li = this._li_.cloneNode(true);
				li.innerText=results[i]['name'];
				this.collection.appendChild(li);
			}
		}
		
	}
	
	//name field is structured like type-chapter-episode
	listOfChapters=false;
	
	function generateTables() {
		
		console.log(listOfChapters);
		//return listOfChapters;
		/*var _table_ = document.createElement('table'),
			_tr_ = document.createElement('tr'),
			_th_ = document.createElement('th'),
			_td_ = document.createElement('td'),
			_select_ = document.createElement('select'),
			_option_ = document.createElement('option');*/
		
		//var table = document.getElementById("table");
		//let thead = document.createElement("thead");
		//thead.innerHTML = "<tr><th colspan='"+listOfChapters.length+"'>Pick a chapter</th></tr>"
		//table.appendChild(thead);
		
		//Behold, the most god awful code ever written
		//let tbody = document.createElement('tbody');
		
		/*let trChapterNames = _tr_.cloneNode(false);
		for(i=0;i<listOfChapters.length;i++)
		{
			let td = _td_.cloneNode(false);
			td.appendChild(document.createTextNode(listOfChapters[i]['name']));
			trChapterNames.appendChild(td);
		}
		tbody.appendChild(trChapterNames);*/
		
		var _dropDownTrigger_ = document.createElement('a');
		_dropDownTrigger_.href = "#";
		_dropDownTrigger_.classList.add('dropdown-trigger');
		_dropDownTrigger_.classList.add('btn');
		
		var _dropDown_ = document.createElement('ul');
		_dropDown_.classList.add('dropdown-content');
		
		var _li_ = document.createElement('li'),
			_a_ = document.createElement('a');
		
		//No idea what this is supposed to do.
		_a_.href="#!";
		
		for (const key in listOfChapters)
		{
			//console.log(key)
			let episodeContainer = document.getElementById(key+'Episodes')
			//let trChapterDropdowns = _tr_.cloneNode(false);
			//let trChapterDropdowns = 
			for(i=0;i<listOfChapters[key].length;i++)
			{
				//let td = _td_.cloneNode(false);
				let flexBoxDiv = document.createElement('div');
				/*let select = _select_.cloneNode(false);
				select.setAttribute('id',"selectChapter"+i)
				select.setAttribute('onchange','onChapterSelected(value);');*/
				let dropDownTrigger = _dropDownTrigger_.cloneNode(true)
				dropDownTrigger.setAttribute('data-target','dropdown-'+key+'-'+i)
				dropDownTrigger.innerText=listOfChapters[key][i]['name']
				
				let dropdown = _dropDown_.cloneNode(true);
				dropdown.id = 'dropdown-'+key+'-'+i;
				
				//Generate chapter name first..
				/*let optChName = _option_.cloneNode(false);
				optChName.setAttribute("selected","");
				optChName.setAttribute("disabled","");
				optChName.innerText=listOfChapters[key][i]['name'];
				select.appendChild(optChName);*/
				
				//Now let's do the episodes
				let curChapter = listOfChapters[key][i]['episodes'];
				for(j=0;j<curChapter.length;j++)
				{
					
					let ep = _li_.cloneNode(true);
					ep.innerHTML = "<a href='#"+getRoutableKeyString(key,i,j)+"' onclick=\"onChapterSelected('"+getRoutableKeyString(key,i,j)+"')\">"+curChapter[j]['name']+"</a>"
					dropdown.appendChild(ep);
					/*let option = _option_.cloneNode(false);
					option.value=getRoutableKeyString(key,i,j)
					option.innerText=curChapter[j]['name'];
					select.appendChild(option);*/
				}
				//flexBoxDiv.appendChild(select);
				flexBoxDiv.appendChild(dropDownTrigger);
				flexBoxDiv.appendChild(dropdown);
				
				episodeContainer.appendChild(flexBoxDiv);
				//td.appendChild(select);
				//trChapterDropdowns.appendChild(td);
			}
		}
		
		//test = new FilterableList(listOfChapters['side'][0]['episodes'],'name',"sideEpisodesWrapper")

		//tbody.appendChild(trChapterDropdowns);
		
		//table.appendChild(thead);
		//table.appendChild(tbody);
		
	}
	
	//materialize.js makes it irrelevant
	/*function showSelectedEpisodes(id)
	{
		let episodesDivs = document.getElementById("Episodes").children;
		for (var i = 0; i < episodesDivs.length;i++){
			if (episodesDivs[i].id == id)
				episodesDivs[i].style="";
			else
				episodesDivs[i].style="display: none;"
		}
		//console.log(episodesDiv.children);
	}*/
	
	//T-Doll search shit
	let frontlinedex = null;
	let CharacterVoice = null;
	
	let dialogueKeysToEnglish = {
		'dialogue1':"Adjutant 1",
		'dialogue2':"Adjutant 2",
		'dialogue3':"Adjutant 3",
		'soulcontract':"Marriage Line",
		'introduce':"Introduction (In the index, but usually identical to obtain)",
		'gain':'When Obtained',
		'allhallows':"During Halloween",
		'christmas':"During Christmas",
		'valentine':"During Valentine's",
		'dialoguewedding':"Adjutant 4 (After Marriage)"
	}
	
	function TDollInfo(dollName)
	{
		/*console.log(dollName);
		console.assert(CharacterVoice)
		console.log(CharacterVoice);*/
		//Destroy everything in here
		let tDollDialogue = document.getElementById('tDollDialogue')
		tDollDialogue.innerHTML = "";
		/*let ul = document.createElement("ul");
		ul.className = 'collapsible'*/
		let _div_ = document.createElement('div');
		_div_.classList.add("card");
		let _cardContent = document.createElement('div');
		_cardContent.classList.add("card-content");
		let dialogue = CharacterVoice[dollName];
		if (dialogue)
		{
			Object.keys(dialogue).forEach(key => {
				let card = _div_.cloneNode(true);
				let cardContent = _cardContent.cloneNode(true);
				let cardTitle = document.createElement('span');
				cardTitle.classList.add('card-title');
				if (dialogueKeysToEnglish[key])
					cardTitle.innerText = dialogueKeysToEnglish[key];
				else
					cardTitle.innerText = key;
				let p = document.createElement('p');
				//console.log(typeof dialogue[key]);
				p.innerHTML= dialogue[key].join([separator = '<br>'])
				cardContent.appendChild(cardTitle);
				cardContent.appendChild(p);
				card.appendChild(cardContent);
				tDollDialogue.appendChild(card);
			});
			
			
			document.getElementById('tDollDialogueName').firstChild.textContent=dollName;
			//document.getElementById('tDollDialogueName').setAttribute('href',"#tDollSearch"+dollName)
			M.Modal.getInstance(document.getElementById('tDollDialogueActivity')).open()
			//jump to top of page
			//window.location.href="#tDollDialogueActivity"
		}
		else
		{
			//console.log("aa");
			M.toast({html: "T-Doll "+dollName+" not present in json..."})
		}
		//document.getElementById('tDollDialogue').appendChild(_div_);
	}
	
	function listResults(results)
	{
		//console.log(results);
			/*<li class="collection-item avatar">
		  <img src="images/yuna.jpg" alt="" class="circle">
		  <span class="title">Title</span>
		  <p>First Line <br>
		     Second Line
		  </p>
		  <a href="#!" class="secondary-content"><i class="material-icons">grade</i></a>
		</li>*/
		//Destroy everything inside the div.
		document.getElementById("SearchResultsDiv").innerHTML = "";
		var ul = document.createElement("ul");
		ul.className= "collection";
		ul.id = "SearchResults";
		for (var i=0, n=results.length; i<n; ++i)
		{
			//let result = frontlinedex[results]
			var li = document.createElement("li");
			li.className = "collection-item avatar waves-effect"; //waves-effect waves-light
			li.style.display = '';
			
			
			var icon = document.createElement("i");
			icon.className = "material-icons circle red";
			li.appendChild(icon);
			
			var span = document.createElement("span");
			span.className = "title";
			span.innerText = results[i].name;
			li.appendChild(span);
			
			var p = document.createElement("p");
			p.innerHTML = results[i].type + " <br> No." + (results[i].num>0 ? results[i].num : "?");
			li.appendChild(p);
			
			//You're probably gonna say this is terrible and blah blah but T-Doll names are unique anyways
			/*for (var j =0; j < frontlinedex.length;j++)
			{
				
			}*/
			if (results[i].internalName)
			{
				li.setAttribute("onclick","TDollInfo(\""+results[i].internalName+"\")")
				li.id = "tDollSearch"+results[i].internalName
			}
			
			
			//Handle stars
			var secondaryContent = document.createElement("div");
			secondaryContent.className = "secondary-content";
			num2stars(secondaryContent,results[i].rating)
			li.appendChild(secondaryContent);
			
			ul.appendChild(li);
		}
		
		document.getElementById("SearchResultsDiv").appendChild(ul);
	}
	
	var delayTimer;
	function searchDolls(query)
	{
		clearTimeout(delayTimer);
		delayTimer = setTimeout(function() {
			
			if (query == "" || query == undefined)
			{
				listResults(frontlinedex);
			}
			else
			{
				
				query = query.toLowerCase();
				/*for (var i=0, n=frontlinedex.length; i<n; ++i)
				{
					if ('alias' in frontlinedex[i] && query == frontlinedex[i]['alias'].toLowerCase())
					{
						console.log("Found alias for "+frontlinedex[i]['name']);
						//console.log(frontlinedex[i]);
						listResults([frontlinedex[i]]);
						return true;
					}
				}*/
				console.log("Searching for "+query);
				
				var results = fuse.search(query);
				console.log("Got "+results.length + " results");
				//I don't care if it's slow
				listResults(Array.from(results, r => r['item']));
			}
		}, 300);
	}
	
	function FetchTDollInfo()
	{
		if (frontlinedex != null && CharacterVoice != null)
			return;
		fetch("girlsfrontline-min.json")
		.then(response => response.json())
		.then(json => {
			console.log("girlsfrontline-min loaded!");
			console.log(json);
			
			frontlinedex = json;
			
			/*fetch("gf_flavortext.json").then(response => response.json()).then(json2 => {
				console.log("Bonus information loaded.");
				console.log("Injecting aliases and quotes...");
				bonusdex = json2;
				frontlinedex.forEach(doll => {
					if (doll['name'] in bonusdex)
					{
						if ('alias' in bonusdex[doll['name']])
							doll['alias'] = bonusdex[doll['name']]['alias']
					}
				})
				console.log("Done.");
			});*/
			
			fuse = new Fuse(frontlinedex, {
				keys: ['name']
			})
			//fuse = new Fuse(Object.keys(frontlinedex));
			

			
			listResults(frontlinedex);
		});
		
		fetch('CharacterVoicePlus.json')
		.then(response => response.json())
		.then(json => {
			console.log("NewCharacterVoice.json loaded!");
			CharacterVoice = json;
		});
	}
	
	
	//Keep this at the bottom
	window.onload=function()
	{
		document.getElementById('fancyOrNot').checked = getCookie('fancyText');
		setCheckboxFromCookie('showInteractiveInterpreter',false);
		hideInterpreterButton();
		setCheckboxFromCookie('showDebugOpcodeButton',false);
		setCheckboxFromCookie('chapterHistoryRouting',true);
	
		fetch('chapterDatabase.json')
		.then(response => response.json())
		.then(json => {
			console.log("chapters loaded!");
			listOfChapters = json
			generateTables();
			document.querySelectorAll('.dropdown-trigger').forEach(elems => {
				var instances = M.Dropdown.init(elems, {constrainWidth:false});
			});
			
			//Can't run until chapters are loaded
			if (document.getElementById('chapterHistoryRouting').checked)
			{
				runFromRoutableKeyString(window.location.hash.slice(1));
			}
		});
		
		document.querySelectorAll('.tabs').forEach(el => {
			var instance = M.Tabs.init(el, null);
			//instance.updateTabIndicator();
		});
		
		/*document.querySelectorAll('.dropdown-trigger').forEach(elems => {
			var instances = M.Dropdown.init(elems, {constrainWidth:false});
		});*/
		
		 
		document.querySelectorAll('.collapsible').forEach(elems => {
			var instances = M.Collapsible.init(elems, null);
		});
		
		document.querySelectorAll('.modal').forEach(el => {
			var instance = M.Modal.init(el, null);
			//instance.updateTabIndicator();
		});
		
		fetch('portraitInformation.json')
			.then(response => response.json())
			.then(json => {
				console.log("portraitinformation.json loaded!");
				PORTRAITS = json;
			});
		
		// Select the button
		//const btn = document.querySelector(".nightMode-toggle");
		// Check for dark mode preference at the OS level
		const prefersDarkScheme = window.matchMedia("(prefers-color-scheme: dark)");
		// Get the user's theme preference from local storage, if it's available
		//const currentTheme = localStorage.getItem("theme");
		const currentTheme = getCookie('theme');
		//print(currentTheme);


		// If the user's preference in localStorage is dark...
		if (currentTheme == "")
		{
			document.body.classList.toggle(prefersDarkScheme ? "dark-theme" : "light-theme")
			setCookie('theme',prefersDarkScheme ? "dark-theme" : "light-theme",180);
		}
		else if (currentTheme == "black-theme") {
			document.body.classList.toggle("black-theme");
			isDarkMode=true
		}
		else if (currentTheme == "dark-theme") {
		  // ...let's toggle the .dark-theme class on the body
		  document.body.classList.toggle("dark-theme");
		  isDarkMode=true
		// Otherwise, if the user's preference in localStorage is light...
		} else {
		  // ...let's toggle the .light-theme class on the body
		  document.body.classList.toggle("light-theme");
		  isDarkMode=false;
		}
		
		document.getElementById("textarea1").value = `portrait;0;FAIL;0;false;false;
speaker;El Fail
bgm;intro_number_61
bg;140
msg;Hello world!
msg;<color=#00CCFF>This is colored text.</color>
msg;As you can see, this section is still a work in progress. So you should probably check back later.
portrait;0;FAIL;0;true;false;
portrait;1;NytoIsomer;4;false;false;
speaker;Dandelai;
msg;<color=#1aff1a>Make sure you save your work in a text file, as it will not be saved here.</color>`
	}
	
	function setCheckboxFromCookie(idOfCheckbox,defaultValueIfNotSet)
	{
		let c = getCookie(idOfCheckbox);
		if (c==undefined || c=="")
		{
			c=defaultValueIfNotSet;
			setCookie(idOfCheckbox,defaultValueIfNotSet,180);
		}
		//console.assert(c);
		console.log("Setting "+idOfCheckbox+" to "+c);
		document.getElementById(idOfCheckbox).checked = (c=='true');
	}
	function setCookieFromCheckbox(idOfCheckbox)
	{
		setCookie(idOfCheckbox,document.getElementById(idOfCheckbox).checked,180);
	}
	
	function hideInterpreterButton()
	{
		if (!document.getElementById('showInteractiveInterpreter').checked)
		{
			document.getElementById("startButton").style="display:none"
		}
		else
		{
			document.getElementById("startButton").style=""
		}
	}


	
</script>
<body>
	<!--<h1 id="theTop">GFL Cutscene Intrepeter (very alpha)</h1>
	<!--<h2>...And a way to read the game dialogue.</h2>-->
  <nav class='nav-extended'>
    <div class="nav-wrapper" id='theTop' style="overflow:hidden;">
      <a href="#" class="brand-logo center" style="text-overflow: ellipsis; white-space: nowrap;">
      	<span class='header-desktop'>GFL Cutscene Intrepeter (beta)</span>
      	<span class='header-desktop-shorter'>GFL Cutscene Intrepeter</span>
      	<span class='header-mobile'>GFL C.I.</span>
      	
	</a>
	
      <ul id="nav-mobile" class="right">
        <li><a href="#!" onclick="NightMode()" class="waves-effect waves-light navbarButton"><i class="material-icons left">brightness_2</i><span class='header-desktop'>Night Mode</span></a></li>
        <li><a href="#settingsModal" class="waves-effect waves-light modal-trigger navbarButton"><i class="material-icons left">settings</i><span class='header-desktop'>Settings</span></a></li>
      </ul>
    </div>
			<div class="col s12 nav-content">
				<ul class="tabs tabs-transparent">
					<li class="tab col s3"><a href="#mainEpisodesWrapper">Main Story Chapters</a></li>
					<li class="tab col s3"><a href="#eventEpisodesWrapper">Story Events</a></li>
					<li class="tab col s3"><a href="#sideEpisodesWrapper">Side Stories</a></li>
					<li class="tab col s3"><a href="#crossoverEpisodesWrapper">Crossover Stories</a></li>
					<li class="tab col s3"><a href="#TDollStuff" onclick="FetchTDollInfo()">T-Doll Dialogue (WIP)</a></li>
					<li class="tab col s3"><a href="#customCutsceneWrapper">Write your own cutscene (WIP)</a></li>
				</ul>
			</div>
  </nav>

	<!-- Modal Structure -->
	<div id="settingsModal" class="modal">
		<div class="modal-content">
		  <h4>Settings</h4>

		<table class="material-settings-table">
			<tr>
				<td style="width:100%">
					<span class="title">Display images and portraits in cutscenes</span>
					<p>Turn it off if you want to save your mobile data.</p>
				</td>
				<td>
					<div class="switch">
						<label>
						  <input type="checkbox" onclick="runFromRoutableKeyString()" id="fancyOrNot">
						  <span class="lever"></span>
						</label>
					</div>
				</td>
			</tr>
			<tr>
				<td style="width:100%">
					<span class="title">Show interactive interpreter button</span>
					<p>Not every browser supports the interactive interpreter and it happens to be very buggy.</p>
				</td>
				<td>
					<div class="switch">
						<label>
						  <input type="checkbox" id="showInteractiveInterpreter" onclick="setCookieFromCheckbox('showInteractiveInterpreter'); hideInterpreterButton()">
						  <span class="lever"></span>
						</label>
					</div>
				</td>
			</tr>
			<tr>
    			<td style="width:100%">
    				<span class="title">Last chapter history</span>
    				<p>Upon reloading the page, returns you to the last viewed cutscene by using the routing string (The string after the # on your URL bar).</p>
    			</td>
    			<td>
					<div class="switch">
						<label>
						  <input type="checkbox" id="chapterHistoryRouting" onclick="setCookieFromCheckbox('chapterHistoryRouting')">
						  <span class="lever"></span>
						</label>
					</div>
				</td>
			</tr>
			<tr>
				<td style="width:100%">
					<span class="title">Show opcode debug buttons</span>
					<p>Displays buttons for showing debug opcodes in cutscenes. You probably don't want this enabled.</p>
				</td>
				<td>
					<div class="switch">
						<label>
						  <input type="checkbox" id="showDebugOpcodeButton" onclick="setCookieFromCheckbox('showDebugOpcodeButton')">
						  <span class="lever"></span>
						</label>
					</div>
				</td>
			</tr>
		</table>
		</div>
		<div class="modal-footer">
		  <a href="#!" class="modal-close waves-effect waves-green btn-flat">Close</a>
		</div>
	</div>
	<!-- Needs to be here so the modal for T-Doll search will be fullscreen on mobile devices. Otherwise it will be below the navbar.-->
	<div id="tDollDialogueActivity" class="modal modal-fixed-footer" style="overflow:hidden">
		<nav style="position:initial;">
			<div class="nav-wrapper blue" style="text-align: left;">
			  <a href="#!" class="brand-logo modal-close" id='tDollDialogueName'>Insert T-Doll Name Here<i class="material-icons">arrow_back</i></a>
			</div>
		</nav>
		<div id="tDollDialogue" class='modal-content'>
		
		</div>
	</div>
  
	<noscript><h1>Turn on JavaScript. This is not a static webpage, it is literally interpreting the GFL text on the fly using JS and rendering it to HTML elements to display it in your browser.</h1></noscript>
	<noscript><h3>Static HTTP pages are coming never. You'll have to look at the source code and write it yourself.</h3></noscript>
	<div id='chapterSelect' class='navbar-fixed'>
		<div class='row'>
			<!--<a href=#modal1" class="modal-trigger" >Settings</a>-->

			<!--Because materialize.js is stupid -->
			<div class="col s12" id="mainEpisodesWrapper">
				<div class="flex-container col s12" id="mainEpisodes"></div>
			</div>
			
			<div class="col s12" id="eventEpisodesWrapper">
				<div class="flex-container col s12" id="eventEpisodes"></div>
			</div>
			<div class="col s12" id="sideEpisodesWrapper">
				<div class="flex-container col s12" id="sideEpisodes"></div>
			</div>
			<div class="col s12" id="crossoverEpisodesWrapper">
				<div class="flex-container col s12" id="crossoverEpisodes"></div>
			</div>
			<div class="col s12" id="TDollStuff">
				<!--I don't know how to do iframes or AJAX, apparently-->
				<!--<iframe src="quoteBrowser.html"></iframe>-->

				<div id="tDollSearchActivity">
					<form action="?">
					<div class="input-field" style="text-align: left;">
						<i class="material-icons prefix">search</i>
						<!--<label class="label-icon" for="search">
						</label>-->
						<input id="search" type="search" oninput="searchDolls(document.getElementById('search').value)" onkeydown="if (event.key == 'Enter') blur(); return;" onsubmit="blur()" required>
						
						<i class="material-icons" onclick="clearSearch()">close</i>
					</div>
					</form>
					
					<div id="SearchResultsDiv"  class="" >
						<p>If you are seeing this it's still loading, please wait 1 second for the JSON to load</p>
						<p>Either that or your browser is broken, please check for an update.</p>
						<div class="progress">
						  <div class="indeterminate"></div>
						</div>
		    
					</div>
				</div>
			</div>
			<div class="col s12" id="customCutsceneWrapper">
				<div id="customCutscene">
					<p>WORK IN PROGRESS - IGNORE THE TERRIBLE UI</p>
					<p>These buttons don't do anything yet, but you can type in the textbox below and run your custom cutscene.</p>
					<a class="waves-effect waves-light btn" onclick="document.getElementById('file-input-txt').click();"><i class="material-icons right">folder_open</i>Load .txt</a>
					<a class="waves-effect waves-light btn" onclick="document.getElementById('file-input-json').click();"><i class="material-icons right">folder_open</i>Load .iop.json</a>
					<input id="file-input-txt" type="file" name="name" style="display: none;" />
					<input id="file-input-json" type="file" name="name" style="display: none;" />
			        <!--<div class="input-field col s12">
						<textarea id="textarea1" class="materialize-textarea"></textarea>
						<label for="textarea1">Textarea</label>
					</div>-->
					<textarea id="textarea1" class="materialize-textarea"></textarea>
					<a class="waves-effect waves-light btn" onclick="runFromUserInput();"><i class="material-icons right">code</i>Run!</a>
				    <div class="card blue-grey darken-1" style="text-align:left">
        				<div class="card-content white-text">
						<span class="card-title">About .txt vs .iop.json</span>
						<p>.txt is the cutscene scripting language GFL uses. The interpreter will always support importing .txt and playing it back.</p>
						<p>.iop.json (<b>I</b>ntermediate <b>Op</b>codes, definitely not a coincidence) is the scripting language designed for the interpreter. It has some advantages compared to the GFL engine:</p>
						<p>- Display more than two characters at a time. Dim multiple charcters. Dim no characters.</p>
						<p>- Dimming doesn't randomly break, because dimming is manually set. </p>
						<p>- The commands are in english. It's also very verbose.</p>
						<p>- You can use + in messages. (GFL's txt script treats + as 'next line')</p>
						<p>- (Coming soon) branch paths, allowing you to use the interpreter like a VN engine of sorts and write interactive stories</p>
						<p>- Load multiple parts, since the only reasonable way to have more than one part would be to use JSON.</p>
						<p>The disadvantages:</p>
						<p>- The verbosity will make you type a lot.</p>
						<p>- Since dimming is manually done, it might get confusing.</p>
						<p>- Good luck memorizing all 5 arguments for a message opcode.</p>
						</div>
					</div>
					<div class="card blue-grey darken-1" style="text-align:left">
        				<div class="card-content white-text">
							<span class="card-title">How to specify a background?</span>
							<p>Backgrounds are stored in the avgtexture folder and indexed in-game with profiles.txt.</p>
							<p>As displaying every single image would be disasterous and I only have about 500GB of bandwidth per month on this webserver, please click the link below to show an image of all the backgrounds with IDs arranged in a neat grid.</p>
						</div>
						<div class="card-action">
							<a href="#">BG picker helper (Jk it doesn't exist yet)</a>
						</div>
					</div>
					<div class="card blue-grey darken-1" style="text-align:left">
        				<div class="card-content white-text">
							<span class="card-title">How to specify a portrait?</span>
							<p>Portraits are in the format of: idx;name;type;dim;isMasked</p>
							<p>Arguments 4 and 5 can be omitted, they will automatically be converted to false.<p>
							<p>idx - Which side. 0 for left, 1 for right. (indexes above 1 are not supported currently)</p>
							<p>name - The internal name of the T-Doll. Hint: Ctrl+F portraitInformation.json</p>
							<p>type - Usually costume, sometimes expression</p>
							<p>dim (optional) - true for dim, false for not dim</p>
							<p>isMasked (optional) - like dim</p>
						</div>
						<div class="card-action">
							<a href="/portraitInformation.json">portraitInformation.json</a>
						</div>
					</div>
					<div class="card blue-grey darken-1" style="text-align:left">
        				<div class="card-content white-text">
							<span class="card-title">How to specify music?</span>
							<p>Music is just the filename.</p>
							<p>The file index is enabled. Click the button to see all the files.</p>
							<p>Alternatively you can use the dropdown and it will paste a bgm command at the end. As it is still WIP and has to be updated manually, you're better off using the index.</p>
						</div>
						<div class="card-action">
							<a href="/audio">Index</a>
							<a href="#" class='dropdown-trigger' data-target='dropdownMusic'>Select by name</a>
						</div>
					</div>
					  <!-- Dropdown Structure -->
					  <ul id='dropdownMusic' class='dropdown-content'>
						<li><a href="#!">one</a></li>
						<li><a href="#!">two</a></li>
					  </ul>
					<!--<ul class="collapsible">
						<li>
						  <div class="collapsible-header">About .txt vs .iop.json</div>
						  <div class="collapsible-body"></div>
						</li>
					</ul>-->
				</div>
			</div>
				
		</div>
		
	</div>
	  
	<!--<h2><a href="#Textboxes">Mobile devices are stupid and the canvas absorbs touch, so click here to jump to the part without the canvas</a></h2>-->
	<h2 id="chapterName">Chapter Name Here</h2>
    <a id="startButton" onclick="initPhaser()" class="waves-effect waves-light btn disabled">Start interactive interpreter (It's like playing the game!)</a>
	<div id="interactiveInterpreterSection" style="display:none;">
		<a id='stopButton' class="waves-effect waves-light btn"> Stop the interpreter (You'll have to refresh the site to start it up again, sorry)</a>
		<p id="curIndexDebug"></p>
		<div id="phaser"></div>
		<br><br><button onclick="showOpcodes('myDIV')">Show converted opcodes (For debugging)</button><br>
		<div id='myDIV' style="display: none;">
			<textarea rows='6' cols='50' id="DebugTextArea"></textarea><br>
			<button onclick="reRunWithNewOpcodes()">Re-run scene with these opcodes</button>
		</div>
	</div>

	<hr>

	<div id="verySimpleText"></div>
	<a class="waves-effect waves-light btn" href="#theTop"><i class="material-icons left">vertical_align_top</i>Back to top</a> <a class="waves-effect waves-light btn" href="#theTop" onclick="goToNextEpisode();"><i class="material-icons left">chevron_right</i>Go to the next cutscene</a>
	<hr>
	<audio controls loop id="audioPlayer">
		<source src="" type="audio/ogg"> <!-- Turns out putting something in makes firefox load it when you load the page, wasting bandwidth. But leaving it blank is fine. -->
		Your browser does not support the audio tag.
	</audio>
	<p>Dandelai is my wife, greets to /gfg/, <a href="https://github.com/RhythmLunatic/gfl-cutscene-interpreter">harass me on github (bug reports, check the source code, fork it)</a></p>
	<p>If you would like an improved UI, fix it yourself and submit a pull request. I don't know React/Vue/etc.</p>
	<p>If you want a feature or something is broken, <b><a href="https://github.com/RhythmLunatic/gfl-cutscene-interpreter/issues">file a bug report</a></b></p>
	<p><a href='/LICENSE.html'>The interpreter is free and open source software and licensed under AGPLv3.</a></p>
	<p><a href='https://github.com/MatheusAvellar/textarea-line-numbers'>Textarea line numbers</a> by MatheusAvellar. Some modifications made for modifying elements directly instead of through ID.</p>
	<br>
	<!--<a href="https://github.com/RhythmLunatic/Girls-Frontline-Discord-Search">Try out my Girls' Frontline discord bot. T-Doll info, quotes, costumes, and more!</a>-->
</body>
